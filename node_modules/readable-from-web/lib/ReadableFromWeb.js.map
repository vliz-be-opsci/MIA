{"version":3,"file":"ReadableFromWeb.js","sourceRoot":"","sources":["ReadableFromWeb.ts"],"names":[],"mappings":";;;AAAA,qDAAiE;AAEjE,MAAM,eAAmB,SAAQ,0BAAQ;IAIvC,YAAmB,MAAyB,EAAE,OAAyB;QACrE,KAAK,CAAC,OAAO,CAAC,CAAC;QACf,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC,SAAS,EAAE,CAAC;QACjC,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC;QAC1B,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE;YAC3B,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;QAC3B,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,KAAY,EAAE,EAAE;YACxB,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;YACzB,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;QACtB,CAAC,CAAC,CAAC;IACL,CAAC;IAED,gDAAgD;IACzC,KAAK;QACV,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE;aACf,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;aACzD,KAAK,CAAC,CAAC,KAAY,EAAE,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;IAClD,CAAC;IAEM,OAAO,CAAC,KAAa;QAC1B,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE,CAAC;YACvB,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,EAAE,CAAC,KAAK,CAAC,GAAG,EAAE;gBAC1C,yDAAyD;gBACzD,2EAA2E;gBAC3E,mDAAmD;YACrD,CAAC,CAAC,CAAC;QACL,CAAC;QACD,OAAO,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;IAC9B,CAAC;CACF;AAMQ,0CAAe;AAJxB,SAAS,eAAe,CAAI,MAAyB,EAAE,OAAyB;IAC9E,OAAO,IAAI,eAAe,CAAI,MAAM,EAAE,OAAO,CAAC,CAAC;AACjD,CAAC;AAEyB,0CAAe","sourcesContent":["import { Readable, type ReadableOptions } from 'readable-stream';\n\nclass ReadableFromWeb<T> extends Readable {\n  private readonly reader: ReadableStreamDefaultReader<T>;\n  private readerClosed: boolean;\n\n  public constructor(stream: ReadableStream<T>, options?: ReadableOptions) {\n    super(options);\n    this.reader = stream.getReader();\n    this.readerClosed = false;\n    this.reader.closed.then(() => {\n      this.readerClosed = true;\n    }).catch((error: Error) => {\n      this.readerClosed = true;\n      this.destroy(error);\n    });\n  }\n\n  // eslint-disable-next-line ts/naming-convention\n  public _read(): void {\n    this.reader.read()\n      .then(chunk => this.push(chunk.done ? null : chunk.value))\n      .catch((error: Error) => this.destroy(error));\n  }\n\n  public destroy(error?: Error): this {\n    if (!this.readerClosed) {\n      this.reader.cancel(error).then().catch(() => {\n        // Ideally, the error from cancel should be handled here.\n        // However, an error thrown in cancel does not seem to reach this callback.\n        // Therefore, the error is simply not handled here.\n      });\n    }\n    return super.destroy(error);\n  }\n}\n\nfunction readableFromWeb<T>(stream: ReadableStream<T>, options?: ReadableOptions): Readable {\n  return new ReadableFromWeb<T>(stream, options);\n}\n\nexport { ReadableFromWeb, readableFromWeb };\n"]}