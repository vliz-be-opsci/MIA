{"version":3,"file":"RdfStore.js","sourceRoot":"","sources":["RdfStore.ts"],"names":[],"mappings":"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","sourcesContent":["import type { EventEmitter } from 'events';\nimport type * as RDF from '@rdfjs/types';\nimport type { AsyncIterator } from 'asynciterator';\nimport { wrap } from 'asynciterator';\nimport { DataFactory } from 'rdf-data-factory';\nimport type { QuadTermName } from 'rdf-terms';\nimport { matchPattern, QUAD_TERM_NAMES } from 'rdf-terms';\nimport { DatasetCoreWrapper } from './dataset/DatasetCoreWrapper';\nimport type { ITermDictionary } from './dictionary/ITermDictionary';\nimport { TermDictionaryNumberRecordFullTerms } from './dictionary/TermDictionaryNumberRecordFullTerms';\nimport { TermDictionaryQuotedIndexed } from './dictionary/TermDictionaryQuotedIndexed';\nimport type { IRdfStoreIndex } from './index/IRdfStoreIndex';\nimport { RdfStoreIndexNestedMapQuoted } from './index/RdfStoreIndexNestedMapQuoted';\nimport type { IRdfStoreOptions } from './IRdfStoreOptions';\nimport { getBestIndex, orderQuadComponents, quadToPattern } from './OrderUtils';\nimport type { EncodedQuadTerms, QuadPatternTerms } from './PatternTerm';\n\n/**\n * An RDF store allows quads to be stored and fetched, based on one or more customizable indexes.\n */\nexport class RdfStore<E = any, Q extends RDF.BaseQuad = RDF.Quad> implements RDF.Store<Q> {\n  public static readonly DEFAULT_INDEX_COMBINATIONS: QuadTermName[][] = [\n    [ 'graph', 'subject', 'predicate', 'object' ],\n    [ 'graph', 'predicate', 'object', 'subject' ],\n    [ 'graph', 'object', 'subject', 'predicate' ],\n  ];\n\n  public readonly options: IRdfStoreOptions<E, Q>;\n  public readonly dataFactory: RDF.DataFactory<Q>;\n  public readonly dictionary: ITermDictionary<E>;\n  public readonly indexesWrapped: IRdfStoreIndexWrapped<E>[];\n  private readonly indexesWrappedComponentOrders: QuadTermName[][];\n  public readonly features = { quotedTripleFiltering: true };\n\n  private _size = 0;\n\n  public constructor(options: IRdfStoreOptions<E, Q>) {\n    this.options = options;\n    this.dataFactory = options.dataFactory;\n    this.dictionary = options.dictionary;\n    this.indexesWrapped = RdfStore.constructIndexesWrapped(options);\n    this.indexesWrappedComponentOrders = this.indexesWrapped.map(indexThis => indexThis.componentOrder);\n  }\n\n  /**\n   * Create an RDF store with default settings.\n   * Concretely, this store stores triples in GSPO, GPOS, and GOSP order,\n   * and makes use of in-memory number dictionary encoding.\n   */\n  public static createDefault(): RdfStore<number> {\n    return new RdfStore<number>({\n      indexCombinations: RdfStore.DEFAULT_INDEX_COMBINATIONS,\n      indexConstructor: subOptions => new RdfStoreIndexNestedMapQuoted(subOptions),\n      dictionary: new TermDictionaryQuotedIndexed(new TermDictionaryNumberRecordFullTerms()),\n      dataFactory: new DataFactory(),\n    });\n  }\n\n  /**\n   * Internal helper to create index objects.\n   * @param options The RDF store options object.\n   */\n  public static constructIndexesWrapped<E, Q extends RDF.BaseQuad = RDF.Quad>(\n    options: IRdfStoreOptions<E, Q>,\n  ): IRdfStoreIndexWrapped<E>[] {\n    const indexes: IRdfStoreIndexWrapped<E>[] = [];\n    if (options.indexCombinations.length === 0) {\n      throw new Error('At least one index combination is required');\n    }\n    for (const componentOrder of options.indexCombinations) {\n      if (!RdfStore.isCombinationValid(componentOrder)) {\n        throw new Error(`Invalid index combination: ${componentOrder}`);\n      }\n      indexes.push({\n        index: options.indexConstructor(options),\n        componentOrder,\n        componentOrderInverse: <any>Object.fromEntries(componentOrder.map((value, key) => [ value, key ])),\n      });\n    }\n    return indexes;\n  }\n\n  /**\n   * Check if a given quad term order is valid.\n   * @param combination A quad term order.\n   */\n  public static isCombinationValid(combination: QuadTermName[]): boolean {\n    for (const quadTermName of QUAD_TERM_NAMES) {\n      if (!combination.includes(quadTermName)) {\n        return false;\n      }\n    }\n    return combination.length === 4;\n  }\n\n  /**\n   * The number of quads in this store.\n   */\n  public get size(): number {\n    return this._size;\n  }\n\n  /**\n   * Add a quad to the store.\n   * @param quad An RDF quad.\n   * @return boolean If the quad was not yet present in the index.\n   */\n  public addQuad(quad: Q): boolean {\n    const quadEncoded = [\n      this.dictionary.encode(quad.subject),\n      this.dictionary.encode(quad.predicate),\n      this.dictionary.encode(quad.object),\n      this.dictionary.encode(quad.graph),\n    ];\n    let newQuad = false;\n    for (const indexWrapped of this.indexesWrapped) {\n      // Before sending the quad to the index, make sure its components are ordered corresponding to the index's order.\n      newQuad = indexWrapped.index\n        .set(<EncodedQuadTerms<E>>orderQuadComponents(indexWrapped.componentOrder, quadEncoded), true);\n    }\n    if (newQuad) {\n      this._size++;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Remove a quad from the store.\n   * @param quad An RDF quad.\n   * @return boolean If the quad was present in the index.\n   */\n  public removeQuad(quad: Q): boolean {\n    const quadEncoded = [\n      this.dictionary.encodeOptional(quad.subject),\n      this.dictionary.encodeOptional(quad.predicate),\n      this.dictionary.encodeOptional(quad.object),\n      this.dictionary.encodeOptional(quad.graph),\n    ];\n\n    // We can quickly return false if the quad is not present in the dictionary\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    if (quadEncoded.includes(undefined)) {\n      return false;\n    }\n\n    let wasPresent = false;\n    for (const indexWrapped of this.indexesWrapped) {\n      // Before sending the quad to the index, make sure its components are ordered corresponding to the index's order.\n      wasPresent = indexWrapped.index\n        .remove(<EncodedQuadTerms<E>>orderQuadComponents(indexWrapped.componentOrder, quadEncoded));\n      if (!wasPresent) {\n        break;\n      }\n    }\n    if (wasPresent) {\n      this._size--;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Removes all streamed quads.\n   * @param stream A stream of quads\n   */\n  public remove(stream: RDF.Stream<Q>): EventEmitter {\n    stream.on('data', quad => this.removeQuad(quad));\n    return stream;\n  }\n\n  /**\n   * All quads matching the pattern will be removed.\n   * @param subject The optional subject.\n   * @param predicate The optional predicate.\n   * @param object The optional object.\n   * @param graph The optional graph.\n   */\n  public removeMatches(\n    subject?: RDF.Term | null | undefined,\n    predicate?: RDF.Term | null | undefined,\n    object?: RDF.Term | null | undefined,\n    graph?: RDF.Term | null | undefined,\n  ): EventEmitter {\n    return this.remove(this.match(subject, predicate, object, graph));\n  }\n\n  /**\n   * Deletes the given named graph.\n   * @param graph The graph term or string to match.\n   */\n  public deleteGraph(graph: string | Q['graph']): EventEmitter {\n    if (typeof graph === 'string') {\n      graph = this.dataFactory.namedNode(graph);\n    }\n    return this.removeMatches(undefined, undefined, undefined, graph);\n  }\n\n  /**\n   * Import the given stream of quads into the store.\n   * @param stream A stream of RDF quads.\n   */\n  public import(stream: RDF.Stream<Q>): EventEmitter {\n    stream.on('data', (quad: Q) => this.addQuad(quad));\n    return stream;\n  }\n\n  /**\n   * Returns a generator producing all quads matching the pattern.\n   * @param subject The optional subject.\n   * @param predicate The optional predicate.\n   * @param object The optional object.\n   * @param graph The optional graph.\n   */\n  public * readQuads(\n    subject?: RDF.Term | null,\n    predicate?: RDF.Term | null,\n    object?: RDF.Term | null,\n    graph?: RDF.Term | null,\n  ): IterableIterator<Q> {\n    // Check if our dictionary and our indexes have quoted pattern support\n    const indexesSupportQuotedPatterns = Boolean(this.dictionary.features.quotedTriples) &&\n      Object.values(this.indexesWrapped).every(wrapped => wrapped.index.features.quotedTripleFiltering);\n\n    // Construct a quad pattern array\n    const [ quadComponents, requireQuotedTripleFiltering ] =\n      quadToPattern(subject, predicate, object, graph, indexesSupportQuotedPatterns);\n\n    // Determine the best index for this pattern\n    const indexWrapped = this.indexesWrapped[getBestIndex(this.indexesWrappedComponentOrders, quadComponents)];\n\n    // Re-order the quad pattern based on this best index's component order\n    const quadComponentsOrdered = <QuadPatternTerms> orderQuadComponents(indexWrapped.componentOrder, quadComponents);\n\n    // Call the best index's find method.\n    // eslint-disable-next-line unicorn/no-array-callback-reference\n    for (const decomposedQuad of indexWrapped.index.find(quadComponentsOrdered)) {\n      // De-order the resulting quad components into the normal SPOG order for quad creation.\n      const quad = this.dataFactory.quad(\n        decomposedQuad[indexWrapped.componentOrderInverse.subject],\n        decomposedQuad[indexWrapped.componentOrderInverse.predicate],\n        decomposedQuad[indexWrapped.componentOrderInverse.object],\n        decomposedQuad[indexWrapped.componentOrderInverse.graph],\n      );\n      if (requireQuotedTripleFiltering) {\n        if (matchPattern(quad, subject!, predicate!, object!, graph!)) {\n          yield quad;\n        }\n      } else {\n        yield quad;\n      }\n    }\n  }\n\n  /**\n   * Returns an array containing all quads matching the pattern.\n   * @param subject The optional subject.\n   * @param predicate The optional predicate.\n   * @param object The optional object.\n   * @param graph The optional graph.\n   */\n  public getQuads(\n    subject?: RDF.Term | null,\n    predicate?: RDF.Term | null,\n    object?: RDF.Term | null,\n    graph?: RDF.Term | null,\n  ): Q[] {\n    return [ ...this.readQuads(subject, predicate, object, graph) ];\n  }\n\n  /**\n   * Returns a stream that produces all quads matching the pattern.\n   * @param subject The optional subject.\n   * @param predicate The optional predicate.\n   * @param object The optional object.\n   * @param graph The optional graph.\n   */\n  public match(\n    subject?: RDF.Term | null,\n    predicate?: RDF.Term | null,\n    object?: RDF.Term | null,\n    graph?: RDF.Term | null,\n  ): RDF.Stream<Q> & AsyncIterator<Q> {\n    return wrap(this.readQuads(subject, predicate, object, graph));\n  }\n\n  /**\n   * Returns the exact cardinality of the quads matching the pattern.\n   * @param subject The optional subject.\n   * @param predicate The optional predicate.\n   * @param object The optional object.\n   * @param graph The optional graph.\n   */\n  public countQuads(\n    subject?: RDF.Term | null,\n    predicate?: RDF.Term | null,\n    object?: RDF.Term | null,\n    graph?: RDF.Term | null,\n  ): number {\n    // Check if our dictionary and our indexes have quoted pattern support\n    const indexesSupportQuotedPatterns = Boolean(this.dictionary.features.quotedTriples) &&\n      Object.values(this.indexesWrapped).every(wrapped => wrapped.index.features.quotedTripleFiltering);\n\n    // Construct a quad pattern array\n    const [ quadComponents ] =\n      quadToPattern(subject, predicate, object, graph, indexesSupportQuotedPatterns);\n\n    // Optimize all-variables pattern\n    if (quadComponents.every(quadComponent => quadComponent === undefined)) {\n      return this.size;\n    }\n\n    // Determine the best index for this pattern\n    const indexWrapped = this.indexesWrapped[getBestIndex(this.indexesWrappedComponentOrders, quadComponents)];\n\n    // Re-order the quad pattern based on this best index's component order\n    const quadComponentsOrdered = <QuadPatternTerms> orderQuadComponents(indexWrapped.componentOrder, quadComponents);\n\n    // Call the best index's count method.\n    return indexWrapped.index.count(quadComponentsOrdered);\n  }\n\n  /**\n   * Wrap this store inside a DatasetCore interface.\n   * Any mutations in either this store or the wrapper will propagate to each other.\n   */\n  public asDataset(): DatasetCoreWrapper<E, Q> {\n    return new DatasetCoreWrapper(this);\n  }\n}\n\nexport interface IRdfStoreIndexWrapped<E> {\n  componentOrder: QuadTermName[];\n  componentOrderInverse: Record<QuadTermName, number>;\n  index: IRdfStoreIndex<E, boolean>;\n}\n"]}