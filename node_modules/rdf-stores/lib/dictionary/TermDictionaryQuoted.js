"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TermDictionaryQuoted = void 0;
const rdf_data_factory_1 = require("rdf-data-factory");
const rdf_terms_1 = require("rdf-terms");
/**
 * A term dictionary for quoted triples.
 *
 * Plain terms and quoted triples are stored in separate dictionaries.
 *
 * Finding quoted triples is done by iterating over all quoted triples, and filtering by the matching ones.
 */
class TermDictionaryQuoted {
    constructor(plainTermDictionary, quotedTriplesDictionary, dataFactory = new rdf_data_factory_1.DataFactory()) {
        this.features = { quotedTriples: true };
        this.plainTermDictionary = plainTermDictionary;
        this.quotedTriplesDictionary = quotedTriplesDictionary;
        this.dataFactory = dataFactory;
    }
    encode(term) {
        if (term.termType === 'Quad') {
            // Mask MSB to indicate that the encoding should refer to the quoted triples dictionary.
            return TermDictionaryQuoted.BITMASK | (1 + this.quotedTriplesDictionary.encode(term));
        }
        return this.plainTermDictionary.encode(term);
    }
    encodeOptional(term) {
        if (term.termType === 'Quad') {
            const encoding = this.quotedTriplesDictionary.encodeOptional(term);
            if (encoding === undefined) {
                return encoding;
            }
            // Mask MSB to indicate that the encoding should refer to the quoted triples dictionary.
            return TermDictionaryQuoted.BITMASK | (1 + encoding);
        }
        return this.plainTermDictionary.encodeOptional(term);
    }
    decode(encoding) {
        if (TermDictionaryQuoted.BITMASK & encoding) {
            // Term comes from the quoted triples dictionary
            const encodingBase = (~TermDictionaryQuoted.BITMASK & encoding) - 1;
            return this.quotedTriplesDictionary.decode(encodingBase);
        }
        // Term comes from the plain terms dictionary
        return this.plainTermDictionary.decode(encoding);
    }
    *encodings() {
        for (const encoding of this.plainTermDictionary.encodings()) {
            yield encoding;
        }
        for (const encoding of this.quotedTriplesDictionary.encodings()) {
            yield TermDictionaryQuoted.BITMASK | (1 + encoding);
        }
    }
    *findQuotedTriples(quotedTriplePattern) {
        for (const termEncoded of this.findQuotedTriplesEncoded(quotedTriplePattern)) {
            yield this.decode(termEncoded);
        }
    }
    *findQuotedTriplesEncoded(quotedTriplePattern) {
        for (let encodedQuotedTriple of this.quotedTriplesDictionary.encodings()) {
            encodedQuotedTriple = TermDictionaryQuoted.BITMASK | (1 + encodedQuotedTriple);
            const quotedTriple = this.decode(encodedQuotedTriple);
            if ((0, rdf_terms_1.matchPattern)(quotedTriple, quotedTriplePattern.subject, quotedTriplePattern.predicate, quotedTriplePattern.object, quotedTriplePattern.graph)) {
                yield encodedQuotedTriple;
            }
        }
    }
}
TermDictionaryQuoted.BITMASK = 1 << 31;
exports.TermDictionaryQuoted = TermDictionaryQuoted;
//# sourceMappingURL=TermDictionaryQuoted.js.map