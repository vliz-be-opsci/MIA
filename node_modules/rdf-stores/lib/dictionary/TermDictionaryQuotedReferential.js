"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TermDictionaryQuotedReferential = void 0;
const rdf_data_factory_1 = require("rdf-data-factory");
const rdf_terms_1 = require("rdf-terms");
const OrderUtils_1 = require("../OrderUtils");
/**
 * A term dictionary for quoted triples.
 *
 * Plain terms and quoted triples are stored in separate dictionaries,
 * but quoted triples are encoded using encodings from the plain term dictionary.
 *
 * Finding quoted triples is done by iterating over all quoted triples, and filtering by the matching ones.
 */
class TermDictionaryQuotedReferential {
    constructor(plainTermDictionary, dataFactory = new rdf_data_factory_1.DataFactory()) {
        this.quotedTriplesDictionary = [];
        this.quotedTriplesReverseDictionary = {};
        this.features = { quotedTriples: true };
        this.plainTermDictionary = plainTermDictionary;
        this.dataFactory = dataFactory;
    }
    encode(term) {
        if (term.termType === 'Quad') {
            return this.encodeQuotedTriple(term, false);
        }
        return this.plainTermDictionary.encode(term);
    }
    encodeQuotedTriple(quad, optional) {
        var _a;
        // Only quoted triples are supported
        if (quad.graph.termType !== 'DefaultGraph') {
            throw new Error('Encoding of quoted quads outside of the default graph is not allowed');
        }
        // Check if the quad was already encoded
        const encodedTripleOptional = (_a = (0, OrderUtils_1.encodeOptionalTerms)([quad.subject, quad.predicate, quad.object, undefined], this)) === null || _a === void 0 ? void 0 : _a.slice(0, 3);
        const id = encodedTripleOptional && encodedTripleOptional.every(encoded => encoded !== undefined) ?
            this.quotedTriplesReverseDictionary[encodedTripleOptional.join(TermDictionaryQuotedReferential.SEPARATOR)] :
            undefined;
        // Return the encoding if we found one
        if (id !== undefined || optional) {
            // Mask MSB to indicate that the encoding should refer to the quoted triples dictionary.
            return (id === undefined ? undefined : TermDictionaryQuotedReferential.BITMASK | id);
        }
        // If the quad was not encoded yet, add a new entry for it in the dictionary.
        const encodedTriple = [
            this.encode(quad.subject),
            this.encode(quad.predicate),
            this.encode(quad.object),
        ];
        const encodingBase = this.quotedTriplesDictionary.length + 1;
        this.quotedTriplesDictionary.push(encodedTriple);
        this.quotedTriplesReverseDictionary[encodedTriple.join(TermDictionaryQuotedReferential.SEPARATOR)] = encodingBase;
        // Mask MSB to indicate that the encoding should refer to the quoted triples dictionary.
        return TermDictionaryQuotedReferential.BITMASK | encodingBase;
    }
    encodeOptional(term) {
        if (term.termType === 'Quad') {
            return this.encodeQuotedTriple(term, true);
        }
        return this.plainTermDictionary.encodeOptional(term);
    }
    decode(encoding) {
        if (TermDictionaryQuotedReferential.BITMASK & encoding) {
            // Term comes from the quoted triples dictionary
            const encodingBase = (~TermDictionaryQuotedReferential.BITMASK & encoding) - 1;
            if (encodingBase >= this.quotedTriplesDictionary.length) {
                throw new Error(`The value ${encoding} is not present in the quoted triples range of the dictionary`);
            }
            const encodedTerms = this.quotedTriplesDictionary[encodingBase];
            return this.dataFactory.quad(this.decode(encodedTerms[0]), this.decode(encodedTerms[1]), this.decode(encodedTerms[2]));
        }
        // Term comes from the plain terms dictionary
        return this.plainTermDictionary.decode(encoding);
    }
    *encodings() {
        for (const encoding of this.plainTermDictionary.encodings()) {
            yield encoding;
        }
        for (const encoding of this.quotedTriplesDictionary.keys()) {
            yield TermDictionaryQuotedReferential.BITMASK | (1 + encoding);
        }
    }
    *findQuotedTriples(quotedTriplePattern) {
        for (const termEncoded of this.findQuotedTriplesEncoded(quotedTriplePattern)) {
            yield this.decode(termEncoded);
        }
    }
    *findQuotedTriplesEncoded(quotedTriplePattern) {
        for (let encodedQuotedTriple of this.quotedTriplesDictionary.keys()) {
            encodedQuotedTriple = TermDictionaryQuotedReferential.BITMASK | (1 + encodedQuotedTriple);
            const quotedTriple = this.decode(encodedQuotedTriple);
            if ((0, rdf_terms_1.matchPattern)(quotedTriple, quotedTriplePattern.subject, quotedTriplePattern.predicate, quotedTriplePattern.object, quotedTriplePattern.graph)) {
                yield encodedQuotedTriple;
            }
        }
    }
}
TermDictionaryQuotedReferential.BITMASK = 1 << 31;
TermDictionaryQuotedReferential.SEPARATOR = '_';
exports.TermDictionaryQuotedReferential = TermDictionaryQuotedReferential;
//# sourceMappingURL=TermDictionaryQuotedReferential.js.map