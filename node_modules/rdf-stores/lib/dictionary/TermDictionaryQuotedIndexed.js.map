{"version":3,"file":"TermDictionaryQuotedIndexed.js","sourceRoot":"","sources":["TermDictionaryQuotedIndexed.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport { DataFactory } from 'rdf-data-factory';\nimport { RdfStoreIndexNestedMap } from '../index/RdfStoreIndexNestedMap';\nimport type { IRdfStoreOptions } from '../IRdfStoreOptions';\nimport { encodeOptionalTerms, quadToPattern } from '../OrderUtils';\nimport type { EncodedQuadTerms, QuadPatternTerms, PatternTerm } from '../PatternTerm';\nimport type { ITermDictionary } from './ITermDictionary';\n\n/**\n * A term dictionary for quoted triples.\n *\n * Plain terms are stored in a regular dictionary.\n * Quoted triples are stored separately using an index, which is backed the same dictionary.\n *\n * Finding quoted triples is done through indexed lookups.\n */\nexport class TermDictionaryQuotedIndexed implements ITermDictionary<number> {\n  public static readonly BITMASK = 1 << 31;\n\n  private readonly plainTermDictionary: ITermDictionary<number>;\n  private readonly quotedTriplesDictionary: number[][] = [];\n  // The indexes below are sorted in SPO, POS, and OSP order\n  private readonly quotedTriplesReverseDictionaries: RdfStoreIndexNestedMap<number, number>[];\n  private readonly dataFactory: RDF.DataFactory;\n  public readonly features = { quotedTriples: true };\n\n  public constructor(\n    rawTermDictionary: ITermDictionary<number>,\n    dataFactory: RDF.DataFactory = new DataFactory(),\n  ) {\n    this.plainTermDictionary = rawTermDictionary;\n    const subIndexOpts: IRdfStoreOptions<number> = {\n      // Not required\n      indexCombinations: [],\n      // Not required\n      indexConstructor: <any> undefined,\n      dictionary: this,\n      dataFactory,\n    };\n    this.quotedTriplesReverseDictionaries = [\n      new RdfStoreIndexNestedMap(subIndexOpts),\n      new RdfStoreIndexNestedMap(subIndexOpts),\n      new RdfStoreIndexNestedMap(subIndexOpts),\n    ];\n    this.dataFactory = dataFactory;\n  }\n\n  public encode(term: RDF.Term): number {\n    if (term.termType === 'Quad') {\n      return this.encodeQuotedTriple(term, false);\n    }\n    return this.plainTermDictionary.encode(term);\n  }\n\n  private encodeQuotedTriple<O extends boolean>(\n    quad: RDF.BaseQuad,\n    optional: O,\n  ): O extends true ? number | undefined : number {\n    // Only quoted triples are supported\n    if (quad.graph.termType !== 'DefaultGraph') {\n      throw new Error('Encoding of quoted quads outside of the default graph is not allowed');\n    }\n\n    // Check if the quad was already encoded\n    const encodedTripleOptional = encodeOptionalTerms(\n      <QuadPatternTerms> [ quad.subject, quad.predicate, quad.object, quad.graph ],\n      this,\n    );\n    const id = encodedTripleOptional && encodedTripleOptional.every(encoded => encoded !== undefined) ?\n      this.quotedTriplesReverseDictionaries[0].getEncoded(<EncodedQuadTerms<number>> encodedTripleOptional) :\n      undefined;\n\n    // Return the encoding if we found one\n    if (id !== undefined || optional) {\n      // Mask MSB to indicate that the encoding should refer to the quoted triples dictionary.\n      return <O extends true ? number | undefined : number>\n        (id === undefined ? undefined : TermDictionaryQuotedIndexed.BITMASK | id);\n    }\n\n    // If the quad was not encoded yet, add a new entry for it in the dictionary.\n    const encodedTriple = [\n      this.encode(quad.subject),\n      this.encode(quad.predicate),\n      this.encode(quad.object),\n    ];\n    const encodingBase = this.quotedTriplesDictionary.length + 1;\n    this.quotedTriplesDictionary.push(encodedTriple);\n    const encodedGraph = this.encode(this.dataFactory.defaultGraph());\n    this.quotedTriplesReverseDictionaries[0].set(<EncodedQuadTerms<number>> [\n      encodedTriple[0],\n      encodedTriple[1],\n      encodedTriple[2],\n      encodedGraph,\n    ], encodingBase);\n    this.quotedTriplesReverseDictionaries[1].set(<EncodedQuadTerms<number>> [\n      encodedTriple[1],\n      encodedTriple[2],\n      encodedTriple[0],\n      encodedGraph,\n    ], encodingBase);\n    this.quotedTriplesReverseDictionaries[2].set(<EncodedQuadTerms<number>> [\n      encodedTriple[2],\n      encodedTriple[0],\n      encodedTriple[1],\n      encodedGraph,\n    ], encodingBase);\n\n    // Mask MSB to indicate that the encoding should refer to the quoted triples dictionary.\n    return TermDictionaryQuotedIndexed.BITMASK | encodingBase;\n  }\n\n  public encodeOptional(term: RDF.Term): number | undefined {\n    if (term.termType === 'Quad') {\n      return this.encodeQuotedTriple(term, true);\n    }\n    return this.plainTermDictionary.encodeOptional(term);\n  }\n\n  public decode(encoding: number): RDF.Term {\n    if (TermDictionaryQuotedIndexed.BITMASK & encoding) {\n      // Term comes from the quoted triples dictionary\n      const encodingBase = (~TermDictionaryQuotedIndexed.BITMASK & encoding) - 1;\n      if (encodingBase >= this.quotedTriplesDictionary.length) {\n        throw new Error(`The value ${encoding} is not present in the quoted triples range of the dictionary`);\n      }\n      const encodedTerms = this.quotedTriplesDictionary[encodingBase];\n      return this.dataFactory.quad(\n        <RDF.Quad['subject']> this.decode(encodedTerms[0]),\n        <RDF.Quad['predicate']> this.decode(encodedTerms[1]),\n        <RDF.Quad['object']> this.decode(encodedTerms[2]),\n      );\n    }\n\n    // Term comes from the plain terms dictionary\n    return this.plainTermDictionary.decode(encoding);\n  }\n\n  public * encodings(): IterableIterator<number> {\n    for (const encoding of this.plainTermDictionary.encodings()) {\n      yield encoding;\n    }\n    for (const encoding of this.quotedTriplesDictionary.keys()) {\n      yield TermDictionaryQuotedIndexed.BITMASK | (1 + encoding);\n    }\n  }\n\n  public * findQuotedTriples(quotedTriplePattern: RDF.Quad): IterableIterator<RDF.Term> {\n    for (const termEncoded of this.findQuotedTriplesEncoded(quotedTriplePattern)) {\n      yield this.decode(termEncoded);\n    }\n  }\n\n  public * findQuotedTriplesEncoded(quotedTriplePattern: RDF.Quad): IterableIterator<number> {\n    const [ patternIn, requireQuotedTripleFiltering ] = quadToPattern(\n      quotedTriplePattern.subject,\n      quotedTriplePattern.predicate,\n      quotedTriplePattern.object,\n      quotedTriplePattern.graph,\n      true,\n    );\n\n    // Find all matching terms iteratively\n    for (const termS of this.patternToIterable(patternIn[0])) {\n      for (const termP of this.patternToIterable(patternIn[1])) {\n        for (const termO of this.patternToIterable(patternIn[2])) {\n          for (const termG of this.patternToIterable(patternIn[3])) {\n            // Find all terms matching the pattern from the reverse indexes\n            // We select the reverse index according to the current triple pattern\n            if ((termS && termP) || (!termP && !termO)) {\n              // SPO\n              const pattern: EncodedQuadTerms<number | undefined> = [ termS, termP, termO, termG ];\n              for (const termEncoded of this.quotedTriplesReverseDictionaries[0].findEncoded(pattern, patternIn)) {\n                yield TermDictionaryQuotedIndexed.BITMASK |\n                this.quotedTriplesReverseDictionaries[0].getEncoded(termEncoded)!;\n              }\n            } else if (!termS && termP) {\n              // POS\n              const pattern: EncodedQuadTerms<number | undefined> = [ termP, termO, termS, termG ];\n              for (const termEncoded of this.quotedTriplesReverseDictionaries[1].findEncoded(pattern, patternIn)) {\n                yield TermDictionaryQuotedIndexed.BITMASK |\n                this.quotedTriplesReverseDictionaries[1].getEncoded(termEncoded)!;\n              }\n            } else {\n              // OSP\n              const pattern: EncodedQuadTerms<number | undefined> = [ termO, termS, termP, termG ];\n              for (const termEncoded of this.quotedTriplesReverseDictionaries[2].findEncoded(pattern, patternIn)) {\n                yield TermDictionaryQuotedIndexed.BITMASK |\n                this.quotedTriplesReverseDictionaries[2].getEncoded(termEncoded)!;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Helper function to convert a term to an iterator over encoded terms.\n   * @param patternTerm A term.\n   * @protected\n   */\n  protected * patternToIterable(patternTerm: PatternTerm): IterableIterator<number | undefined> {\n    // If the term is another quoted quad, recursively find other quoted triples\n    if (patternTerm?.termType === 'Quad') {\n      yield * this.findQuotedTriplesEncoded(patternTerm);\n      return;\n    }\n\n    // Undefined terms indicate a variable\n    if (patternTerm === undefined) {\n      // eslint-disable-next-line unicorn/no-useless-undefined\n      yield undefined;\n      return;\n    }\n\n    // Defined terms indicate a precise match\n    const enc = this.encodeOptional(patternTerm);\n    if (enc === undefined) {\n      return;\n    }\n    yield enc;\n  }\n}\n"]}