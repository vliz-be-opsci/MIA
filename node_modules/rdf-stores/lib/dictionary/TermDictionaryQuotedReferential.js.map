{"version":3,"file":"TermDictionaryQuotedReferential.js","sourceRoot":"","sources":["TermDictionaryQuotedReferential.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport { DataFactory } from 'rdf-data-factory';\nimport { matchPattern } from 'rdf-terms';\nimport { encodeOptionalTerms } from '../OrderUtils';\nimport type { QuadPatternTerms } from '../PatternTerm';\nimport type { ITermDictionary } from './ITermDictionary';\n\n/**\n * A term dictionary for quoted triples.\n *\n * Plain terms and quoted triples are stored in separate dictionaries,\n * but quoted triples are encoded using encodings from the plain term dictionary.\n *\n * Finding quoted triples is done by iterating over all quoted triples, and filtering by the matching ones.\n */\nexport class TermDictionaryQuotedReferential implements ITermDictionary<number> {\n  public static readonly BITMASK = 1 << 31;\n  public static readonly SEPARATOR = '_';\n\n  private readonly plainTermDictionary: ITermDictionary<number>;\n  private readonly quotedTriplesDictionary: number[][] = [];\n  private readonly quotedTriplesReverseDictionary: Record<string, number> = {};\n  private readonly dataFactory: RDF.DataFactory;\n  public readonly features = { quotedTriples: true };\n\n  public constructor(\n    plainTermDictionary: ITermDictionary<number>,\n    dataFactory: RDF.DataFactory = new DataFactory(),\n  ) {\n    this.plainTermDictionary = plainTermDictionary;\n    this.dataFactory = dataFactory;\n  }\n\n  public encode(term: RDF.Term): number {\n    if (term.termType === 'Quad') {\n      return this.encodeQuotedTriple(term, false);\n    }\n    return this.plainTermDictionary.encode(term);\n  }\n\n  private encodeQuotedTriple<O extends boolean>(\n    quad: RDF.BaseQuad,\n    optional: O,\n  ): O extends true ? number | undefined : number {\n    // Only quoted triples are supported\n    if (quad.graph.termType !== 'DefaultGraph') {\n      throw new Error('Encoding of quoted quads outside of the default graph is not allowed');\n    }\n\n    // Check if the quad was already encoded\n    const encodedTripleOptional = encodeOptionalTerms(\n      <QuadPatternTerms> [ quad.subject, quad.predicate, quad.object, undefined ],\n      this,\n    )?.slice(0, 3);\n    const id = encodedTripleOptional && encodedTripleOptional.every(encoded => encoded !== undefined) ?\n      this.quotedTriplesReverseDictionary[encodedTripleOptional.join(TermDictionaryQuotedReferential.SEPARATOR)] :\n      undefined;\n\n    // Return the encoding if we found one\n    if (id !== undefined || optional) {\n      // Mask MSB to indicate that the encoding should refer to the quoted triples dictionary.\n      return <O extends true ? number | undefined : number>\n        (id === undefined ? undefined : TermDictionaryQuotedReferential.BITMASK | id);\n    }\n\n    // If the quad was not encoded yet, add a new entry for it in the dictionary.\n    const encodedTriple = [\n      this.encode(quad.subject),\n      this.encode(quad.predicate),\n      this.encode(quad.object),\n    ];\n    const encodingBase = this.quotedTriplesDictionary.length + 1;\n    this.quotedTriplesDictionary.push(encodedTriple);\n    this.quotedTriplesReverseDictionary[encodedTriple.join(TermDictionaryQuotedReferential.SEPARATOR)] = encodingBase;\n\n    // Mask MSB to indicate that the encoding should refer to the quoted triples dictionary.\n    return TermDictionaryQuotedReferential.BITMASK | encodingBase;\n  }\n\n  public encodeOptional(term: RDF.Term): number | undefined {\n    if (term.termType === 'Quad') {\n      return this.encodeQuotedTriple(term, true);\n    }\n    return this.plainTermDictionary.encodeOptional(term);\n  }\n\n  public decode(encoding: number): RDF.Term {\n    if (TermDictionaryQuotedReferential.BITMASK & encoding) {\n      // Term comes from the quoted triples dictionary\n      const encodingBase = (~TermDictionaryQuotedReferential.BITMASK & encoding) - 1;\n      if (encodingBase >= this.quotedTriplesDictionary.length) {\n        throw new Error(`The value ${encoding} is not present in the quoted triples range of the dictionary`);\n      }\n      const encodedTerms = this.quotedTriplesDictionary[encodingBase];\n      return this.dataFactory.quad(\n        <RDF.Quad['subject']> this.decode(encodedTerms[0]),\n        <RDF.Quad['predicate']> this.decode(encodedTerms[1]),\n        <RDF.Quad['object']> this.decode(encodedTerms[2]),\n      );\n    }\n\n    // Term comes from the plain terms dictionary\n    return this.plainTermDictionary.decode(encoding);\n  }\n\n  public * encodings(): IterableIterator<number> {\n    for (const encoding of this.plainTermDictionary.encodings()) {\n      yield encoding;\n    }\n    for (const encoding of this.quotedTriplesDictionary.keys()) {\n      yield TermDictionaryQuotedReferential.BITMASK | (1 + encoding);\n    }\n  }\n\n  public * findQuotedTriples(quotedTriplePattern: RDF.Quad): IterableIterator<RDF.Term> {\n    for (const termEncoded of this.findQuotedTriplesEncoded(quotedTriplePattern)) {\n      yield this.decode(termEncoded);\n    }\n  }\n\n  public * findQuotedTriplesEncoded(quotedTriplePattern: RDF.Quad): IterableIterator<number> {\n    for (let encodedQuotedTriple of this.quotedTriplesDictionary.keys()) {\n      encodedQuotedTriple = TermDictionaryQuotedReferential.BITMASK | (1 + encodedQuotedTriple);\n      const quotedTriple = this.decode(encodedQuotedTriple);\n      if (matchPattern(\n        <RDF.BaseQuad> quotedTriple,\n        quotedTriplePattern.subject,\n        quotedTriplePattern.predicate,\n        quotedTriplePattern.object,\n        quotedTriplePattern.graph,\n      )) {\n        yield encodedQuotedTriple;\n      }\n    }\n  }\n}\n"]}