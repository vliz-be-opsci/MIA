{"version":3,"file":"TermDictionaryQuoted.js","sourceRoot":"","sources":["TermDictionaryQuoted.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport { DataFactory } from 'rdf-data-factory';\nimport { matchPattern } from 'rdf-terms';\nimport type { ITermDictionary } from './ITermDictionary';\n\n/**\n * A term dictionary for quoted triples.\n *\n * Plain terms and quoted triples are stored in separate dictionaries.\n *\n * Finding quoted triples is done by iterating over all quoted triples, and filtering by the matching ones.\n */\nexport class TermDictionaryQuoted implements ITermDictionary<number> {\n  public static readonly BITMASK = 1 << 31;\n\n  private readonly plainTermDictionary: ITermDictionary<number>;\n  private readonly quotedTriplesDictionary: ITermDictionary<number>;\n  private readonly dataFactory: RDF.DataFactory;\n  public readonly features = { quotedTriples: true };\n\n  public constructor(\n    plainTermDictionary: ITermDictionary<number>,\n    quotedTriplesDictionary: ITermDictionary<number>,\n    dataFactory: RDF.DataFactory = new DataFactory(),\n  ) {\n    this.plainTermDictionary = plainTermDictionary;\n    this.quotedTriplesDictionary = quotedTriplesDictionary;\n    this.dataFactory = dataFactory;\n  }\n\n  public encode(term: RDF.Term): number {\n    if (term.termType === 'Quad') {\n      // Mask MSB to indicate that the encoding should refer to the quoted triples dictionary.\n      return TermDictionaryQuoted.BITMASK | (1 + this.quotedTriplesDictionary.encode(term));\n    }\n    return this.plainTermDictionary.encode(term);\n  }\n\n  public encodeOptional(term: RDF.Term): number | undefined {\n    if (term.termType === 'Quad') {\n      const encoding = this.quotedTriplesDictionary.encodeOptional(term);\n      if (encoding === undefined) {\n        return encoding;\n      }\n      // Mask MSB to indicate that the encoding should refer to the quoted triples dictionary.\n      return TermDictionaryQuoted.BITMASK | (1 + encoding);\n    }\n    return this.plainTermDictionary.encodeOptional(term);\n  }\n\n  public decode(encoding: number): RDF.Term {\n    if (TermDictionaryQuoted.BITMASK & encoding) {\n      // Term comes from the quoted triples dictionary\n      const encodingBase = (~TermDictionaryQuoted.BITMASK & encoding) - 1;\n      return this.quotedTriplesDictionary.decode(encodingBase);\n    }\n\n    // Term comes from the plain terms dictionary\n    return this.plainTermDictionary.decode(encoding);\n  }\n\n  public * encodings(): IterableIterator<number> {\n    for (const encoding of this.plainTermDictionary.encodings()) {\n      yield encoding;\n    }\n    for (const encoding of this.quotedTriplesDictionary.encodings()) {\n      yield TermDictionaryQuoted.BITMASK | (1 + encoding);\n    }\n  }\n\n  public * findQuotedTriples(quotedTriplePattern: RDF.Quad): IterableIterator<RDF.Term> {\n    for (const termEncoded of this.findQuotedTriplesEncoded(quotedTriplePattern)) {\n      yield this.decode(termEncoded);\n    }\n  }\n\n  public * findQuotedTriplesEncoded(quotedTriplePattern: RDF.Quad): IterableIterator<number> {\n    for (let encodedQuotedTriple of this.quotedTriplesDictionary.encodings()) {\n      encodedQuotedTriple = TermDictionaryQuoted.BITMASK | (1 + encodedQuotedTriple);\n      const quotedTriple = this.decode(encodedQuotedTriple);\n      if (matchPattern(\n        <RDF.BaseQuad> quotedTriple,\n        quotedTriplePattern.subject,\n        quotedTriplePattern.predicate,\n        quotedTriplePattern.object,\n        quotedTriplePattern.graph,\n      )) {\n        yield encodedQuotedTriple;\n      }\n    }\n  }\n}\n"]}