"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TermDictionarySymbol = void 0;
const rdf_data_factory_1 = require("rdf-data-factory");
const rdf_string_1 = require("rdf-string");
/**
 * A term dictionary that encodes and decodes using symbols.
 */
class TermDictionarySymbol {
    constructor(dataFactory = new rdf_data_factory_1.DataFactory()) {
        this.features = { quotedTriples: false };
        this.dataFactory = dataFactory;
    }
    encode(term) {
        return Symbol.for(`rdf::${(0, rdf_string_1.termToString)(term)}`);
    }
    encodeOptional(term) {
        return this.encode(term);
    }
    decode(encoding) {
        const string = Symbol.keyFor(encoding);
        if (string === undefined) {
            throw new Error(`The value ${String(encoding)} is not present in this dictionary`);
        }
        return (0, rdf_string_1.stringToTerm)(string.slice(5), this.dataFactory);
    }
    encodings() {
        throw new Error('encodings is not supported');
    }
    findQuotedTriples(quotedTriplePattern) {
        throw new Error('findQuotedTriples is not supported');
    }
    findQuotedTriplesEncoded(quotedTriplePattern) {
        throw new Error('findQuotedTriplesEncoded is not supported');
    }
}
exports.TermDictionarySymbol = TermDictionarySymbol;
//# sourceMappingURL=TermDictionarySymbol.js.map