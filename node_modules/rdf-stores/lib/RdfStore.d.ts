/// <reference types="node" />
import type { EventEmitter } from 'events';
import type * as RDF from '@rdfjs/types';
import type { AsyncIterator } from 'asynciterator';
import type { QuadTermName } from 'rdf-terms';
import { DatasetCoreWrapper } from './dataset/DatasetCoreWrapper';
import type { ITermDictionary } from './dictionary/ITermDictionary';
import type { IRdfStoreIndex } from './index/IRdfStoreIndex';
import type { IRdfStoreOptions } from './IRdfStoreOptions';
/**
 * An RDF store allows quads to be stored and fetched, based on one or more customizable indexes.
 */
export declare class RdfStore<E = any, Q extends RDF.BaseQuad = RDF.Quad> implements RDF.Store<Q> {
    static readonly DEFAULT_INDEX_COMBINATIONS: QuadTermName[][];
    readonly options: IRdfStoreOptions<E, Q>;
    readonly dataFactory: RDF.DataFactory<Q>;
    readonly dictionary: ITermDictionary<E>;
    readonly indexesWrapped: IRdfStoreIndexWrapped<E>[];
    private readonly indexesWrappedComponentOrders;
    readonly features: {
        quotedTripleFiltering: boolean;
    };
    private _size;
    constructor(options: IRdfStoreOptions<E, Q>);
    /**
     * Create an RDF store with default settings.
     * Concretely, this store stores triples in GSPO, GPOS, and GOSP order,
     * and makes use of in-memory number dictionary encoding.
     */
    static createDefault(): RdfStore<number>;
    /**
     * Internal helper to create index objects.
     * @param options The RDF store options object.
     */
    static constructIndexesWrapped<E, Q extends RDF.BaseQuad = RDF.Quad>(options: IRdfStoreOptions<E, Q>): IRdfStoreIndexWrapped<E>[];
    /**
     * Check if a given quad term order is valid.
     * @param combination A quad term order.
     */
    static isCombinationValid(combination: QuadTermName[]): boolean;
    /**
     * The number of quads in this store.
     */
    get size(): number;
    /**
     * Add a quad to the store.
     * @param quad An RDF quad.
     * @return boolean If the quad was not yet present in the index.
     */
    addQuad(quad: Q): boolean;
    /**
     * Remove a quad from the store.
     * @param quad An RDF quad.
     * @return boolean If the quad was present in the index.
     */
    removeQuad(quad: Q): boolean;
    /**
     * Removes all streamed quads.
     * @param stream A stream of quads
     */
    remove(stream: RDF.Stream<Q>): EventEmitter;
    /**
     * All quads matching the pattern will be removed.
     * @param subject The optional subject.
     * @param predicate The optional predicate.
     * @param object The optional object.
     * @param graph The optional graph.
     */
    removeMatches(subject?: RDF.Term | null | undefined, predicate?: RDF.Term | null | undefined, object?: RDF.Term | null | undefined, graph?: RDF.Term | null | undefined): EventEmitter;
    /**
     * Deletes the given named graph.
     * @param graph The graph term or string to match.
     */
    deleteGraph(graph: string | Q['graph']): EventEmitter;
    /**
     * Import the given stream of quads into the store.
     * @param stream A stream of RDF quads.
     */
    import(stream: RDF.Stream<Q>): EventEmitter;
    /**
     * Returns a generator producing all quads matching the pattern.
     * @param subject The optional subject.
     * @param predicate The optional predicate.
     * @param object The optional object.
     * @param graph The optional graph.
     */
    readQuads(subject?: RDF.Term | null, predicate?: RDF.Term | null, object?: RDF.Term | null, graph?: RDF.Term | null): IterableIterator<Q>;
    /**
     * Returns an array containing all quads matching the pattern.
     * @param subject The optional subject.
     * @param predicate The optional predicate.
     * @param object The optional object.
     * @param graph The optional graph.
     */
    getQuads(subject?: RDF.Term | null, predicate?: RDF.Term | null, object?: RDF.Term | null, graph?: RDF.Term | null): Q[];
    /**
     * Returns a stream that produces all quads matching the pattern.
     * @param subject The optional subject.
     * @param predicate The optional predicate.
     * @param object The optional object.
     * @param graph The optional graph.
     */
    match(subject?: RDF.Term | null, predicate?: RDF.Term | null, object?: RDF.Term | null, graph?: RDF.Term | null): RDF.Stream<Q> & AsyncIterator<Q>;
    /**
     * Returns the exact cardinality of the quads matching the pattern.
     * @param subject The optional subject.
     * @param predicate The optional predicate.
     * @param object The optional object.
     * @param graph The optional graph.
     */
    countQuads(subject?: RDF.Term | null, predicate?: RDF.Term | null, object?: RDF.Term | null, graph?: RDF.Term | null): number;
    /**
     * Wrap this store inside a DatasetCore interface.
     * Any mutations in either this store or the wrapper will propagate to each other.
     */
    asDataset(): DatasetCoreWrapper<E, Q>;
}
export interface IRdfStoreIndexWrapped<E> {
    componentOrder: QuadTermName[];
    componentOrderInverse: Record<QuadTermName, number>;
    index: IRdfStoreIndex<E, boolean>;
}
