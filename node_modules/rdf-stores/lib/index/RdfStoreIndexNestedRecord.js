"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RdfStoreIndexNestedRecord = void 0;
const OrderUtils_1 = require("../OrderUtils");
/**
 * An RDF store index that is implemented using nested records.
 */
class RdfStoreIndexNestedRecord {
    constructor(options) {
        this.features = {
            quotedTripleFiltering: false,
        };
        this.dictionary = options.dictionary;
        this.nestedRecords = {};
    }
    set(terms, value) {
        const map0 = this.nestedRecords;
        const map1 = map0[terms[0]] || (map0[terms[0]] = {});
        const map2 = map1[terms[1]] || (map1[terms[1]] = {});
        const map3 = map2[terms[2]] || (map2[terms[2]] = {});
        if (map3[terms[3]]) {
            return false;
        }
        map3[terms[3]] = value;
        return true;
    }
    remove(terms) {
        const map0 = this.nestedRecords;
        const map1 = map0[terms[0]];
        if (!map1) {
            return false;
        }
        const map2 = map1[terms[1]];
        if (!map2) {
            return false;
        }
        const map3 = map2[terms[2]];
        if (!map3) {
            return false;
        }
        if (!map3[terms[3]]) {
            return false;
        }
        delete map3[terms[3]];
        // Clean up intermediate maps
        if (Object.keys(map3).length === 0) {
            delete map2[terms[2]];
            if (Object.keys(map2).length === 0) {
                delete map1[terms[1]];
                if (Object.keys(map1).length === 0) {
                    delete map0[terms[0]];
                }
            }
        }
        return true;
    }
    get(key) {
        const encoded = (0, OrderUtils_1.encodeOptionalTerms)(key, this.dictionary);
        // eslint-disable-next-line unicorn/no-useless-undefined
        if (!encoded || encoded.includes(undefined)) {
            return undefined;
        }
        return this.getEncoded(encoded);
    }
    getEncoded(ids) {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.nestedRecords[ids[0]]) === null || _a === void 0 ? void 0 : _a[ids[1]]) === null || _b === void 0 ? void 0 : _b[ids[2]]) === null || _c === void 0 ? void 0 : _c[ids[3]];
    }
    *find(terms) {
        const ids = (0, OrderUtils_1.encodeOptionalTerms)(terms, this.dictionary);
        if (!ids) {
            return;
        }
        const [id0, id1, id2, id3] = ids;
        const [term0, term1, term2, term3] = terms;
        let partialQuad0;
        let partialQuad1;
        let partialQuad2;
        let partialQuad3;
        let map1;
        let map2;
        let map3;
        const map0 = this.nestedRecords;
        const map0Keys = id0 !== undefined ? (id0 in map0 ? [id0] : []) : Object.keys(map0);
        for (const key1 of map0Keys) {
            map1 = map0[key1];
            partialQuad0 = term0 || this.dictionary.decode(Number.parseInt(key1, 10));
            const map1Keys = id1 !== undefined ? (id1 in map1 ? [id1] : []) : Object.keys(map1);
            for (const key2 of map1Keys) {
                map2 = map1[key2];
                partialQuad1 = term1 || this.dictionary.decode(Number.parseInt(key2, 10));
                const map2Keys = id2 !== undefined ? (id2 in map2 ? [id2] : []) : Object.keys(map2);
                for (const key3 of map2Keys) {
                    map3 = map2[key3];
                    partialQuad2 = term2 || this.dictionary.decode(Number.parseInt(key3, 10));
                    const map3Keys = id3 !== undefined ? (id3 in map3 ? [id3] : []) : Object.keys(map3);
                    for (const key4 of map3Keys) {
                        partialQuad3 = term3 || this.dictionary.decode(Number.parseInt(key4, 10));
                        yield [partialQuad0, partialQuad1, partialQuad2, partialQuad3];
                    }
                }
            }
        }
    }
    // The code below is nearly identical. We duplicate because abstraction would result in a significant performance hit.
    *findEncoded(ids, terms) {
        const [id0, id1, id2, id3] = ids;
        let map1;
        let map2;
        let map3;
        const map0 = this.nestedRecords;
        const map0Keys = id0 !== undefined ? (id0 in map0 ? [id0] : []) : Object.keys(map0);
        for (const key1 of map0Keys) {
            map1 = map0[key1];
            const map1Keys = id1 !== undefined ? (id1 in map1 ? [id1] : []) : Object.keys(map1);
            for (const key2 of map1Keys) {
                map2 = map1[key2];
                const map2Keys = id2 !== undefined ? (id2 in map2 ? [id2] : []) : Object.keys(map2);
                for (const key3 of map2Keys) {
                    map3 = map2[key3];
                    const map3Keys = id3 !== undefined ? (id3 in map3 ? [id3] : []) : Object.keys(map3);
                    for (const key4 of map3Keys) {
                        yield [
                            Number.parseInt(key1, 10),
                            Number.parseInt(key2, 10),
                            Number.parseInt(key3, 10),
                            Number.parseInt(key4, 10),
                        ];
                    }
                }
            }
        }
    }
    count(terms) {
        let count = 0;
        const ids = (0, OrderUtils_1.encodeOptionalTerms)(terms, this.dictionary);
        if (!ids) {
            return 0;
        }
        const id0 = ids[0];
        const id1 = ids[1];
        const id2 = ids[2];
        const id3 = ids[3];
        let map1;
        let map2;
        let map3;
        const map0 = this.nestedRecords;
        const map0Keys = id0 !== undefined ? (id0 in map0 ? [id0] : []) : Object.keys(map0);
        for (const key1 of map0Keys) {
            map1 = map0[key1];
            const map1Keys = id1 !== undefined ? (id1 in map1 ? [id1] : []) : Object.keys(map1);
            for (const key2 of map1Keys) {
                map2 = map1[key2];
                const map2Keys = id2 !== undefined ? (id2 in map2 ? [id2] : []) : Object.keys(map2);
                for (const key3 of map2Keys) {
                    map3 = map2[key3];
                    if (id3 !== undefined) {
                        if (id3 in map3) {
                            count++;
                        }
                    }
                    else {
                        count += Object.keys(map3).length;
                    }
                }
            }
        }
        return count;
    }
}
exports.RdfStoreIndexNestedRecord = RdfStoreIndexNestedRecord;
//# sourceMappingURL=RdfStoreIndexNestedRecord.js.map