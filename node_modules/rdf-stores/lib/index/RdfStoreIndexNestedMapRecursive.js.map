{"version":3,"file":"RdfStoreIndexNestedMapRecursive.js","sourceRoot":"","sources":["RdfStoreIndexNestedMapRecursive.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ITermDictionary } from '../dictionary/ITermDictionary';\nimport type { IRdfStoreOptions } from '../IRdfStoreOptions';\nimport { encodeOptionalTerms } from '../OrderUtils';\nimport type { EncodedQuadTerms, PatternTerm, QuadPatternTerms, QuadTerms } from '../PatternTerm';\nimport type { IRdfStoreIndex } from './IRdfStoreIndex';\nimport type { NestedMapActual } from './RdfStoreIndexNestedMap';\n\n/**\n * An RDF store index that is implemented using nested Maps,\n * and finds quads components via recursive methods calls.\n */\nexport class RdfStoreIndexNestedMapRecursive<E, V> implements IRdfStoreIndex<E, V> {\n  protected readonly dictionary: ITermDictionary<E>;\n  protected readonly nestedMap: NestedMapActual<E, V>;\n  public readonly features = {\n    quotedTripleFiltering: false,\n  };\n\n  public constructor(options: IRdfStoreOptions<E>) {\n    this.dictionary = options.dictionary;\n    this.nestedMap = new Map();\n  }\n\n  public set(terms: EncodedQuadTerms<E>, value: V): boolean {\n    let map = this.nestedMap;\n    let contained = false;\n    for (const [ i, term ] of terms.entries()) {\n      const mapActual = map;\n      let nextMap = mapActual.get(term);\n      if (!nextMap) {\n        nextMap = i === terms.length - 1 ? value : new Map();\n        mapActual.set(term, nextMap);\n      } else if (i === terms.length - 1) {\n        contained = true;\n      }\n      map = <NestedMapActual<E, V>> nextMap;\n    }\n\n    return !contained;\n  }\n\n  public remove(terms: EncodedQuadTerms<E>): boolean {\n    const map0 = this.nestedMap;\n    const map1: NestedMapActual<E, V> | undefined = <any> map0.get(terms[0]);\n    if (!map1) {\n      return false;\n    }\n    const map2: NestedMapActual<E, V> | undefined = <any> map1.get(terms[1]);\n    if (!map2) {\n      return false;\n    }\n    const map3: NestedMapActual<E, V> | undefined = <any> map2.get(terms[2]);\n    if (!map3) {\n      return false;\n    }\n    const ret = map3.delete(terms[3]);\n\n    // Clean up intermediate maps\n    if (ret && map3.size === 0) {\n      map2.delete(terms[2]);\n      if (map2.size === 0) {\n        map1.delete(terms[1]);\n        if (map1.size === 0) {\n          map0.delete(terms[0]);\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  public get(key: QuadTerms): V | undefined {\n    const encoded = encodeOptionalTerms(<QuadPatternTerms> key, this.dictionary);\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    if (!encoded || encoded.includes(undefined)) {\n      return undefined;\n    }\n    return this.getEncoded(<EncodedQuadTerms<E>> encoded);\n  }\n\n  public getEncoded(ids: EncodedQuadTerms<E>): V | undefined {\n    const map1: NestedMapActual<E, V> | undefined = <any> this.nestedMap.get(ids[0]);\n    if (!map1) {\n      return undefined;\n    }\n    const map2: NestedMapActual<E, V> | undefined = <any> map1.get(ids[1]);\n    if (!map2) {\n      return undefined;\n    }\n    const map3: NestedMapActual<E, V> | undefined = <any> map2.get(ids[2]);\n    if (!map3) {\n      return undefined;\n    }\n    return <V | undefined> map3.get(ids[3]);\n  }\n\n  public * find(terms: QuadPatternTerms): IterableIterator<QuadTerms> {\n    const ids = encodeOptionalTerms(terms, this.dictionary);\n    if (!ids) {\n      return;\n    }\n\n    for (const termsEncoded of this.findEncoded(<EncodedQuadTerms<E | undefined>> ids, terms)) {\n      yield [\n        ids[0] !== undefined ? terms[0]! : this.dictionary.decode(termsEncoded[0]),\n        ids[1] !== undefined ? terms[1]! : this.dictionary.decode(termsEncoded[1]),\n        ids[2] !== undefined ? terms[2]! : this.dictionary.decode(termsEncoded[2]),\n        ids[3] !== undefined ? terms[3]! : this.dictionary.decode(termsEncoded[3]),\n      ];\n    }\n  }\n\n  public * findEncoded(\n    ids: EncodedQuadTerms<E | undefined>,\n    terms: QuadPatternTerms,\n  ): IterableIterator<EncodedQuadTerms<E>> {\n    return yield * <IterableIterator<EncodedQuadTerms<E>>> this\n      .findEncodedInner(0, ids, terms, this.nestedMap, []);\n  }\n\n  protected * findEncodedInner(\n    index: number,\n    ids: (E | undefined)[],\n    terms: QuadPatternTerms,\n    map: NestedMapActual<E, V>,\n    partialQuad: E[],\n  ): IterableIterator<E[]> {\n    if (index === ids.length) {\n      yield [ ...partialQuad ];\n    } else {\n      const id = ids[index];\n      const currentTerm = terms[index];\n\n      // If current term is undefined, iterate over all terms at this level.\n      if (!currentTerm) {\n        for (const [ key, subMap ] of map.entries()) {\n          partialQuad[index] = key;\n          yield * this\n            .findEncodedInner(index + 1, ids, terms, <NestedMapActual<E, V>>subMap, partialQuad);\n        }\n      } else {\n        // If the current term is defined, find one matching map for the current term.\n        const encodedTerm = id;\n        if (encodedTerm !== undefined) {\n          const subMap = map.get(encodedTerm);\n          if (subMap) {\n            partialQuad[index] = <E> id;\n            yield * this\n              .findEncodedInner(index + 1, ids, terms, <NestedMapActual<E, V>>subMap, partialQuad);\n          }\n        }\n      }\n    }\n  }\n\n  public count(terms: QuadPatternTerms): number {\n    return this.countInner(0, terms, this.nestedMap);\n  }\n\n  protected countInner(\n    index: number,\n    terms: PatternTerm[],\n    map: NestedMapActual<E, V>,\n  ): number {\n    const currentTerm = terms[index];\n    let count = 0;\n\n    // If current term is undefined, iterate over all terms at this level.\n    if (!currentTerm) {\n      if (index === terms.length - 1) {\n        return map.size;\n      }\n\n      for (const subMap of map.values()) {\n        count += this.countInner(index + 1, terms, <NestedMapActual<E, V>>subMap);\n      }\n    } else {\n      // If the current term is defined, find one matching map for the current term.\n      const encodedTerm = this.dictionary.encodeOptional(currentTerm);\n      if (encodedTerm !== undefined) {\n        if (index === terms.length - 1) {\n          if (map.has(encodedTerm)) {\n            return 1;\n          }\n          return 0;\n        }\n\n        const subMap = map.get(encodedTerm);\n        if (subMap) {\n          count += this.countInner(index + 1, terms, <NestedMapActual<E, V>>subMap);\n        }\n      }\n    }\n\n    return count;\n  }\n}\n"]}