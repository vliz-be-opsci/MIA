{"version":3,"file":"RdfStoreIndexNestedMap.js","sourceRoot":"","sources":["RdfStoreIndexNestedMap.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport type { ITermDictionary } from '../dictionary/ITermDictionary';\nimport type { IRdfStoreOptions } from '../IRdfStoreOptions';\nimport { encodeOptionalTerms } from '../OrderUtils';\nimport type { EncodedQuadTerms, QuadPatternTerms, QuadTerms } from '../PatternTerm';\nimport type { IRdfStoreIndex } from './IRdfStoreIndex';\n\n/**\n * An RDF store index that is implemented using nested Maps.\n */\nexport class RdfStoreIndexNestedMap<E, V> implements IRdfStoreIndex<E, V> {\n  protected readonly dictionary: ITermDictionary<E>;\n  protected readonly nestedMap: NestedMapActual<E, V>;\n  public readonly features = {\n    quotedTripleFiltering: false,\n  };\n\n  public constructor(options: IRdfStoreOptions<E>) {\n    this.dictionary = options.dictionary;\n    this.nestedMap = new Map();\n  }\n\n  public set(terms: EncodedQuadTerms<E>, value: V): boolean {\n    const map0 = this.nestedMap;\n    let map1: NestedMapActual<E, V> = <any> map0.get(terms[0]);\n    if (!map1) {\n      map1 = new Map();\n      map0.set(terms[0], map1);\n    }\n    let map2: NestedMapActual<E, V> = <any> map1.get(terms[1]);\n    if (!map2) {\n      map2 = new Map();\n      map1.set(terms[1], map2);\n    }\n    let map3: NestedMapActual<E, V> = <any> map2.get(terms[2]);\n    if (!map3) {\n      map3 = new Map();\n      map2.set(terms[2], map3);\n    }\n    const contained = map3.has(terms[3]);\n    if (!contained) {\n      map3.set(terms[3], value);\n    }\n    return !contained;\n  }\n\n  public remove(terms: EncodedQuadTerms<E>): boolean {\n    const map0 = this.nestedMap;\n    const map1: NestedMapActual<E, V> | undefined = <any> map0.get(terms[0]);\n    if (!map1) {\n      return false;\n    }\n    const map2: NestedMapActual<E, V> | undefined = <any> map1.get(terms[1]);\n    if (!map2) {\n      return false;\n    }\n    const map3: NestedMapActual<E, V> | undefined = <any> map2.get(terms[2]);\n    if (!map3) {\n      return false;\n    }\n    const ret = map3.delete(terms[3]);\n\n    // Clean up intermediate maps\n    if (ret && map3.size === 0) {\n      map2.delete(terms[2]);\n      if (map2.size === 0) {\n        map1.delete(terms[1]);\n        if (map1.size === 0) {\n          map0.delete(terms[0]);\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  public get(key: QuadTerms): V | undefined {\n    const encoded = encodeOptionalTerms(<QuadPatternTerms> key, this.dictionary);\n    // eslint-disable-next-line unicorn/no-useless-undefined\n    if (!encoded || encoded.includes(undefined)) {\n      return undefined;\n    }\n    return this.getEncoded(<EncodedQuadTerms<E>> encoded);\n  }\n\n  public getEncoded(ids: EncodedQuadTerms<E>): V | undefined {\n    const map1: NestedMapActual<E, V> | undefined = <any> this.nestedMap.get(ids[0]);\n    if (!map1) {\n      return undefined;\n    }\n    const map2: NestedMapActual<E, V> | undefined = <any> map1.get(ids[1]);\n    if (!map2) {\n      return undefined;\n    }\n    const map3: NestedMapActual<E, V> | undefined = <any> map2.get(ids[2]);\n    if (!map3) {\n      return undefined;\n    }\n    return <V | undefined> map3.get(ids[3]);\n  }\n\n  public * find(terms: QuadPatternTerms): IterableIterator<QuadTerms> {\n    const ids = encodeOptionalTerms(terms, this.dictionary);\n    if (!ids) {\n      return;\n    }\n\n    const [ id0, id1, id2, id3 ] = ids;\n    const [ term0, term1, term2, term3 ] = terms;\n\n    let partialQuad0: RDF.Term;\n    let partialQuad1: RDF.Term;\n    let partialQuad2: RDF.Term;\n    let partialQuad3: RDF.Term;\n\n    let map1: NestedMapActual<E, V>;\n    let map2: NestedMapActual<E, V>;\n    let map3: NestedMapActual<E, V>;\n\n    const map0: NestedMapActual<E, V> = this.nestedMap;\n    const map0Keys = id0 !== undefined ? (map0.has(id0) ? [ id0 ] : []) : map0.keys();\n    for (const key1 of map0Keys) {\n      map1 = <any>map0.get(key1);\n      partialQuad0 = term0 || this.dictionary.decode(key1);\n      const map1Keys = id1 !== undefined ? (map1.has(id1) ? [ id1 ] : []) : map1.keys();\n      for (const key2 of map1Keys) {\n        map2 = <any>map1.get(key2);\n        partialQuad1 = term1 || this.dictionary.decode(key2);\n        const map2Keys = id2 !== undefined ? (map2.has(id2) ? [ id2 ] : []) : map2.keys();\n        for (const key3 of map2Keys) {\n          map3 = <any>map2.get(key3);\n          partialQuad2 = term2 || this.dictionary.decode(key3);\n          const map3Keys = id3 !== undefined ? (map3.has(id3) ? [ id3 ] : []) : map3.keys();\n          for (const key4 of map3Keys) {\n            partialQuad3 = term3 || this.dictionary.decode(key4);\n            yield <any>[ partialQuad0, partialQuad1, partialQuad2, partialQuad3 ];\n          }\n        }\n      }\n    }\n  }\n\n  // The code below is nearly identical. We duplicate because abstraction would result in a significant performance hit.\n\n  public * findEncoded(\n    ids: EncodedQuadTerms<E | undefined>,\n    terms: QuadPatternTerms,\n  ): IterableIterator<EncodedQuadTerms<E>> {\n    const [ id0, id1, id2, id3 ] = ids;\n\n    let map1: NestedMapActual<E, V>;\n    let map2: NestedMapActual<E, V>;\n    let map3: NestedMapActual<E, V>;\n\n    const map0: NestedMapActual<E, V> = this.nestedMap;\n    const map0Keys = id0 !== undefined ? (map0.has(id0) ? [ id0 ] : []) : map0.keys();\n    for (const key1 of map0Keys) {\n      map1 = <any>map0.get(key1);\n      const map1Keys = id1 !== undefined ? (map1.has(id1) ? [ id1 ] : []) : map1.keys();\n      for (const key2 of map1Keys) {\n        map2 = <any>map1.get(key2);\n        const map2Keys = id2 !== undefined ? (map2.has(id2) ? [ id2 ] : []) : map2.keys();\n        for (const key3 of map2Keys) {\n          map3 = <any>map2.get(key3);\n          const map3Keys = id3 !== undefined ? (map3.has(id3) ? [ id3 ] : []) : map3.keys();\n          for (const key4 of map3Keys) {\n            yield [ <E> key1, <E> key2, <E> key3, <E> key4 ];\n          }\n        }\n      }\n    }\n  }\n\n  public count(terms: QuadPatternTerms): number {\n    let count = 0;\n\n    const ids = encodeOptionalTerms(terms, this.dictionary);\n    if (!ids) {\n      return 0;\n    }\n    const id0 = ids[0];\n    const id1 = ids[1];\n    const id2 = ids[2];\n    const id3 = ids[3];\n\n    let map1: NestedMapActual<E, V>;\n    let map2: NestedMapActual<E, V>;\n    let map3: NestedMapActual<E, V>;\n\n    const map0: NestedMapActual<E, V> = this.nestedMap;\n    const map0Keys = id0 !== undefined ? (map0.has(id0) ? [ id0 ] : []) : map0.keys();\n    for (const key1 of map0Keys) {\n      map1 = <any>map0.get(key1);\n      const map1Keys = id1 !== undefined ? (map1.has(id1) ? [ id1 ] : []) : map1.keys();\n      for (const key2 of map1Keys) {\n        map2 = <any>map1.get(key2);\n        const map2Keys = id2 !== undefined ? (map2.has(id2) ? [ id2 ] : []) : map2.keys();\n        for (const key3 of map2Keys) {\n          map3 = <any>map2.get(key3);\n          if (id3 !== undefined) {\n            if (map3.has(id3)) {\n              count++;\n            }\n          } else {\n            count += map3.size;\n          }\n        }\n      }\n    }\n\n    return count;\n  }\n}\n\nexport type NestedMap<E, V> = NestedMapActual<E, V> | V;\nexport type NestedMapActual<E, V> = Map<E, NestedMap<E, V>>;\n"]}