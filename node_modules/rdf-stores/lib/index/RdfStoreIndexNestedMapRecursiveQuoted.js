"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RdfStoreIndexNestedMapRecursiveQuoted = void 0;
const OrderUtils_1 = require("../OrderUtils");
const RdfStoreIndexNestedMapRecursive_1 = require("./RdfStoreIndexNestedMapRecursive");
/**
 * An RDF store index that is implemented using nested Maps,
 * and finds quads components via recursive methods calls
 * with optimized quoted triple support.
 */
class RdfStoreIndexNestedMapRecursiveQuoted extends RdfStoreIndexNestedMapRecursive_1.RdfStoreIndexNestedMapRecursive {
    constructor(options) {
        super(options);
        this.features = {
            quotedTripleFiltering: true,
        };
    }
    *findEncoded(ids, terms) {
        return yield* this
            .findEncodedInnerQuoted(0, ids, terms, (0, OrderUtils_1.arePatternsQuoted)(terms), this.nestedMap, []);
    }
    *findEncodedInnerQuoted(index, ids, terms, isQuotedPattern, map, partialQuad) {
        if (index === ids.length) {
            yield [...partialQuad];
        }
        else {
            const id = ids[index];
            const currentTerm = terms[index];
            // If current term is undefined, iterate over all terms at this level.
            if (!currentTerm) {
                for (const [key, subMap] of map.entries()) {
                    partialQuad[index] = key;
                    yield* this
                        .findEncodedInnerQuoted(index + 1, ids, terms, isQuotedPattern, subMap, partialQuad);
                }
            }
            else if (isQuotedPattern[index]) {
                const quotedTriplesEncoded = this
                    .dictionary.findQuotedTriplesEncoded(currentTerm);
                // Below, we perform a type of inner (hash) join between quotedTriplesEncoded and map (with hash on map)
                for (const quotedTripleEncoded of quotedTriplesEncoded) {
                    const subMap = map.get(quotedTripleEncoded);
                    if (subMap) {
                        partialQuad[index] = quotedTripleEncoded;
                        yield* this.findEncodedInnerQuoted(index + 1, ids, terms, isQuotedPattern, subMap, partialQuad);
                    }
                }
            }
            else {
                // If the current term is defined, find one matching map for the current term.
                const encodedTerm = id;
                if (encodedTerm !== undefined) {
                    const subMap = map.get(encodedTerm);
                    if (subMap) {
                        partialQuad[index] = id;
                        yield* this.findEncodedInnerQuoted(index + 1, ids, terms, isQuotedPattern, subMap, partialQuad);
                    }
                }
            }
        }
    }
    countInner(index, terms, map) {
        const currentTerm = terms[index];
        let count = 0;
        // If current term is undefined, iterate over all terms at this level.
        if (!currentTerm) {
            if (index === terms.length - 1) {
                return map.size;
            }
            for (const subMap of map.values()) {
                count += this.countInner(index + 1, terms, subMap);
            }
        }
        else if (currentTerm.termType === 'Quad' && (0, OrderUtils_1.quadHasVariables)(currentTerm)) {
            const quotedTriplesEncoded = this.dictionary.findQuotedTriplesEncoded(currentTerm);
            // Below, we perform a type of inner (hash) join between quotedTriplesEncoded and map (with hash on map)
            for (const quotedTripleEncoded of quotedTriplesEncoded) {
                if (index === terms.length - 1) {
                    if (map.has(quotedTripleEncoded)) {
                        count++;
                    }
                }
                else {
                    const subMap = map.get(quotedTripleEncoded);
                    if (subMap) {
                        count += this.countInner(index + 1, terms, subMap);
                    }
                }
            }
        }
        else {
            // If the current term is defined, find one matching map for the current term.
            const encodedTerm = this.dictionary.encodeOptional(currentTerm);
            if (encodedTerm !== undefined) {
                if (index === terms.length - 1) {
                    if (map.has(encodedTerm)) {
                        return 1;
                    }
                    return 0;
                }
                const subMap = map.get(encodedTerm);
                if (subMap) {
                    count += this.countInner(index + 1, terms, subMap);
                }
            }
        }
        return count;
    }
}
exports.RdfStoreIndexNestedMapRecursiveQuoted = RdfStoreIndexNestedMapRecursiveQuoted;
//# sourceMappingURL=RdfStoreIndexNestedMapRecursiveQuoted.js.map