{"version":3,"file":"RdfStoreIndexNestedRecordQuoted.js","sourceRoot":"","sources":["RdfStoreIndexNestedRecordQuoted.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport type { IRdfStoreOptions } from '../IRdfStoreOptions';\nimport { arePatternsQuoted, encodeOptionalTerms } from '../OrderUtils';\nimport type { QuadPatternTerms, EncodedQuadTerms, PatternTerm, QuadTerms } from '../PatternTerm';\nimport type { NestedRecordActual } from './RdfStoreIndexNestedRecord';\nimport { RdfStoreIndexNestedRecord } from './RdfStoreIndexNestedRecord';\n\n/**\n * An RDF store index that is implemented using nested records with optimized quoted triple support.\n */\nexport class RdfStoreIndexNestedRecordQuoted<E extends number, V> extends RdfStoreIndexNestedRecord<E, V> {\n  public readonly features = {\n    quotedTripleFiltering: true,\n  };\n\n  public constructor(options: IRdfStoreOptions<E>) {\n    super(options);\n  }\n\n  protected * getQuotedPatternKeys(map: NestedRecordActual<E>, term: PatternTerm): IterableIterator<E> {\n    for (const quotedTripleEncoded of this.dictionary.findQuotedTriplesEncoded(<RDF.Quad>term)) {\n      if (quotedTripleEncoded in map) {\n        yield quotedTripleEncoded;\n      }\n    }\n  }\n\n  public * find(terms: QuadPatternTerms): IterableIterator<QuadTerms> {\n    const ids = encodeOptionalTerms(terms, this.dictionary);\n    if (!ids) {\n      return;\n    }\n\n    const [ id0, id1, id2, id3 ] = ids;\n    const [ term0, term1, term2, term3 ] = terms;\n    const [ quotedTerm0, quotedTerm1, quotedTerm2, quotedTerm3 ] = arePatternsQuoted(terms);\n\n    let partialQuad0: RDF.Term;\n    let partialQuad1: RDF.Term;\n    let partialQuad2: RDF.Term;\n    let partialQuad3: RDF.Term;\n\n    let map1: NestedRecordActual<E>;\n    let map2: NestedRecordActual<E>;\n    let map3: NestedRecordActual<E>;\n\n    const map0: NestedRecordActual<E> = this.nestedRecords;\n    const map0Keys = <E[] | string[] | IterableIterator<E>> (term0 !== undefined ?\n      (quotedTerm0 ? this.getQuotedPatternKeys(map0, term0) : (id0! in map0 ? [ id0 ] : [])) :\n      Object.keys(map0));\n    for (const key1 of map0Keys) {\n      map1 = map0[<E>key1];\n      partialQuad0 = !quotedTerm0 && term0 ? term0 : this.dictionary.decode(<E>Number.parseInt(<string>key1, 10));\n      const map1Keys = <E[] | string[] | IterableIterator<E>> (term1 !== undefined ?\n        (quotedTerm1 ? this.getQuotedPatternKeys(map1, term1) : (id1! in map1 ? [ id1 ] : [])) :\n        Object.keys(map1));\n      for (const key2 of map1Keys) {\n        map2 = map1[<E>key2];\n        partialQuad1 = !quotedTerm1 && term1 ? term1 : this.dictionary.decode(<E>Number.parseInt(<string>key2, 10));\n        const map2Keys = <E[] | string[] | IterableIterator<E>> (term2 !== undefined ?\n          (quotedTerm2 ? this.getQuotedPatternKeys(map2, term2) : (id2! in map2 ? [ id2 ] : [])) :\n          Object.keys(map2));\n        for (const key3 of map2Keys) {\n          map3 = map2[<E>key3];\n          partialQuad2 = !quotedTerm2 && term2 ? term2 : this.dictionary.decode(<E>Number.parseInt(<string>key3, 10));\n          const map3Keys = <E[] | string[] | IterableIterator<E>> (term3 !== undefined ?\n            (quotedTerm3 ? this.getQuotedPatternKeys(map3, term3) : (id3! in map3 ? [ id3 ] : [])) :\n            Object.keys(map3));\n          for (const key4 of map3Keys) {\n            partialQuad3 = !quotedTerm3 && term3 ? term3 : this.dictionary.decode(<E>Number.parseInt(<string>key4, 10));\n            yield <any>[ partialQuad0, partialQuad1, partialQuad2, partialQuad3 ];\n          }\n        }\n      }\n    }\n  }\n\n  // The code below is nearly identical. We duplicate because abstraction would result in a significant performance hit.\n\n  public * findEncoded(\n    ids: EncodedQuadTerms<E | undefined>,\n    terms: QuadPatternTerms,\n  ): IterableIterator<EncodedQuadTerms<E>> {\n    const [ id0, id1, id2, id3 ] = ids;\n    const [ term0, term1, term2, term3 ] = terms;\n    const [ quotedTerm0, quotedTerm1, quotedTerm2, quotedTerm3 ] = arePatternsQuoted(terms);\n\n    let map1: NestedRecordActual<E>;\n    let map2: NestedRecordActual<E>;\n    let map3: NestedRecordActual<E>;\n\n    const map0: NestedRecordActual<E> = this.nestedRecords;\n    const map0Keys = <E[] | string[] | IterableIterator<E>> (term0 !== undefined ?\n      (quotedTerm0 ? this.getQuotedPatternKeys(map0, term0) : (id0! in map0 ? [ id0 ] : [])) :\n      Object.keys(map0));\n    for (const key1 of map0Keys) {\n      map1 = map0[<E>key1];\n      const map1Keys = <E[] | string[] | IterableIterator<E>> (term1 !== undefined ?\n        (quotedTerm1 ? this.getQuotedPatternKeys(map1, term1) : (id1! in map1 ? [ id1 ] : [])) :\n        Object.keys(map1));\n      for (const key2 of map1Keys) {\n        map2 = map1[<E>key2];\n        const map2Keys = <E[] | string[] | IterableIterator<E>> (term2 !== undefined ?\n          (quotedTerm2 ? this.getQuotedPatternKeys(map2, term2) : (id2! in map2 ? [ id2 ] : [])) :\n          Object.keys(map2));\n        for (const key3 of map2Keys) {\n          map3 = map2[<E>key3];\n          const map3Keys = <E[] | string[] | IterableIterator<E>> (term3 !== undefined ?\n            (quotedTerm3 ? this.getQuotedPatternKeys(map3, term3) : (id3! in map3 ? [ id3 ] : [])) :\n            Object.keys(map3));\n          for (const key4 of map3Keys) {\n            yield [\n              <E>Number.parseInt(<string>key1, 10),\n              <E>Number.parseInt(<string>key2, 10),\n              <E>Number.parseInt(<string>key3, 10),\n              <E>Number.parseInt(<string>key4, 10),\n            ];\n          }\n        }\n      }\n    }\n  }\n\n  public count(terms: QuadPatternTerms): number {\n    let count = 0;\n\n    const ids = encodeOptionalTerms(terms, this.dictionary);\n    if (!ids) {\n      return 0;\n    }\n    const [ id0, id1, id2, id3 ] = ids;\n    const [ term0, term1, term2, term3 ] = terms;\n    const [ quotedTerm0, quotedTerm1, quotedTerm2, quotedTerm3 ] = arePatternsQuoted(terms);\n\n    let map1: NestedRecordActual<E>;\n    let map2: NestedRecordActual<E>;\n    let map3: NestedRecordActual<E>;\n\n    const map0: NestedRecordActual<E> = this.nestedRecords;\n    const map0Keys = <E[] | string[] | IterableIterator<E>> (term0 !== undefined ?\n      (quotedTerm0 ? this.getQuotedPatternKeys(map0, term0) : (id0! in map0 ? [ id0 ] : [])) :\n      Object.keys(map0));\n    for (const key1 of map0Keys) {\n      map1 = map0[<E>key1];\n      const map1Keys = <E[] | string[] | IterableIterator<E>> (term1 !== undefined ?\n        (quotedTerm1 ? this.getQuotedPatternKeys(map1, term1) : (id1! in map1 ? [ id1 ] : [])) :\n        Object.keys(map1));\n      for (const key2 of map1Keys) {\n        map2 = map1[<E>key2];\n        const map2Keys = <E[] | string[] | IterableIterator<E>> (term2 !== undefined ?\n          (quotedTerm2 ? this.getQuotedPatternKeys(map2, term2) : (id2! in map2 ? [ id2 ] : [])) :\n          Object.keys(map2));\n        for (const key3 of map2Keys) {\n          map3 = map2[<E>key3];\n          if (term3 !== undefined) {\n            if (quotedTerm3) {\n              count += [ ...this.getQuotedPatternKeys(map3, term3) ].length;\n            } else if (id3! in map3) {\n              count++;\n            }\n          } else {\n            count += Object.keys(map3).length;\n          }\n        }\n      }\n    }\n\n    return count;\n  }\n}\n"]}