"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RdfStoreIndexNestedMapQuoted = void 0;
const OrderUtils_1 = require("../OrderUtils");
const RdfStoreIndexNestedMap_1 = require("./RdfStoreIndexNestedMap");
/**
 * An RDF store index that is implemented using nested Maps with optimized quoted triple support.
 */
class RdfStoreIndexNestedMapQuoted extends RdfStoreIndexNestedMap_1.RdfStoreIndexNestedMap {
    constructor(options) {
        super(options);
        this.features = {
            quotedTripleFiltering: true,
        };
    }
    *getQuotedPatternKeys(map, term) {
        for (const quotedTripleEncoded of this.dictionary.findQuotedTriplesEncoded(term)) {
            if (map.has(quotedTripleEncoded)) {
                yield quotedTripleEncoded;
            }
        }
    }
    *find(terms) {
        const ids = (0, OrderUtils_1.encodeOptionalTerms)(terms, this.dictionary);
        if (!ids) {
            return;
        }
        const [id0, id1, id2, id3] = ids;
        const [term0, term1, term2, term3] = terms;
        const [quotedTerm0, quotedTerm1, quotedTerm2, quotedTerm3] = (0, OrderUtils_1.arePatternsQuoted)(terms);
        let partialQuad0;
        let partialQuad1;
        let partialQuad2;
        let partialQuad3;
        let map1;
        let map2;
        let map3;
        const map0 = this.nestedMap;
        const map0Keys = (term0 !== undefined ?
            (quotedTerm0 ? this.getQuotedPatternKeys(map0, term0) : (map0.has(id0) ? [id0] : [])) :
            map0.keys());
        for (const key1 of map0Keys) {
            map1 = map0.get(key1);
            partialQuad0 = !quotedTerm0 && term0 ? term0 : this.dictionary.decode(key1);
            const map1Keys = (term1 !== undefined ?
                (quotedTerm1 ? this.getQuotedPatternKeys(map1, term1) : (map1.has(id1) ? [id1] : [])) :
                map1.keys());
            for (const key2 of map1Keys) {
                map2 = map1.get(key2);
                partialQuad1 = !quotedTerm1 && term1 ? term1 : this.dictionary.decode(key2);
                const map2Keys = (term2 !== undefined ?
                    (quotedTerm2 ? this.getQuotedPatternKeys(map2, term2) : (map2.has(id2) ? [id2] : [])) :
                    map2.keys());
                for (const key3 of map2Keys) {
                    map3 = map2.get(key3);
                    partialQuad2 = !quotedTerm2 && term2 ? term2 : this.dictionary.decode(key3);
                    const map3Keys = (term3 !== undefined ?
                        (quotedTerm3 ? this.getQuotedPatternKeys(map3, term3) : (map3.has(id3) ? [id3] : [])) :
                        map3.keys());
                    for (const key4 of map3Keys) {
                        partialQuad3 = !quotedTerm3 && term3 ? term3 : this.dictionary.decode(key4);
                        yield [partialQuad0, partialQuad1, partialQuad2, partialQuad3];
                    }
                }
            }
        }
    }
    // The code below is nearly identical. We duplicate because abstraction would result in a significant performance hit.
    *findEncoded(ids, terms) {
        const [id0, id1, id2, id3] = ids;
        const [term0, term1, term2, term3] = terms;
        const [quotedTerm0, quotedTerm1, quotedTerm2, quotedTerm3] = (0, OrderUtils_1.arePatternsQuoted)(terms);
        let map1;
        let map2;
        let map3;
        const map0 = this.nestedMap;
        const map0Keys = (term0 !== undefined ?
            (quotedTerm0 ? this.getQuotedPatternKeys(map0, term0) : (map0.has(id0) ? [id0] : [])) :
            map0.keys());
        for (const key1 of map0Keys) {
            map1 = map0.get(key1);
            const map1Keys = (term1 !== undefined ?
                (quotedTerm1 ? this.getQuotedPatternKeys(map1, term1) : (map1.has(id1) ? [id1] : [])) :
                map1.keys());
            for (const key2 of map1Keys) {
                map2 = map1.get(key2);
                const map2Keys = (term2 !== undefined ?
                    (quotedTerm2 ? this.getQuotedPatternKeys(map2, term2) : (map2.has(id2) ? [id2] : [])) :
                    map2.keys());
                for (const key3 of map2Keys) {
                    map3 = map2.get(key3);
                    const map3Keys = (term3 !== undefined ?
                        (quotedTerm3 ? this.getQuotedPatternKeys(map3, term3) : (map3.has(id3) ? [id3] : [])) :
                        map3.keys());
                    for (const key4 of map3Keys) {
                        yield [
                            Number.parseInt(key1, 10),
                            Number.parseInt(key2, 10),
                            Number.parseInt(key3, 10),
                            Number.parseInt(key4, 10),
                        ];
                    }
                }
            }
        }
    }
    count(terms) {
        let count = 0;
        const ids = (0, OrderUtils_1.encodeOptionalTerms)(terms, this.dictionary);
        if (!ids) {
            return 0;
        }
        const [id0, id1, id2, id3] = ids;
        const [term0, term1, term2, term3] = terms;
        const [quotedTerm0, quotedTerm1, quotedTerm2, quotedTerm3] = (0, OrderUtils_1.arePatternsQuoted)(terms);
        let map1;
        let map2;
        let map3;
        const map0 = this.nestedMap;
        const map0Keys = (term0 !== undefined ?
            (quotedTerm0 ? this.getQuotedPatternKeys(map0, term0) : (map0.has(id0) ? [id0] : [])) :
            map0.keys());
        for (const key1 of map0Keys) {
            map1 = map0.get(key1);
            const map1Keys = (term1 !== undefined ?
                (quotedTerm1 ? this.getQuotedPatternKeys(map1, term1) : (map1.has(id1) ? [id1] : [])) :
                map1.keys());
            for (const key2 of map1Keys) {
                map2 = map1.get(key2);
                const map2Keys = (term2 !== undefined ?
                    (quotedTerm2 ? this.getQuotedPatternKeys(map2, term2) : (map2.has(id2) ? [id2] : [])) :
                    map2.keys());
                for (const key3 of map2Keys) {
                    map3 = map2.get(key3);
                    if (term3 !== undefined) {
                        if (quotedTerm3) {
                            count += [...this.getQuotedPatternKeys(map3, term3)].length;
                        }
                        else if (map3.has(id3)) {
                            count++;
                        }
                    }
                    else {
                        count += map3.size;
                    }
                }
            }
        }
        return count;
    }
}
exports.RdfStoreIndexNestedMapQuoted = RdfStoreIndexNestedMapQuoted;
//# sourceMappingURL=RdfStoreIndexNestedMapQuoted.js.map