"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.arePatternsQuoted = exports.quadHasVariables = exports.quadToPattern = exports.encodeOptionalTerms = exports.orderQuadComponents = exports.getComponentOrderScore = exports.getBestIndex = exports.QUAD_TERM_NAMES_INVERSE = void 0;
const rdf_terms_1 = require("rdf-terms");
exports.QUAD_TERM_NAMES_INVERSE = Object.fromEntries(rdf_terms_1.QUAD_TERM_NAMES.map((value, key) => [value, key]));
/**
 * Determine the best suitable order's index among the given orders for the given quad pattern.
 * @param componentOrders Possible orders of quad components.
 * @param quadPattern A quad pattern.
 */
function getBestIndex(componentOrders, quadPattern) {
    if (componentOrders.length === 1 || quadPattern.every(term => term !== undefined)) {
        return 0;
    }
    // Determine the quad component names for which we require a defined lookup
    const definedQuadComponentNames = [];
    for (let quadComponentId = 0; quadComponentId < rdf_terms_1.QUAD_TERM_NAMES.length; quadComponentId++) {
        if (quadPattern[quadComponentId]) {
            definedQuadComponentNames.push(rdf_terms_1.QUAD_TERM_NAMES[quadComponentId]);
        }
    }
    // Score indexes by how well they match to the index
    const scoredIndexes = componentOrders.map((componentOrder, index) => {
        const score = getComponentOrderScore(componentOrder, definedQuadComponentNames);
        return { score, index };
    });
    // Sort the indexes, and pick the first one
    return scoredIndexes.sort((scoredLeft, scoredRight) => scoredRight.score - scoredLeft.score)[0].index;
}
exports.getBestIndex = getBestIndex;
/**
 * Determine the score of the given partial component order in the given component order.
 * @param componentOrder A quad component order.
 * @param partialComponentOrder A partial quad component order that originates from a quad pattern.
 */
function getComponentOrderScore(componentOrder, partialComponentOrder) {
    return componentOrder
        .map((order, i) => partialComponentOrder.includes(order) ? componentOrder.length - i : 0)
        .reduce((acc, add) => acc + add, 0);
}
exports.getComponentOrderScore = getComponentOrderScore;
/**
 * Order a quad pattern's terms based on the given component order.
 * @param desiredComponentOrder The desired order of components.
 * @param quadPattern A quad pattern.
 */
function orderQuadComponents(desiredComponentOrder, quadPattern) {
    return desiredComponentOrder.map(desiredComponent => {
        const desiredComponentIndex = exports.QUAD_TERM_NAMES_INVERSE[desiredComponent];
        return quadPattern[desiredComponentIndex];
    });
}
exports.orderQuadComponents = orderQuadComponents;
/**
 * Encode the given array of quad terms.
 * @param terms Non-encoded quad terms.
 * @param dictionary A dictionary
 * @return array An array of encoded terms.
 * The array will be undefined if at least one of the patterns does not occur within the dictionary.
 */
function encodeOptionalTerms(terms, dictionary) {
    const encodedTerms = terms.map(term => {
        if (term) {
            if (term.termType === 'Quad' && quadHasVariables(term)) {
                return;
            }
            const encodedTerm = dictionary.encodeOptional(term);
            if (encodedTerm === undefined) {
                return 'none';
            }
            return encodedTerm;
        }
        return term;
    });
    if (encodedTerms.includes('none')) {
        return undefined;
    }
    return encodedTerms;
}
exports.encodeOptionalTerms = encodeOptionalTerms;
/**
 * Convert a quad patter to a `QuadPatternTerms` type.
 * @param subject The subject.
 * @param predicate The predicate.
 * @param object The object.
 * @param graph The graph.
 * @param quotedPatterns If the index supports quoted triple filtering.
 * @return Tuple A tuple of QuadPatternTerms
 *               and a boolean indicating if post-filtering will be needed on quoted triples.
 *               This boolean can only be true if `quotedPatterns` is false, and a quoted triple pattern was present.
 */
function quadToPattern(subject, predicate, object, graph, quotedPatterns) {
    let requireQuotedTripleFiltering = false;
    const quadPatternTerms = [subject || undefined, predicate || undefined, object || undefined, graph || undefined]
        .map(term => {
        if (term) {
            if (term.termType === 'Variable') {
                return;
            }
            if (term.termType === 'Quad') {
                if (quotedPatterns) {
                    return term;
                }
                requireQuotedTripleFiltering = true;
                return;
            }
        }
        return term;
    });
    return [quadPatternTerms, requireQuotedTripleFiltering];
}
exports.quadToPattern = quadToPattern;
/**
 * Check if the given quad contains variables, even in deeply nested quoted triples.
 * @param currentTerm The quad pattern term.
 */
function quadHasVariables(currentTerm) {
    for (const component of rdf_terms_1.QUAD_TERM_NAMES) {
        const subTerm = currentTerm[component];
        if (subTerm.termType === 'Variable' || (subTerm.termType === 'Quad' && quadHasVariables(subTerm))) {
            return true;
        }
    }
    return false;
}
exports.quadHasVariables = quadHasVariables;
/**
 * Create a boolean array indicating which terms are quoted triple patterns.
 * @param terms An array of terms.
 */
function arePatternsQuoted(terms) {
    return terms.map(term => (term === null || term === void 0 ? void 0 : term.termType) === 'Quad' && quadHasVariables(term));
}
exports.arePatternsQuoted = arePatternsQuoted;
//# sourceMappingURL=OrderUtils.js.map