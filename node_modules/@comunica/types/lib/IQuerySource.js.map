{"version":3,"file":"IQuerySource.js","sourceRoot":"","sources":["IQuerySource.ts"],"names":[],"mappings":";;AA4MA,iDAAiD;AACjD,4BAA4B;AAC5B,gCAAgC;AAChC,4CAA4C;AAC5C,uBAAuB;AACvB,oGAAoG;AACpG,yBAAyB;AACzB,wBAAwB;AACxB,wBAAwB;AACxB,wBAAwB;AACxB,OAAO;AACP,KAAK;AACL,EAAE;AACF,4CAA4C;AAC5C,uBAAuB;AACvB,sHAAsH;AACtH,yBAAyB;AACzB,wBAAwB;AACxB,wBAAwB;AACxB,wBAAwB;AACxB,wBAAwB;AACxB,OAAO;AACP,KAAK;AACL,EAAE;AACF,8CAA8C;AAC9C,uBAAuB;AACvB,oGAAoG;AACpG,yBAAyB;AACzB,wBAAwB;AACxB,wBAAwB;AACxB,wBAAwB;AACxB,OAAO;AACP,uBAAuB;AACvB,KAAK;AACL,EAAE;AACF,iEAAiE;AACjE,yBAAyB;AACzB,gBAAgB;AAChB,QAAQ;AACR,2BAA2B;AAC3B,oDAAoD;AACpD,SAAS;AACT,QAAQ;AACR,2BAA2B;AAC3B,sDAAsD;AACtD,SAAS;AACT,QAAQ;AACR,2BAA2B;AAC3B,qDAAqD;AACrD,SAAS;AACT,QAAQ;AACR,2BAA2B;AAC3B,gDAAgD;AAChD,SAAS;AACT,QAAQ;AACR,2BAA2B;AAC3B,6DAA6D;AAC7D,SAAS;AACT,OAAO;AACP,KAAK;AACL,EAAE;AACF,yBAAyB;AACzB,6FAA6F;AAC7F,4CAA4C;AAC5C,uBAAuB;AACvB,4CAA4C;AAC5C,uBAAuB;AACvB,wBAAwB;AACxB,OAAO;AACP,gBAAgB;AAChB,QAAQ;AACR,uBAAuB;AACvB,gBAAgB;AAChB,uCAAuC;AACvC,iBAAiB;AACjB,6BAA6B;AAC7B,0GAA0G;AAC1G,+BAA+B;AAC/B,8BAA8B;AAC9B,8BAA8B;AAC9B,aAAa;AACb,WAAW;AACX,SAAS;AACT,OAAO;AACP,uBAAuB;AACvB,KAAK;AACL,EAAE;AACF,0BAA0B;AAC1B,eAAe;AACf,wDAAwD;AACxD,gDAAgD;AAChD,yBAAyB;AACzB,gBAAgB;AAChB,QAAQ;AACR,2BAA2B;AAC3B,wGAAwG;AACxG,6BAA6B;AAC7B,4BAA4B;AAC5B,4BAA4B;AAC5B,4BAA4B;AAC5B,WAAW;AACX,2BAA2B;AAC3B,SAAS;AACT,QAAQ;AACR,2BAA2B;AAC3B,gDAAgD;AAChD,oBAAoB;AACpB,YAAY;AACZ,2BAA2B;AAC3B,oBAAoB;AACpB,2CAA2C;AAC3C,qBAAqB;AACrB,iCAAiC;AACjC,8GAA8G;AAC9G,mCAAmC;AACnC,kCAAkC;AAClC,iBAAiB;AACjB,eAAe;AACf,aAAa;AACb,WAAW;AACX,SAAS;AACT,OAAO;AACP,KAAK","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport type { AsyncIterator } from 'asynciterator';\nimport type { Algebra } from 'sparqlalgebrajs';\nimport type { BindingsStream } from './Bindings';\nimport type { IActionContext } from './IActionContext';\nimport type { MetadataBindings } from './IMetadata';\n\nexport interface IQuerySourceSerialized extends IQuerySourceUnidentifiedExpanded {\n  type?: 'serialized';\n  value: string;\n  mediaType: string;\n  baseIRI?: string;\n}\n\nexport interface IQuerySourceUnidentifiedExpanded {\n  type?: string;\n  value: string | RDF.Source | RDF.Store;\n  context?: IActionContext;\n}\n\nexport interface IQuerySourceUnidentifiedExpandedRawContext {\n  type?: string;\n  value: string | RDF.Source | RDF.Store;\n  context?: Record<string, any>;\n}\n\nexport type QuerySourceUnidentifiedExpanded = IQuerySourceUnidentifiedExpanded | IQuerySourceSerialized;\nexport type QuerySourceUnidentified = string | RDF.Source | RDF.Store | QuerySourceUnidentifiedExpanded |\nIQuerySourceUnidentifiedExpandedRawContext;\n\n/**\n * Attaches a context to a query target.\n */\nexport interface IQuerySourceWrapper<Q extends IQuerySource = IQuerySource> {\n  source: Q;\n  context?: IActionContext;\n}\n\nexport type QuerySourceReference = string | RDF.Source;\n\n/**\n * A lazy query source.\n */\nexport interface IQuerySource {\n  /**\n   * The URL of RDF source of this source.\n   */\n  referenceValue: QuerySourceReference;\n\n  /**\n   * Get the selector type that is supported by this source.\n   * @param context The action context.\n   */\n  getSelectorShape: (context: IActionContext) => Promise<FragmentSelectorShape>;\n\n  /**\n   * Returns a (possibly lazy) stream that returns all bindings matching the operation.\n   *\n   * Passed operations MUST conform to the query shape exposed by the selector type returned from `getSelectorShape`.\n   * The given operation represents a Linked Data Fragments selector.\n   *\n   * The returned stream MUST expose the property 'metadata' of type `MetadataBindings`.\n   * The implementor is reponsible for handling cases where 'metadata'\n   * is being called without the stream being in flow-mode.\n   * This metadata object can become invalidated (see `metadata.state`),\n   * in which case the 'metadata' property must and will be updated.\n   *\n   * @param {Algebra.Operation} operation The query operation to execute.\n   * @param {IActionContext} context      The query context.\n   * @param {BindingsStream} options      Options for querying bindings\n   * @return {AsyncIterator<RDF.Quad>} The resulting bindings stream.\n   *\n   * @see https://linkeddatafragments.org/specification/linked-data-fragments/#selectors\n   */\n  queryBindings: (\n    operation: Algebra.Operation,\n    context: IActionContext,\n    options?: IQueryBindingsOptions,\n  ) => BindingsStream;\n\n  /**\n   * Returns a (possibly lazy) stream that returns all quads matching the operation.\n   *\n   * This method should only be supported if the selector type returned from `getSelectorShape`\n   * supports construct queries.\n   *\n   * @param {Algebra.Operation} operation The query operation to execute.\n   * @param {IActionContext} context      The query context.\n   * @return {AsyncIterator<RDF.Quad>}    The resulting quads stream.\n   */\n  queryQuads: (\n    operation: Algebra.Operation,\n    context: IActionContext,\n  ) => AsyncIterator<RDF.Quad>;\n\n  /**\n   * Returns a promise resolving to the ask response of the given operation.\n   *\n   * This method should only be supported if the selector type returned from `getSelectorShape`\n   * supports ask queries.\n   *\n   * @param {Algebra.Operation} operation The query operation to execute.\n   * @param {IActionContext} context      The query context.\n   * @return {Promise<boolean>}           The resulting ask reply.\n   */\n  queryBoolean: (\n    operation: Algebra.Ask,\n    context: IActionContext,\n  ) => Promise<boolean>;\n\n  /**\n   * Returns a promise resolving when the given update operation succeeds.\n   *\n   * This method should only be supported if the selector type returned from `getSelectorShape`\n   * supports update queries.\n   *\n   * @param {Algebra.Operation} operation The query operation to execute.\n   * @param {IActionContext} context      The query context.\n   * @return {Promise<boolean>}           The void response.\n   */\n  queryVoid: (\n    operation: Algebra.Update,\n    context: IActionContext,\n  ) => Promise<void>;\n\n  /**\n   * Returns a string representation of this source.\n   */\n  toString: () => string;\n}\n\nexport interface IQueryBindingsOptions {\n  /**\n   * Bindings that must be joined by the source together with the operation.\n   * This can only be done if the source accepts joinBindings in the selector shape.\n   *\n   * The passed bindings may optionally apply to different variables than the query.\n   * If this is not the case, then `filterBindings` should be used instead.\n   */\n  joinBindings?: { bindings: BindingsStream; metadata: MetadataBindings };\n  /**\n   * Bindings to filter the query operation's result by.\n   * This can only be done if the source accepts filterBindings in the selector shape.\n   *\n   * The caller of this function should ensure that only bindings are being passed that are applicable to the query,\n   * which means that a projection and filtering step might be needed beforehand.\n   */\n  filterBindings?: { bindings: BindingsStream; metadata: MetadataBindings };\n}\n\n/**\n * A fragment selector shape determines the shape of selectors that can be executed by a query source.\n * Selectors conforming to this shape represent boolean functions to decide if triples belong to a query response.\n * @see https://linkeddatafragments.org/specification/linked-data-fragments/#selectors\n */\nexport type FragmentSelectorShape = {\n  type: 'operation';\n  /**\n   * The supported operation.\n   */\n  operation: {\n    operationType: 'type';\n    type: Algebra.types;\n  } | {\n    operationType: 'pattern';\n    pattern: Algebra.Operation;\n  };\n  /**\n   * Variables that are in-scope in this operation and its children.\n   */\n  scopedVariables?: RDF.Variable[];\n  /**\n   * Variables that must be passed to the selector when instantiated.\n   */\n  variablesRequired?: RDF.Variable[];\n  /**\n   * Variables that may be passed to the selector when instantiated.\n   */\n  variablesOptional?: RDF.Variable[];\n  /**\n   * Children of this operation.\n   */\n  children?: FragmentSelectorShape[];\n  /**\n   * If bindings can be passed into the source as a join.\n   */\n  joinBindings?: true;\n  /**\n   * If bindings can be passed into the source as a filter.\n   */\n  filterBindings?: true;\n} | {\n  type: 'conjunction';\n  children: FragmentSelectorShape[];\n} | {\n  type: 'disjunction';\n  children: FragmentSelectorShape[];\n} | {\n  type: 'arity';\n  min?: number;\n  max?: number;\n  child: FragmentSelectorShape;\n};\n\n// ----- Examples of FragmentSelectorShapes -----\n// const AF = new Factory();\n// const DF = new DataFactory();\n// const shapeTpf: FragmentSelectorShape = {\n//   type: 'operation',\n//   operation: { pattern: AF.createPattern(DF.variable('s'), DF.variable('p'), DF.variable('o')) },\n//   variablesOptional: [\n//     DF.variable('s'),\n//     DF.variable('p'),\n//     DF.variable('o'),\n//   ],\n// };\n//\n// const shapeQpf: FragmentSelectorShape = {\n//   type: 'operation',\n//   operation: { pattern: AF.createPattern(DF.variable('s'), DF.variable('p'), DF.variable('o'), DF.variable('g')) },\n//   variablesOptional: [\n//     DF.variable('s'),\n//     DF.variable('p'),\n//     DF.variable('o'),\n//     DF.variable('g'),\n//   ],\n// };\n//\n// const shapeBrTpf: FragmentSelectorShape = {\n//   type: 'operation',\n//   operation: { pattern: AF.createPattern(DF.variable('s'), DF.variable('p'), DF.variable('o')) },\n//   variablesOptional: [\n//     DF.variable('s'),\n//     DF.variable('p'),\n//     DF.variable('o'),\n//   ],\n//   addBindings: true,\n// };\n//\n// const shapeSparqlEp: FragmentSelectorShape = { // Same as SaGe\n//   type: 'disjunction',\n//   children: [\n//     {\n//       type: 'operation',\n//       operation: { type: Algebra.types.PROJECT },\n//     },\n//     {\n//       type: 'operation',\n//       operation: { type: Algebra.types.CONSTRUCT },\n//     },\n//     {\n//       type: 'operation',\n//       operation: { type: Algebra.types.DESCRIBE },\n//     },\n//     {\n//       type: 'operation',\n//       operation: { type: Algebra.types.ASK },\n//     },\n//     {\n//       type: 'operation',\n//       operation: { type: Algebra.types.COMPOSITE_UPDATE },\n//     },\n//   ],\n// };\n//\n// // Example of request:\n// //   Find ?s matching \"?s dbo:country dbr:norway. ?s dbo:award ?o2. ?s dbo:birthDate ?o3.\"\n// const shapeSpf: FragmentSelectorShape = {\n//   type: 'operation',\n//   operation: { type: Algebra.types.BGP },\n//   scopedVariables: [\n//     DF.variable('s'),\n//   ],\n//   children: [\n//     {\n//       type: 'arity',\n//       min: 1,\n//       max: Number.POSITIVE_INFINITY,\n//       child: {\n//         type: 'operation',\n//         operation: { pattern: AF.createPattern(DF.variable('s'), DF.variable('p'), DF.variable('o')) },\n//         variablesOptional: [\n//           DF.variable('p'),\n//           DF.variable('o'),\n//         ],\n//       },\n//     },\n//   ],\n//   addBindings: true,\n// };\n//\n// // Example of requests:\n// //   - brTPF\n// //   - Find all ?s and ?o matching \"?s db:country ?o\"\n// const shapeSmartKg: FragmentSelectorShape = {\n//   type: 'disjunction',\n//   children: [\n//     {\n//       type: 'operation',\n//       operation: { pattern: AF.createPattern(DF.variable('s'), DF.variable('p'), DF.variable('o')) },\n//       variablesOptional: [\n//         DF.variable('s'),\n//         DF.variable('p'),\n//         DF.variable('o'),\n//       ],\n//       addBindings: true,\n//     },\n//     {\n//       type: 'operation',\n//       operation: { type: Algebra.types.BGP },\n//       children: [\n//         {\n//           type: 'arity',\n//           min: 1,\n//           max: Number.POSITIVE_INFINITY,\n//           child: {\n//             type: 'operation',\n//             operation: { pattern: AF.createPattern(DF.variable('s'), DF.variable('p'), DF.variable('o')) },\n//             variablesRequired: [\n//               DF.variable('p'),\n//             ],\n//           },\n//         },\n//       ],\n//     },\n//   ],\n// };\n"]}