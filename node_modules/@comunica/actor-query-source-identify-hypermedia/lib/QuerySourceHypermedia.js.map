{"version":3,"file":"QuerySourceHypermedia.js","sourceRoot":"","sources":["QuerySourceHypermedia.ts"],"names":[],"mappings":"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","sourcesContent":["import { QuerySourceRdfJs } from '@comunica/actor-query-source-identify-rdfjs';\nimport type { BindingsFactory } from '@comunica/bindings-factory';\nimport type { IActorDereferenceRdfOutput, MediatorDereferenceRdf } from '@comunica/bus-dereference-rdf';\nimport type { MediatorQuerySourceIdentifyHypermedia } from '@comunica/bus-query-source-identify-hypermedia';\nimport type { IActorRdfMetadataOutput, MediatorRdfMetadata } from '@comunica/bus-rdf-metadata';\nimport type { MediatorRdfMetadataAccumulate } from '@comunica/bus-rdf-metadata-accumulate';\nimport type { MediatorRdfMetadataExtract } from '@comunica/bus-rdf-metadata-extract';\nimport type { ILink, MediatorRdfResolveHypermediaLinks } from '@comunica/bus-rdf-resolve-hypermedia-links';\nimport type { MediatorRdfResolveHypermediaLinksQueue } from '@comunica/bus-rdf-resolve-hypermedia-links-queue';\nimport { KeysQuerySourceIdentify } from '@comunica/context-entries';\nimport type {\n  BindingsStream,\n  FragmentSelectorShape,\n  IActionContext,\n  IAggregatedStore,\n  IQueryBindingsOptions,\n  IQuerySource,\n  MetadataBindings,\n} from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport type { AsyncIterator } from 'asynciterator';\nimport { TransformIterator } from 'asynciterator';\nimport { LRUCache } from 'lru-cache';\nimport { Readable } from 'readable-stream';\nimport type { Algebra } from 'sparqlalgebrajs';\nimport type { ISourceState } from './LinkedRdfSourcesAsyncRdfIterator';\nimport { MediatedLinkedRdfSourcesAsyncRdfIterator } from './MediatedLinkedRdfSourcesAsyncRdfIterator';\nimport { StreamingStoreMetadata } from './StreamingStoreMetadata';\n\nexport class QuerySourceHypermedia implements IQuerySource {\n  public readonly referenceValue: string;\n  public readonly firstUrl: string;\n  public readonly forceSourceType?: string;\n  public readonly aggregateStore: boolean;\n  public readonly mediators: IMediatorArgs;\n  public readonly logWarning: (warningMessage: string) => void;\n  public readonly bindingsFactory: BindingsFactory;\n\n  /**\n   * A cache for source URLs to source states.\n   */\n  public sourcesState: LRUCache<string, Promise<ISourceState>>;\n\n  private readonly cacheSize: number;\n  private readonly maxIterators: number;\n\n  public constructor(\n    cacheSize: number,\n    firstUrl: string,\n    forceSourceType: string | undefined,\n    maxIterators: number,\n    aggregateStore: boolean,\n    mediators: IMediatorArgs,\n    logWarning: (warningMessage: string) => void,\n    bindingsFactory: BindingsFactory,\n  ) {\n    this.referenceValue = firstUrl;\n    this.cacheSize = cacheSize;\n    this.firstUrl = firstUrl;\n    this.forceSourceType = forceSourceType;\n    this.maxIterators = maxIterators;\n    this.mediators = mediators;\n    this.aggregateStore = aggregateStore;\n    this.logWarning = logWarning;\n    this.bindingsFactory = bindingsFactory;\n    this.sourcesState = new LRUCache<string, Promise<ISourceState>>({ max: this.cacheSize });\n  }\n\n  public async getSelectorShape(context: IActionContext): Promise<FragmentSelectorShape> {\n    const source = await this.getSourceCached({ url: this.firstUrl }, {}, context, this.getAggregateStore(context));\n    return source.source.getSelectorShape(context);\n  }\n\n  public queryBindings(\n    operation: Algebra.Operation,\n    context: IActionContext,\n    options?: IQueryBindingsOptions,\n  ): BindingsStream {\n    // Optimized match with aggregated store if enabled and started.\n    const aggregatedStore: IAggregatedStore | undefined = this.getAggregateStore(context);\n    if (aggregatedStore && operation.type === 'pattern' && aggregatedStore.started) {\n      return new QuerySourceRdfJs(aggregatedStore, this.bindingsFactory).queryBindings(operation, context);\n    }\n\n    // Initialize the sources state on first call\n    if (this.sourcesState.size === 0) {\n      this.getSourceCached({ url: this.firstUrl }, {}, context, aggregatedStore)\n        .catch(error => it.destroy(error));\n    }\n\n    const it: MediatedLinkedRdfSourcesAsyncRdfIterator = new MediatedLinkedRdfSourcesAsyncRdfIterator(\n      this.cacheSize,\n      operation,\n      options,\n      context,\n      this.forceSourceType,\n      this.firstUrl,\n      this.maxIterators,\n      (link, handledDatasets) => this.getSourceCached(link, handledDatasets, context, aggregatedStore),\n      aggregatedStore,\n      this.mediators.mediatorMetadataAccumulate,\n      this.mediators.mediatorRdfResolveHypermediaLinks,\n      this.mediators.mediatorRdfResolveHypermediaLinksQueue,\n    );\n    if (aggregatedStore) {\n      aggregatedStore.started = true;\n\n      // Kickstart this iterator when derived iterators are created from the aggregatedStore,\n      // otherwise the traversal process will not start if this iterator is not the first one to be consumed.\n      const listener = (): void => it.kickstart();\n      aggregatedStore.addIteratorCreatedListener(listener);\n      it.on('end', () => aggregatedStore.removeIteratorCreatedListener(listener));\n    }\n\n    return it;\n  }\n\n  public queryQuads(operation: Algebra.Operation, context: IActionContext): AsyncIterator<RDF.Quad> {\n    return new TransformIterator(async() => {\n      const source = await this.getSourceCached({ url: this.firstUrl }, {}, context, this.getAggregateStore(context));\n      return source.source.queryQuads(operation, context);\n    });\n  }\n\n  public async queryBoolean(operation: Algebra.Ask, context: IActionContext): Promise<boolean> {\n    const source = await this.getSourceCached({ url: this.firstUrl }, {}, context, this.getAggregateStore(context));\n    return await source.source.queryBoolean(operation, context);\n  }\n\n  public async queryVoid(operation: Algebra.Update, context: IActionContext): Promise<void> {\n    const source = await this.getSourceCached({ url: this.firstUrl }, {}, context, this.getAggregateStore(context));\n    return await source.source.queryVoid(operation, context);\n  }\n\n  /**\n   * Resolve a source for the given URL.\n   * @param link A source link.\n   * @param handledDatasets A hash of dataset identifiers that have already been handled.\n   * @param context The action context.\n   * @param aggregatedStore An optional aggregated store.\n   */\n  public async getSource(\n    link: ILink,\n    handledDatasets: Record<string, boolean>,\n    context: IActionContext,\n    aggregatedStore: IAggregatedStore | undefined,\n  ): Promise<ISourceState> {\n    // Include context entries from link\n    if (link.context) {\n      context = context.merge(link.context);\n    }\n\n    // Get the RDF representation of the given document\n    let url = link.url;\n    let quads: RDF.Stream;\n    let metadata: Record<string, any>;\n    try {\n      const dereferenceRdfOutput: IActorDereferenceRdfOutput = await this.mediators.mediatorDereferenceRdf\n        .mediate({ context, url });\n      url = dereferenceRdfOutput.url;\n\n      // Determine the metadata\n      const rdfMetadataOutput: IActorRdfMetadataOutput = await this.mediators.mediatorMetadata.mediate(\n        { context, url, quads: dereferenceRdfOutput.data, triples: dereferenceRdfOutput.metadata?.triples },\n      );\n\n      rdfMetadataOutput.data.on('error', () => {\n        // Silence errors in the data stream,\n        // as they will be emitted again in the metadata stream,\n        // and will result in a promise rejection anyways.\n        // If we don't do this, we end up with an unhandled error message\n      });\n\n      metadata = (await this.mediators.mediatorMetadataExtract.mediate({\n        context,\n        url,\n        // The problem appears to be conflicting metadata keys here\n        metadata: rdfMetadataOutput.metadata,\n        headers: dereferenceRdfOutput.headers,\n        requestTime: dereferenceRdfOutput.requestTime,\n      })).metadata;\n      quads = rdfMetadataOutput.data;\n\n      // Optionally filter the resulting data\n      if (link.transform) {\n        quads = await link.transform(quads);\n      }\n    } catch (error: unknown) {\n      // Make sure that dereference errors are only emitted once an actor really needs the read quads\n      // This for example allows SPARQL endpoints that error on service description fetching to still be source-forcible\n      quads = new Readable();\n      quads.read = () => {\n        setTimeout(() => quads.emit('error', error));\n        return null;\n      };\n      ({ metadata } = await this.mediators.mediatorMetadataAccumulate.mediate({ context, mode: 'initialize' }));\n\n      // Log as warning, because the quads above may not always be consumed (e.g. for SPARQL endpoints),\n      // so the user would not be notified of something going wrong otherwise.\n      this.logWarning(`Metadata extraction for ${url} failed: ${(<Error> error).message}`);\n    }\n\n    // Aggregate all discovered quads into a store.\n    aggregatedStore?.setBaseMetadata(<MetadataBindings> metadata, false);\n    aggregatedStore?.containedSources.add(link.url);\n    aggregatedStore?.import(quads);\n\n    // Determine the source\n    const { source, dataset } = await this.mediators.mediatorQuerySourceIdentifyHypermedia.mediate({\n      context,\n      forceSourceType: link.url === this.firstUrl ? this.forceSourceType : undefined,\n      handledDatasets,\n      metadata,\n      quads,\n      url,\n    });\n\n    if (dataset) {\n      // Mark the dataset as applied\n      // This is needed to make sure that things like QPF search forms are only applied once,\n      // and next page links are followed after that.\n      handledDatasets[dataset] = true;\n    }\n\n    return { link, source, metadata: <MetadataBindings> metadata, handledDatasets };\n  }\n\n  /**\n   * Resolve a source for the given URL.\n   * This will first try to retrieve the source from cache.\n   * @param link A source ILink.\n   * @param handledDatasets A hash of dataset identifiers that have already been handled.\n   * @param context The action context.\n   * @param aggregatedStore An optional aggregated store.\n   */\n  protected getSourceCached(\n    link: ILink,\n    handledDatasets: Record<string, boolean>,\n    context: IActionContext,\n    aggregatedStore: IAggregatedStore | undefined,\n  ): Promise<ISourceState> {\n    let source = this.sourcesState.get(link.url);\n    if (source) {\n      return source;\n    }\n    source = this.getSource(link, handledDatasets, context, aggregatedStore);\n    if (link.url === this.firstUrl || aggregatedStore === undefined) {\n      this.sourcesState.set(link.url, source);\n    }\n    return source;\n  }\n\n  public getAggregateStore(context: IActionContext): IAggregatedStore | undefined {\n    let aggregatedStore: IAggregatedStore | undefined;\n    if (this.aggregateStore) {\n      const aggregatedStores: Map<string, IAggregatedStore> | undefined = context\n        .get(KeysQuerySourceIdentify.hypermediaSourcesAggregatedStores);\n      if (aggregatedStores) {\n        aggregatedStore = aggregatedStores.get(this.firstUrl);\n        if (!aggregatedStore) {\n          aggregatedStore = new StreamingStoreMetadata(\n            undefined,\n            async(accumulatedMetadata, appendingMetadata) => <MetadataBindings>\n              (await this.mediators.mediatorMetadataAccumulate.mediate({\n                mode: 'append',\n                accumulatedMetadata,\n                appendingMetadata,\n                context,\n              })).metadata,\n          );\n          aggregatedStores.set(this.firstUrl, aggregatedStore);\n        }\n        return aggregatedStore;\n      }\n    }\n  }\n\n  public toString(): string {\n    return `QuerySourceHypermedia(${this.firstUrl})`;\n  }\n}\n\nexport interface IMediatorArgs {\n  mediatorDereferenceRdf: MediatorDereferenceRdf;\n  mediatorMetadata: MediatorRdfMetadata;\n  mediatorMetadataExtract: MediatorRdfMetadataExtract;\n  mediatorMetadataAccumulate: MediatorRdfMetadataAccumulate;\n  mediatorQuerySourceIdentifyHypermedia: MediatorQuerySourceIdentifyHypermedia;\n  mediatorRdfResolveHypermediaLinks: MediatorRdfResolveHypermediaLinks;\n  mediatorRdfResolveHypermediaLinksQueue: MediatorRdfResolveHypermediaLinksQueue;\n}\n"]}