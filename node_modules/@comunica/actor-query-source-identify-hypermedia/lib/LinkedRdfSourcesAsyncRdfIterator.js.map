{"version":3,"file":"LinkedRdfSourcesAsyncRdfIterator.js","sourceRoot":"","sources":["LinkedRdfSourcesAsyncRdfIterator.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ILink } from '@comunica/bus-rdf-resolve-hypermedia-links';\nimport type { ILinkQueue } from '@comunica/bus-rdf-resolve-hypermedia-links-queue';\nimport { MetadataValidationState } from '@comunica/metadata';\nimport type { IQuerySource, IActionContext, MetadataBindings, IQueryBindingsOptions } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport type { AsyncIterator, BufferedIteratorOptions } from 'asynciterator';\nimport { BufferedIterator } from 'asynciterator';\nimport type { Algebra } from 'sparqlalgebrajs';\n\nexport abstract class LinkedRdfSourcesAsyncRdfIterator extends BufferedIterator<RDF.Bindings> {\n  protected readonly operation: Algebra.Operation;\n  protected readonly queryBindingsOptions: IQueryBindingsOptions | undefined;\n  protected readonly context: IActionContext;\n\n  private readonly cacheSize: number;\n  protected readonly firstUrl: string;\n  private readonly maxIterators: number;\n  private readonly sourceStateGetter: SourceStateGetter;\n\n  protected started = false;\n  private readonly currentIterators: AsyncIterator<RDF.Bindings>[] = [];\n  private iteratorsPendingCreation = 0;\n  private iteratorsPendingTermination = 0;\n  // eslint-disable-next-line unicorn/no-useless-undefined\n  private accumulatedMetadata: Promise<MetadataBindings | undefined> = Promise.resolve(undefined);\n  private preflightMetadata: Promise<MetadataBindings> | undefined;\n\n  public constructor(\n    cacheSize: number,\n    operation: Algebra.Operation,\n    queryBindingsOptions: IQueryBindingsOptions | undefined,\n    context: IActionContext,\n    firstUrl: string,\n    maxIterators: number,\n    sourceStateGetter: SourceStateGetter,\n    options?: BufferedIteratorOptions,\n  ) {\n    super({ autoStart: false, ...options });\n    this._reading = false;\n    this.cacheSize = cacheSize;\n    this.operation = operation;\n    this.queryBindingsOptions = queryBindingsOptions;\n    this.context = context;\n    this.firstUrl = firstUrl;\n    this.maxIterators = maxIterators;\n    this.sourceStateGetter = sourceStateGetter;\n\n    if (this.maxIterators <= 0) {\n      throw new Error(`LinkedRdfSourcesAsyncRdfIterator.maxIterators must be larger than zero, but got ${this.maxIterators}`);\n    }\n  }\n\n  /**\n   * Start filling the buffer of this iterator.\n   */\n  public kickstart(): void {\n    if (!this.started) {\n      this._fillBufferAsync();\n    }\n  }\n\n  public override getProperty<P>(propertyName: string, callback?: (value: P) => void): P | undefined {\n    if (propertyName === 'metadata' && !this.started) {\n      // If the iterator has not started yet, forcefully fetch the metadata from the source without starting the\n      // iterator. This way, we keep the iterator lazy.\n      if (!this.preflightMetadata) {\n        this.preflightMetadata = new Promise((resolve, reject) => {\n          this.sourceStateGetter({ url: this.firstUrl }, {})\n            .then((sourceState) => {\n              // Don't pass query options, as we don't want to consume any passed iterators\n              const bindingsStream = sourceState.source.queryBindings(this.operation, this.context);\n              bindingsStream.getProperty('metadata', (metadata: MetadataBindings) => {\n                metadata.state = new MetadataValidationState();\n                bindingsStream.destroy();\n                this.accumulateMetadata(sourceState.metadata, metadata)\n                  .then((accumulatedMetadata) => {\n                    // Also merge fields that were not explicitly accumulated\n                    const returnMetadata = { ...sourceState.metadata, ...metadata, ...accumulatedMetadata };\n                    resolve(returnMetadata);\n                  })\n                  .catch(() => {\n                    resolve({\n                      ...sourceState.metadata,\n                      state: new MetadataValidationState(),\n                    });\n                  });\n              });\n            })\n            .catch(reject);\n        });\n      }\n      this.preflightMetadata\n        .then(metadata => this.setProperty('metadata', metadata))\n        .catch(() => {\n          // Ignore errors\n        });\n    }\n    return super.getProperty(propertyName, callback);\n  }\n\n  protected override _end(destroy?: boolean): void {\n    // Close all running iterators\n    for (const it of this.currentIterators) {\n      it.destroy();\n    }\n\n    super._end(destroy);\n  }\n\n  /**\n   * Get the internal link queue.\n   * The returned instance must always be the same.\n   */\n  public abstract getLinkQueue(): Promise<ILinkQueue>;\n\n  /**\n   * Determine the links to be followed from the current source given its metadata.\n   * @param metadata The metadata of a source.\n   */\n  protected abstract getSourceLinks(metadata: Record<string, any>): Promise<ILink[]>;\n\n  public override _read(count: number, done: () => void): void {\n    if (this.started) {\n      // Read from all current iterators\n      for (const iterator of this.currentIterators) {\n        while (count > 0) {\n          const read = iterator.read();\n          if (read === null) {\n            break;\n          } else {\n            count--;\n            this._push(read);\n          }\n        }\n        if (count <= 0) {\n          break;\n        }\n      }\n\n      // Schedule new iterators if needed\n      if (count >= 0 && this.canStartNewIterator()) {\n        // We can safely ignore skip catching the error, since we are guaranteed to have\n        // successfully got the source for this.firstUrl before.\n        // eslint-disable-next-line ts/no-floating-promises\n        this.sourceStateGetter({ url: this.firstUrl }, {})\n          .then((sourceState) => {\n            this.startIteratorsForNextUrls(sourceState.handledDatasets, false);\n            done();\n          });\n      } else {\n        done();\n      }\n    } else {\n      // The first time this is called, prepare the first source\n      this.started = true;\n\n      // Await the source to be set, and start the source iterator\n      this.sourceStateGetter({ url: this.firstUrl }, {})\n        .then((sourceState) => {\n          this.startIterator(sourceState);\n          done();\n        })\n        // Destroy should be async because it can be called before it is listened to\n        .catch(error => setTimeout(() => this.destroy(error)));\n    }\n  }\n\n  protected canStartNewIterator(): boolean {\n    return (this.currentIterators.length + this.iteratorsPendingCreation + this.iteratorsPendingTermination) <\n      this.maxIterators && (!this.canStartNewIteratorConsiderReadable() || !this.readable);\n  }\n\n  protected canStartNewIteratorConsiderReadable(): boolean {\n    return true;\n  }\n\n  protected areIteratorsRunning(): boolean {\n    return (this.currentIterators.length + this.iteratorsPendingCreation + this.iteratorsPendingTermination) > 0;\n  }\n\n  /**\n   * Append the fields from appendingMetadata into accumulatedMetadata.\n   * @param accumulatedMetadata The fields to append to.\n   * @param appendingMetadata The fields to append.\n   * @protected\n   */\n  protected abstract accumulateMetadata(\n    accumulatedMetadata: MetadataBindings,\n    appendingMetadata: MetadataBindings,\n  ): Promise<MetadataBindings>;\n\n  /**\n   * Start a new iterator for the given source.\n   * Once the iterator is done, it will either determine a new source, or it will close the linked iterator.\n   * @param {ISourceState} startSource The start source state.\n   */\n  protected startIterator(startSource: ISourceState): void {\n    // Delegate the quad pattern query to the given source\n    try {\n      const iterator = startSource.source.queryBindings(this.operation, this.context, this.queryBindingsOptions);\n      this.currentIterators.push(iterator);\n      let receivedEndEvent = false;\n      let receivedMetadata = false;\n\n      // Attach readers to the newly created iterator\n      (<any>iterator)._destination = this;\n      iterator.on('error', (error: Error) => this.destroy(error));\n      iterator.on('readable', () => this._fillBuffer());\n      iterator.on('end', () => {\n        this.currentIterators.splice(this.currentIterators.indexOf(iterator), 1);\n\n        // Indicate that this iterator still needs to flush its next-links.\n        // Without this, the linked iterator could sometimes be closed before next-links are obtained.\n        receivedEndEvent = true;\n        if (!receivedMetadata) {\n          this.iteratorsPendingTermination++;\n        }\n\n        // If the metadata was already received, handle the next URL in the queue\n        if (receivedMetadata) {\n          this.startIteratorsForNextUrls(startSource.handledDatasets, true);\n        }\n      });\n\n      // Listen for the metadata of the source\n      // The metadata property is guaranteed to be set\n      iterator.getProperty('metadata', (metadata: MetadataBindings) => {\n        // Accumulate the metadata object\n        this.accumulatedMetadata = this.accumulatedMetadata\n          .then(previousMetadata => (async() => {\n            if (!previousMetadata) {\n              previousMetadata = startSource.metadata;\n            }\n            return this.accumulateMetadata(previousMetadata, metadata);\n          })()\n            .then((accumulatedMetadata) => {\n              // Also merge fields that were not explicitly accumulated\n              const returnMetadata = { ...startSource.metadata, ...metadata, ...accumulatedMetadata };\n\n              // Create new metadata state\n              returnMetadata.state = new MetadataValidationState();\n\n              // Emit metadata, and invalidate any metadata that was set before\n              this.updateMetadata(returnMetadata);\n\n              // Invalidate any preflight metadata\n              if (this.preflightMetadata) {\n                this.preflightMetadata\n                  .then(metadataIn => metadataIn.state.invalidate())\n                  .catch(() => {\n                    // Ignore errors\n                  });\n              }\n\n              // Determine next urls, which will eventually become a next-next source.\n              this.getSourceLinks(returnMetadata)\n                .then((nextUrls: ILink[]) => Promise.all(nextUrls))\n                .then(async(nextUrls: ILink[]) => {\n                  // Append all next URLs to our queue\n                  const linkQueue = await this.getLinkQueue();\n                  for (const nextUrl of nextUrls) {\n                    linkQueue.push(nextUrl, startSource.link);\n                  }\n\n                  receivedMetadata = true;\n                  if (receivedEndEvent) {\n                    this.iteratorsPendingTermination--;\n                  }\n\n                  this.startIteratorsForNextUrls(startSource.handledDatasets, true);\n                }).catch(error => this.destroy(error));\n\n              return returnMetadata;\n            })).catch((error) => {\n            this.destroy(error);\n            return <MetadataBindings>{};\n          });\n      });\n    } catch (syncError: unknown) {\n      this.destroy(<Error> syncError);\n    }\n  }\n\n  protected updateMetadata(metadataNew: MetadataBindings): void {\n    const metadataToInvalidate = this.getProperty<MetadataBindings>('metadata');\n    this.setProperty('metadata', metadataNew);\n    metadataToInvalidate?.state.invalidate();\n  }\n\n  protected isRunning(): boolean {\n    return !this.done;\n  }\n\n  /**\n   * Check if a next URL is in the queue.\n   * If yes, start a new iterator.\n   * If no, close this iterator.\n   * @param handledDatasets\n   * @param canClose\n   */\n  protected startIteratorsForNextUrls(handledDatasets: Record<string, boolean>, canClose: boolean): void {\n    this.getLinkQueue()\n      .then((linkQueue) => {\n        // Create as many new iterators as possible\n        while (this.canStartNewIterator() && this.isRunning()) {\n          const nextLink = linkQueue.pop();\n          if (nextLink) {\n            this.iteratorsPendingCreation++;\n            this.sourceStateGetter(nextLink, handledDatasets)\n              .then((nextSourceState) => {\n                this.iteratorsPendingCreation--;\n                this.startIterator(nextSourceState);\n              })\n              .catch(error => this.emit('error', error));\n          } else {\n            break;\n          }\n        }\n\n        // Close, only if no other iterators are still running\n        if (canClose && this.isCloseable(linkQueue, true)) {\n          this.close();\n        }\n      })\n      .catch(error => this.destroy(error));\n  }\n\n  protected isCloseable(linkQueue: ILinkQueue, _requireQueueEmpty: boolean): boolean {\n    return linkQueue.isEmpty() && !this.areIteratorsRunning();\n  }\n}\n\n/**\n * The current state of a source.\n * This is needed for following links within a source.\n */\nexport interface ISourceState {\n  /**\n   * The link to this source.\n   */\n  link: ILink;\n  /**\n   * A source.\n   */\n  source: IQuerySource;\n  /**\n   * The source's initial metadata.\n   */\n  metadata: MetadataBindings;\n  /**\n   * All dataset identifiers that have been passed for this source.\n   */\n  handledDatasets: Record<string, boolean>;\n}\n\nexport type SourceStateGetter = (link: ILink, handledDatasets: Record<string, boolean>) => Promise<ISourceState>;\n"]}