{"version":3,"file":"MediatedLinkedRdfSourcesAsyncRdfIterator.js","sourceRoot":"","sources":["MediatedLinkedRdfSourcesAsyncRdfIterator.ts"],"names":[],"mappings":"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","sourcesContent":["import type { MediatorRdfMetadataAccumulate } from '@comunica/bus-rdf-metadata-accumulate';\nimport type { ILink, MediatorRdfResolveHypermediaLinks } from '@comunica/bus-rdf-resolve-hypermedia-links';\nimport type {\n  ILinkQueue,\n  MediatorRdfResolveHypermediaLinksQueue,\n} from '@comunica/bus-rdf-resolve-hypermedia-links-queue';\nimport { KeysQueryOperation } from '@comunica/context-entries';\nimport type { IActionContext, IAggregatedStore, IQueryBindingsOptions, MetadataBindings } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport { DataFactory } from 'rdf-data-factory';\nimport type { Algebra } from 'sparqlalgebrajs';\nimport { Factory } from 'sparqlalgebrajs';\nimport type { SourceStateGetter, ISourceState } from './LinkedRdfSourcesAsyncRdfIterator';\nimport { LinkedRdfSourcesAsyncRdfIterator } from './LinkedRdfSourcesAsyncRdfIterator';\n\nconst DF = new DataFactory<RDF.BaseQuad>();\nconst AF = new Factory();\n\n/**\n * An quad iterator that can iterate over consecutive RDF sources\n * that are determined using the rdf-resolve-hypermedia-links bus.\n *\n * @see LinkedRdfSourcesAsyncRdfIterator\n */\nexport class MediatedLinkedRdfSourcesAsyncRdfIterator extends LinkedRdfSourcesAsyncRdfIterator {\n  private readonly mediatorMetadataAccumulate: MediatorRdfMetadataAccumulate;\n  private readonly mediatorRdfResolveHypermediaLinks: MediatorRdfResolveHypermediaLinks;\n  private readonly mediatorRdfResolveHypermediaLinksQueue: MediatorRdfResolveHypermediaLinksQueue;\n  private readonly forceSourceType?: string;\n  private readonly handledUrls: Record<string, boolean>;\n  private readonly aggregatedStore: IAggregatedStore | undefined;\n  private linkQueue: Promise<ILinkQueue> | undefined;\n  private wasForcefullyClosed = false;\n\n  public constructor(\n    cacheSize: number,\n    operation: Algebra.Operation,\n    queryBindingsOptions: IQueryBindingsOptions | undefined,\n    context: IActionContext,\n    forceSourceType: string | undefined,\n    firstUrl: string,\n    maxIterators: number,\n    sourceStateGetter: SourceStateGetter,\n    aggregatedStore: IAggregatedStore | undefined,\n    mediatorMetadataAccumulate: MediatorRdfMetadataAccumulate,\n    mediatorRdfResolveHypermediaLinks: MediatorRdfResolveHypermediaLinks,\n    mediatorRdfResolveHypermediaLinksQueue: MediatorRdfResolveHypermediaLinksQueue,\n  ) {\n    super(\n      cacheSize,\n      operation,\n      queryBindingsOptions,\n      context,\n      firstUrl,\n      maxIterators,\n      sourceStateGetter,\n      // Buffersize must be infinite for an aggregated store because it must keep filling until there are no more\n      // derived iterators in the aggregated store.\n      aggregatedStore ? { maxBufferSize: Number.POSITIVE_INFINITY } : undefined,\n    );\n    this.forceSourceType = forceSourceType;\n    this.mediatorMetadataAccumulate = mediatorMetadataAccumulate;\n    this.mediatorRdfResolveHypermediaLinks = mediatorRdfResolveHypermediaLinks;\n    this.mediatorRdfResolveHypermediaLinksQueue = mediatorRdfResolveHypermediaLinksQueue;\n    this.handledUrls = { [firstUrl]: true };\n    this.aggregatedStore = aggregatedStore;\n  }\n\n  // Mark the aggregated store as ended once we trigger the closing or destroying of this iterator.\n  // We don't override _end, because that would mean that we have to wait\n  // until the buffer of this iterator must be fully consumed, which will not always be the case.\n\n  public override close(): void {\n    if (!this.aggregatedStore) {\n      super.close();\n      return;\n    }\n\n    this.getLinkQueue()\n      .then((linkQueue) => {\n        if (this.isCloseable(linkQueue, false)) {\n          // Wait a tick before ending the aggregatedStore, to ensure that pending match() calls to it have started.\n          if (this.aggregatedStore) {\n            setTimeout(() => this.aggregatedStore!.end());\n          }\n          super.close();\n        } else {\n          this.wasForcefullyClosed = true;\n        }\n      })\n      .catch(error => super.destroy(error));\n  }\n\n  public override destroy(cause?: Error): void {\n    if (!this.aggregatedStore) {\n      super.destroy(cause);\n      return;\n    }\n\n    this.getLinkQueue()\n      .then((linkQueue) => {\n        if (cause ?? this.isCloseable(linkQueue, false)) {\n          // Wait a tick before ending the aggregatedStore, to ensure that pending match() calls to it have started.\n          if (this.aggregatedStore) {\n            setTimeout(() => this.aggregatedStore!.end());\n          }\n          super.destroy(cause);\n        } else {\n          this.wasForcefullyClosed = true;\n        }\n      })\n      .catch(error => super.destroy(error));\n  }\n\n  protected override isCloseable(linkQueue: ILinkQueue, requireQueueEmpty: boolean): boolean {\n    return (requireQueueEmpty ? linkQueue.isEmpty() : this.wasForcefullyClosed || linkQueue.isEmpty()) &&\n      !this.areIteratorsRunning();\n  }\n\n  protected override canStartNewIterator(): boolean {\n    // Also allow sub-iterators to be started if the aggregated store has at least one running iterator.\n    // We need this because there are cases where these running iterators will be consumed before this linked iterator.\n    return (!this.wasForcefullyClosed &&\n      // eslint-disable-next-line ts/prefer-nullish-coalescing\n      (this.aggregatedStore && this.aggregatedStore.hasRunningIterators())) || super.canStartNewIterator();\n  }\n\n  protected override canStartNewIteratorConsiderReadable(): boolean {\n    return !this.aggregatedStore;\n  }\n\n  protected override isRunning(): boolean {\n    // Same as above\n    // eslint-disable-next-line ts/prefer-nullish-coalescing\n    return (this.aggregatedStore && this.aggregatedStore.hasRunningIterators()) || !this.done;\n  }\n\n  public getLinkQueue(): Promise<ILinkQueue> {\n    if (!this.linkQueue) {\n      this.linkQueue = this.mediatorRdfResolveHypermediaLinksQueue\n        .mediate({ firstUrl: this.firstUrl, context: this.context })\n        .then(result => result.linkQueue);\n    }\n    return this.linkQueue;\n  }\n\n  protected async getSourceLinks(metadata: Record<string, any>): Promise<ILink[]> {\n    try {\n      const { links } = await this.mediatorRdfResolveHypermediaLinks.mediate({ context: this.context, metadata });\n\n      // Filter URLs to avoid cyclic next-page loops\n      return links.filter((link) => {\n        if (this.handledUrls[link.url]) {\n          return false;\n        }\n        this.handledUrls[link.url] = true;\n        return true;\n      });\n    } catch {\n      // No next URLs may be available, for example when we've reached the end of a Hydra next-page sequence.\n      return [];\n    }\n  }\n\n  protected override startIterator(startSource: ISourceState): void {\n    if (this.aggregatedStore && !this.aggregatedStore.containedSources.has(startSource.link.url)) {\n      // A source that has been cached due to earlier query executions may not be part of the aggregated store yet.\n      // In that case, we add all quads from that source to the aggregated store.\n      this.aggregatedStore?.containedSources.add(startSource.link.url);\n      const stream = startSource.source.queryBindings(\n        AF.createPattern(\n          DF.variable('s'),\n          DF.variable('p'),\n          DF.variable('o'),\n          DF.variable('g'),\n        ),\n        this.context.set(KeysQueryOperation.unionDefaultGraph, true),\n      ).map(bindings => DF.quad(\n        bindings.get('s')!,\n        bindings.get('p')!,\n        bindings.get('o')!,\n        bindings.get('g'),\n      ));\n      this.aggregatedStore.import(<RDF.Stream> stream)\n        .on('end', () => {\n          super.startIterator(startSource);\n        });\n    } else {\n      super.startIterator(startSource);\n    }\n  }\n\n  public async accumulateMetadata(\n    accumulatedMetadata: MetadataBindings,\n    appendingMetadata: MetadataBindings,\n  ): Promise<MetadataBindings> {\n    return <MetadataBindings> (await this.mediatorMetadataAccumulate.mediate({\n      mode: 'append',\n      accumulatedMetadata,\n      appendingMetadata,\n      context: this.context,\n    })).metadata;\n  }\n\n  protected override updateMetadata(metadataNew: MetadataBindings): void {\n    super.updateMetadata(metadataNew);\n    this.aggregatedStore?.setBaseMetadata(metadataNew, true);\n  }\n}\n"]}