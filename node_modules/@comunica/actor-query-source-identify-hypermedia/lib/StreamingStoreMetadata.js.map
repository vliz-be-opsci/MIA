{"version":3,"file":"StreamingStoreMetadata.js","sourceRoot":"","sources":["StreamingStoreMetadata.ts"],"names":[],"mappings":"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","sourcesContent":["// eslint-disable-next-line import/no-nodejs-modules\nimport type { EventEmitter } from 'node:events';\nimport { ClosableTransformIterator } from '@comunica/bus-query-operation';\nimport { MetadataValidationState } from '@comunica/metadata';\nimport type { MetadataQuads, IAggregatedStore, MetadataBindings } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport type { AsyncIterator } from 'asynciterator';\nimport { StreamingStore } from 'rdf-streaming-store';\n\n/**\n * A StreamingStore that returns an AsyncIterator with a valid MetadataQuads property.\n */\nexport class StreamingStoreMetadata extends StreamingStore implements IAggregatedStore {\n  public started = false;\n  public containedSources = new Set<string>();\n  public readonly runningIterators: Set<AsyncIterator<RDF.Quad>> = new Set<AsyncIterator<RDF.Quad>>();\n  protected readonly iteratorCreatedListeners: Set<() => void> = new Set();\n  protected readonly metadataAccumulator:\n  (accumulatedMetadata: MetadataBindings, appendingMetadata: MetadataBindings) => Promise<MetadataBindings>;\n\n  protected baseMetadata: MetadataBindings = {\n    state: new MetadataValidationState(),\n    cardinality: { type: 'exact', value: 0 },\n    canContainUndefs: false,\n    variables: [],\n  };\n\n  public constructor(\n    store: RDF.Store | undefined,\n    metadataAccumulator:\n    (accumulatedMetadata: MetadataBindings, appendingMetadata: MetadataBindings) => Promise<MetadataBindings>,\n  ) {\n    super(store);\n    this.metadataAccumulator = metadataAccumulator;\n  }\n\n  public override import(stream: RDF.Stream): EventEmitter {\n    if (!this.ended) {\n      super.import(stream);\n    }\n    return stream;\n  }\n\n  public hasRunningIterators(): boolean {\n    return this.runningIterators.size > 0;\n  }\n\n  public override match(\n    subject?: RDF.Term | null,\n    predicate?: RDF.Term | null,\n    object?: RDF.Term | null,\n    graph?: RDF.Term | null,\n  ): AsyncIterator<RDF.Quad> {\n    // Wrap the raw stream in an AsyncIterator\n    const rawStream = super.match(subject, predicate, object, graph);\n    const iterator = new ClosableTransformIterator<RDF.Quad, RDF.Quad>(\n      <any> rawStream,\n      {\n        autoStart: false,\n        onClose: () => {\n          // Running iterators are deleted once closed or destroyed\n          this.runningIterators.delete(iterator);\n        },\n      },\n    );\n\n    // Expose the metadata property containing the cardinality\n    let count = this.getStore().countQuads(subject!, predicate!, object!, graph!);\n    const metadata: MetadataQuads = {\n      state: new MetadataValidationState(),\n      cardinality: {\n        type: 'estimate',\n        value: count,\n      },\n      canContainUndefs: false,\n    };\n    iterator.setProperty('metadata', metadata);\n    iterator.setProperty('lastCount', count);\n\n    // Every time a new quad is pushed into the iterator, update the metadata\n    rawStream.on('quad', () => {\n      iterator.setProperty('lastCount', ++count);\n      this.updateMetadataState(iterator, count);\n    });\n\n    // Store all running iterators until they close or are destroyed\n    this.runningIterators.add(iterator);\n\n    // Invoke creation listeners\n    for (const listener of this.iteratorCreatedListeners) {\n      listener();\n    }\n\n    return iterator;\n  }\n\n  public setBaseMetadata(metadata: MetadataBindings, updateStates: boolean): void {\n    this.baseMetadata = { ...metadata };\n    this.baseMetadata.cardinality = { type: 'exact', value: 0 };\n\n    if (updateStates) {\n      for (const iterator of this.runningIterators) {\n        const count: number = iterator.getProperty('lastCount')!;\n        this.updateMetadataState(iterator, count);\n      }\n    }\n  }\n\n  protected updateMetadataState(iterator: AsyncIterator<RDF.Quad>, count: number): void {\n    // Append the given cardinality to the base metadata\n    const metadataNew: MetadataBindings = {\n      state: new MetadataValidationState(),\n      cardinality: {\n        type: 'estimate',\n        value: count,\n      },\n      canContainUndefs: false,\n      variables: [],\n    };\n\n    this.metadataAccumulator(this.baseMetadata, metadataNew)\n      .then((accumulatedMetadata) => {\n        accumulatedMetadata.state = new MetadataValidationState();\n\n        // Set the new metadata, and invalidate the previous state\n        const metadataToInvalidate = iterator.getProperty<MetadataQuads>('metadata');\n        iterator.setProperty('metadata', accumulatedMetadata);\n        metadataToInvalidate?.state.invalidate();\n      })\n      .catch(() => {\n        // Void errors\n      });\n  }\n\n  public addIteratorCreatedListener(listener: () => void): void {\n    this.iteratorCreatedListeners.add(listener);\n  }\n\n  public removeIteratorCreatedListener(listener: () => void): void {\n    this.iteratorCreatedListeners.delete(listener);\n  }\n}\n"]}