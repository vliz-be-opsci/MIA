"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorQueryOperationValues = void 0;
const bindings_factory_1 = require("@comunica/bindings-factory");
const bus_query_operation_1 = require("@comunica/bus-query-operation");
const metadata_1 = require("@comunica/metadata");
const asynciterator_1 = require("asynciterator");
const rdf_data_factory_1 = require("rdf-data-factory");
const DF = new rdf_data_factory_1.DataFactory();
/**
 * A comunica Values Query Operation Actor.
 */
class ActorQueryOperationValues extends bus_query_operation_1.ActorQueryOperationTyped {
    constructor(args) {
        super(args, 'values');
    }
    async testOperation(_operation, _context) {
        return true;
    }
    async runOperation(operation, context) {
        const bindingsFactory = await bindings_factory_1.BindingsFactory.create(this.mediatorMergeBindingsContext, context);
        const bindingsStream = new asynciterator_1.ArrayIterator(operation.bindings
            .map(x => bindingsFactory.bindings(Object.entries(x)
            .map(([key, value]) => [DF.variable(key.slice(1)), value]))));
        const variables = operation.variables;
        const metadata = () => Promise.resolve({
            state: new metadata_1.MetadataValidationState(),
            cardinality: { type: 'exact', value: operation.bindings.length },
            canContainUndefs: operation.bindings.some(bindings => variables.some(variable => !(`?${variable.value}` in bindings))),
            variables,
        });
        return { type: 'bindings', bindingsStream, metadata };
    }
}
exports.ActorQueryOperationValues = ActorQueryOperationValues;
//# sourceMappingURL=ActorQueryOperationValues.js.map