{"version":3,"file":"ActorQueryOperationGroup.js","sourceRoot":"","sources":["ActorQueryOperationGroup.ts"],"names":[],"mappings":"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","sourcesContent":["import { BindingsFactory } from '@comunica/bindings-factory';\nimport type { MediatorHashBindings } from '@comunica/bus-hash-bindings';\nimport type { MediatorMergeBindingsContext } from '@comunica/bus-merge-bindings-context';\nimport type { IActorQueryOperationTypedMediatedArgs } from '@comunica/bus-query-operation';\nimport { ActorQueryOperation, ActorQueryOperationTypedMediated } from '@comunica/bus-query-operation';\nimport type { IActorTest } from '@comunica/core';\nimport { AsyncEvaluator } from '@comunica/expression-evaluator';\nimport type { BindingsStream, IActionContext, IQueryOperationResult } from '@comunica/types';\nimport { ArrayIterator, TransformIterator } from 'asynciterator';\nimport type { Algebra } from 'sparqlalgebrajs';\nimport { GroupsState } from './GroupsState';\n\n/**\n * A comunica Group Query Operation Actor.\n */\nexport class ActorQueryOperationGroup extends ActorQueryOperationTypedMediated<Algebra.Group> {\n  public readonly mediatorHashBindings: MediatorHashBindings;\n  public readonly mediatorMergeBindingsContext: MediatorMergeBindingsContext;\n\n  public constructor(args: IActorQueryOperationGroupArgs) {\n    super(args, 'group');\n  }\n\n  public async testOperation(operation: Algebra.Group, context: IActionContext): Promise<IActorTest> {\n    const bindingsFactory = await BindingsFactory.create(this.mediatorMergeBindingsContext, context);\n    for (const aggregate of operation.aggregates) {\n      // Will throw for unsupported expressions\n      const _ = new AsyncEvaluator(\n        aggregate.expression,\n        ActorQueryOperation.getAsyncExpressionContext(context, this.mediatorQueryOperation, bindingsFactory),\n      );\n    }\n    return true;\n  }\n\n  public async runOperation(operation: Algebra.Group, context: IActionContext):\n  Promise<IQueryOperationResult> {\n    const bindingsFactory = await BindingsFactory.create(this.mediatorMergeBindingsContext, context);\n    // Create a hash function\n    const { hashFunction } = await this.mediatorHashBindings.mediate({ allowHashCollisions: true, context });\n\n    // Get result stream for the input query\n    const { input, aggregates } = operation;\n    const outputRaw = await this.mediatorQueryOperation.mediate({ operation: input, context });\n    const output = ActorQueryOperation.getSafeBindings(outputRaw);\n\n    // The variables in scope are the variables on which we group, i.e. pattern.variables.\n    // For 'GROUP BY ?x, ?z', this is [?x, ?z], for 'GROUP by expr(?x) as ?e' this is [?e].\n    // But also in scope are the variables defined by the aggregations, since GROUP has to handle this.\n    const variables = [\n      ...operation.variables,\n      ...aggregates.map(agg => agg.variable),\n    ];\n\n    const sparqleeConfig = ActorQueryOperation.getAsyncExpressionContext(\n      context,\n      this.mediatorQueryOperation,\n      bindingsFactory,\n    );\n\n    // Wrap a new promise inside an iterator that completes when the stream has ended or when an error occurs\n    const bindingsStream = new TransformIterator(() => new Promise<BindingsStream>((resolve, reject) => {\n      const groups = new GroupsState(hashFunction, operation, sparqleeConfig, bindingsFactory);\n\n      // Phase 2: Collect aggregator results\n      // We can only return when the binding stream ends, when that happens\n      // we return the identified groups. Which are nothing more than Bindings\n      // of the grouping variables merged with the aggregate variables\n      // eslint-disable-next-line ts/no-misused-promises\n      output.bindingsStream.on('end', async() => {\n        try {\n          const bindingsStreamInner = new ArrayIterator(await groups.collectResults(), { autoStart: false });\n          resolve(bindingsStreamInner);\n        } catch (error: unknown) {\n          reject(error);\n        }\n      });\n\n      // Make sure to propagate any errors in the binding stream\n      output.bindingsStream.on('error', reject);\n\n      // Phase 1: Consume the stream, identify the groups and populate the aggregators.\n      // We need to bind this after the 'error' and 'end' listeners to avoid the\n      // stream having ended before those listeners are bound.\n      output.bindingsStream.on('data', (bindings) => {\n        groups.consumeBindings(bindings).catch(reject);\n      });\n    }), { autoStart: false });\n\n    return {\n      type: 'bindings',\n      bindingsStream,\n      metadata: async() => ({ ...await output.metadata(), variables }),\n    };\n  }\n}\n\nexport interface IActorQueryOperationGroupArgs extends IActorQueryOperationTypedMediatedArgs {\n  mediatorHashBindings: MediatorHashBindings;\n  /**\n   * A mediator for creating binding context merge handlers\n   */\n  mediatorMergeBindingsContext: MediatorMergeBindingsContext;\n}\n"]}