import type * as RDF from '@rdfjs/types';
import type { Algebra } from 'sparqlalgebrajs';
import type { ICompleteSharedContext } from '../evaluators/evaluatorHelpers/BaseExpressionEvaluator';
import type * as E from '../expressions';
import type { ITermTransformer } from '../transformers/TermTransformer';
import type { IAggregatorComponentClass } from '.';
export declare abstract class AggregatorComponent {
    protected sharedContext: ICompleteSharedContext;
    abstract put(bindings: RDF.Term | undefined): void;
    abstract result(): RDF.Term | undefined;
    protected separator: string;
    protected termTransformer: ITermTransformer;
    static emptyValue(): RDF.Term | undefined;
    constructor(expr: Algebra.AggregateExpression, sharedContext: ICompleteSharedContext);
    protected termToNumericOrError(term: RDF.Term): E.NumericLiteral;
}
/**
 * A base aggregator that can handle distinct and possibly wildcards.
 */
export declare class Aggregator {
    protected aggregatorComponent: AggregatorComponent;
    protected distinct: boolean;
    protected variableValues: Map<string, Set<string>>;
    constructor(expr: Algebra.AggregateExpression, aggregatorComponent: AggregatorComponent);
    static emptyValue(component: IAggregatorComponentClass): RDF.Term | undefined;
    result(): RDF.Term | undefined;
    put(bindings: RDF.Term, variable?: string): void;
    private canSkip;
    private addSeen;
}
