"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WildcardCountAggregator = void 0;
const RdfString = require("rdf-string");
const Helpers_1 = require("../functions/Helpers");
/**
 * Implementation of the COUNT aggregator on a wildcard.
 * We choose to make this is separate class, because it would pollute the code of the other aggregators.
 */
class WildcardCountAggregator {
    constructor(expr) {
        // Key: string representation of a ',' separated list of terms.
        // Value: string representation of a ',' separated list of variables sorted by name.
        this.bindingValues = new Map();
        this.counter = 0;
        this.distinct = expr.distinct;
    }
    putBindings(bindings) {
        if (!this.handleDistinct(bindings)) {
            this.counter += 1;
        }
    }
    static emptyValue() {
        return (0, Helpers_1.integer)(0).toRDF();
    }
    result() {
        return (0, Helpers_1.integer)(this.counter).toRDF();
    }
    /**
     * Returns true if the given bindings should be skipped.
     * @param bindings
     * @private
     */
    handleDistinct(bindings) {
        if (this.distinct) {
            const bindingList = [...bindings];
            bindingList.sort((first, snd) => first[0].value.localeCompare(snd[0].value));
            const variables = bindingList.map(([variable]) => variable.value).join(',');
            const terms = bindingList.map(([, term]) => RdfString.termToString(term)).join(',');
            const set = this.bindingValues.get(variables);
            const result = set !== undefined && set.has(terms);
            // Add to the set:
            if (!set) {
                this.bindingValues.set(variables, new Set());
            }
            this.bindingValues.get(variables).add(terms);
            return result;
        }
        return false;
    }
}
exports.WildcardCountAggregator = WildcardCountAggregator;
//# sourceMappingURL=WildcardCountAggregator.js.map