{"version":3,"file":"Aggregator.js","sourceRoot":"","sources":["Aggregator.ts"],"names":[],"mappings":";;;AACA,wCAAwC;AAIxC,qEAAkE;AAElE,2CAA2C;AAC3C,uDAAmD;AAGnD,MAAsB,mBAAmB;IAOhC,MAAM,CAAC,UAAU;QACtB,OAAO,SAAS,CAAC;IACnB,CAAC;IAED,YAAmB,IAAiC,EAAY,aAAqC;QAArC,kBAAa,GAAb,aAAa,CAAwB;QACnG,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,SAAS,IAAI,GAAG,CAAC;QACvC,IAAI,CAAC,eAAe,GAAG,IAAI,iCAAe,CAAC,aAAa,CAAC,iBAAiB,CAAC,CAAC;IAC9E,CAAC;IAES,oBAAoB,CAAC,IAAc;QAC3C,IAAI,IAAI,CAAC,QAAQ,KAAK,SAAS,EAAE,CAAC;YAChC,MAAM,IAAI,KAAK,CAAC,mBAAmB,IAAI,CAAC,KAAK,aAAa,IAAI,CAAC,QAAQ,+BAA+B,CAAC,CAAC;QAC1G,CAAC;aAAM,IACL,CAAC,IAAA,0BAAW,EAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,kBAAS,CAAC,cAAc,EAAE,IAAI,CAAC,aAAa,CAAC,iBAAiB,CAAC,EACjG,CAAC;YACD,MAAM,IAAI,KAAK,CAAC,iBAAiB,IAAI,CAAC,QAAQ,CAAC,KAAK,eAAe,IAAI,CAAC,KAAK,aAAa,IAAI,CAAC,QAAQ,+BAA+B,CAAC,CAAC;QAC1I,CAAC;QACD,OAA0B,IAAI,CAAC,eAAe,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;IACxE,CAAC;CACF;AA1BD,kDA0BC;AAED;;GAEG;AACH,MAAa,UAAU;IAIrB,YAAmB,IAAiC,EAAY,mBAAwC;QAAxC,wBAAmB,GAAnB,mBAAmB,CAAqB;QAF9F,mBAAc,GAA6B,IAAI,GAAG,EAAE,CAAC;QAG7D,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;IAChC,CAAC;IAEM,MAAM,CAAC,UAAU,CAAC,SAAoC;QAC3D,OAAO,SAAS,CAAC,UAAU,EAAE,CAAC;IAChC,CAAC;IAEM,MAAM;QACX,OAAO,IAAI,CAAC,mBAAmB,CAAC,MAAM,EAAE,CAAC;IAC3C,CAAC;IAEM,GAAG,CAAC,QAAkB,EAAE,QAAQ,GAAG,EAAE;QAC1C,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,QAAQ,CAAC,EAAE,CAAC;YACtC,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;YACvC,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;QACnC,CAAC;IACH,CAAC;IAEO,OAAO,CAAC,IAAc,EAAE,QAAgB;QAC9C,MAAM,GAAG,GAAG,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;QAC9C,OAAO,IAAI,CAAC,QAAQ,IAAI,GAAG,KAAK,SAAS,IAAI,GAAG,CAAC,GAAG,CAAC,SAAS,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC;IACrF,CAAC;IAEO,OAAO,CAAC,IAAc,EAAE,QAAgB;QAC9C,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;YAClB,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC;gBACvC,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,QAAQ,EAAE,IAAI,GAAG,EAAE,CAAC,CAAC;YAC/C,CAAC;YACD,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,QAAQ,CAAE,CAAC,GAAG,CAAC,SAAS,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC;QACvE,CAAC;IACH,CAAC;CACF;AApCD,gCAoCC","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport * as RdfString from 'rdf-string';\nimport type { Algebra } from 'sparqlalgebrajs';\nimport type { ICompleteSharedContext } from '../evaluators/evaluatorHelpers/BaseExpressionEvaluator';\nimport type * as E from '../expressions';\nimport { TermTransformer } from '../transformers/TermTransformer';\nimport type { ITermTransformer } from '../transformers/TermTransformer';\nimport { TypeAlias } from '../util/Consts';\nimport { isSubTypeOf } from '../util/TypeHandling';\nimport type { IAggregatorComponentClass } from '.';\n\nexport abstract class AggregatorComponent {\n  public abstract put(bindings: RDF.Term | undefined): void;\n  public abstract result(): RDF.Term | undefined;\n\n  protected separator: string;\n  protected termTransformer: ITermTransformer;\n\n  public static emptyValue(): RDF.Term | undefined {\n    return undefined;\n  }\n\n  public constructor(expr: Algebra.AggregateExpression, protected sharedContext: ICompleteSharedContext) {\n    this.separator = expr.separator || ' ';\n    this.termTransformer = new TermTransformer(sharedContext.superTypeProvider);\n  }\n\n  protected termToNumericOrError(term: RDF.Term): E.NumericLiteral {\n    if (term.termType !== 'Literal') {\n      throw new Error(`Term with value ${term.value} has type ${term.termType} and is not a numeric literal`);\n    } else if (\n      !isSubTypeOf(term.datatype.value, TypeAlias.SPARQL_NUMERIC, this.sharedContext.superTypeProvider)\n    ) {\n      throw new Error(`Term datatype ${term.datatype.value} with value ${term.value} has type ${term.termType} and is not a numeric literal`);\n    }\n    return <E.NumericLiteral> this.termTransformer.transformLiteral(term);\n  }\n}\n\n/**\n * A base aggregator that can handle distinct and possibly wildcards.\n */\nexport class Aggregator {\n  protected distinct: boolean;\n  protected variableValues: Map<string, Set<string>> = new Map();\n\n  public constructor(expr: Algebra.AggregateExpression, protected aggregatorComponent: AggregatorComponent) {\n    this.distinct = expr.distinct;\n  }\n\n  public static emptyValue(component: IAggregatorComponentClass): RDF.Term | undefined {\n    return component.emptyValue();\n  }\n\n  public result(): RDF.Term | undefined {\n    return this.aggregatorComponent.result();\n  }\n\n  public put(bindings: RDF.Term, variable = ''): void {\n    if (!this.canSkip(bindings, variable)) {\n      this.aggregatorComponent.put(bindings);\n      this.addSeen(bindings, variable);\n    }\n  }\n\n  private canSkip(term: RDF.Term, variable: string): boolean {\n    const set = this.variableValues.get(variable);\n    return this.distinct && set !== undefined && set.has(RdfString.termToString(term));\n  }\n\n  private addSeen(term: RDF.Term, variable: string): void {\n    if (this.distinct) {\n      if (!this.variableValues.has(variable)) {\n        this.variableValues.set(variable, new Set());\n      }\n      this.variableValues.get(variable)!.add(RdfString.termToString(term));\n    }\n  }\n}\n"]}