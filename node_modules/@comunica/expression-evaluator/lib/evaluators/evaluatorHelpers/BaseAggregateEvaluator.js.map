{"version":3,"file":"BaseAggregateEvaluator.js","sourceRoot":"","sources":["BaseAggregateEvaluator.ts"],"names":[],"mappings":";;;AACA,qDAA0C;AAC1C,mDAAgD;AAChD,6DAA0D;AAC1D,uFAAoF;AAEpF,yCAAyC;AAGzC,MAAsB,sBAAsB;IAQ1C,YACE,IAAiC,EACjC,aAAqC,EACrC,UAAoB;QARZ,eAAU,GAAG,KAAK,CAAC;QACnB,eAAU,GAAG,KAAK,CAAC;QAEnB,kBAAa,GAAG,KAAK,CAAC;QAO9B,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;QACvB,IAAI,CAAC,UAAU,GAAG,IAAI,uBAAU,CAAC,IAAI,EAAE,IAAI,yBAAW,CAAe,IAAI,CAAC,UAAU,CAAC,CAAC,IAAI,EAAE,aAAa,CAAC,CAAC,CAAC;QAC5G,IAAI,CAAC,UAAU,GAAG,UAAU,IAAI,KAAK,CAAC;QACtC,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC,cAAc,KAAK,yBAAO,CAAC,eAAe,CAAC,QAAQ,CAAC;QACtF,IAAI,IAAI,CAAC,UAAU,EAAE,CAAC;YACpB,IAAI,CAAC,kBAAkB,GAAG,IAAI,iDAAuB,CAAC,IAAI,CAAC,CAAC;QAC9D,CAAC;IACH,CAAC;IAED;;;;;;;;OAQG;IACI,MAAM,CAAC,UAAU,CAAC,IAAiC,EAAE,UAAU,GAAG,KAAK;QAC5E,IAAI,GAAyB,CAAC;QAC9B,IAAI,IAAI,CAAC,UAAU,CAAC,cAAc,KAAK,yBAAO,CAAC,eAAe,CAAC,QAAQ,EAAE,CAAC;YACxE,GAAG,GAAG,iDAAuB,CAAC,UAAU,EAAE,CAAC;QAC7C,CAAC;aAAM,CAAC;YACN,GAAG,GAAG,uBAAU,CAAC,UAAU,CAAC,yBAAW,CAAe,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC;QAC1E,CAAC;QACD,IAAI,GAAG,KAAK,SAAS,IAAI,UAAU,EAAE,CAAC;YACpC,MAAM,IAAI,GAAG,CAAC,mBAAmB,EAAE,CAAC;QACtC,CAAC;QACD,OAAO,GAAG,CAAC;IACb,CAAC;IAEM,MAAM;QACX,IAAI,IAAI,CAAC,aAAa,EAAE,CAAC;YACvB,OAAO,SAAS,CAAC;QACnB,CAAC;QACD,IAAI,IAAI,CAAC,UAAU,EAAE,CAAC;YACpB,OAAO,IAAI,CAAC,kBAAmB,CAAC,MAAM,EAAE,CAAC;QAC3C,CAAC;QACD,OAAO,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC;IAClC,CAAC;CAaF;AAjED,wDAiEC","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport { Algebra } from 'sparqlalgebrajs';\nimport { aggregators } from '../../aggregators';\nimport { Aggregator } from '../../aggregators/Aggregator';\nimport { WildcardCountAggregator } from '../../aggregators/WildcardCountAggregator';\nimport type { SetFunction } from '../../util/Consts';\nimport * as Err from '../../util/Errors';\nimport type { ICompleteSharedContext } from './BaseExpressionEvaluator';\n\nexport abstract class BaseAggregateEvaluator {\n  protected expression: Algebra.AggregateExpression;\n  protected aggregator: Aggregator;\n  protected throwError = false;\n  protected isWildcard = false;\n  protected wildcardAggregator: WildcardCountAggregator | undefined;\n  protected errorOccurred = false;\n\n  protected constructor(\n    expr: Algebra.AggregateExpression,\n    sharedContext: ICompleteSharedContext,\n    throwError?: boolean,\n  ) {\n    this.expression = expr;\n    this.aggregator = new Aggregator(expr, new aggregators[<SetFunction> expr.aggregator](expr, sharedContext));\n    this.throwError = throwError ?? false;\n    this.isWildcard = expr.expression.expressionType === Algebra.expressionTypes.WILDCARD;\n    if (this.isWildcard) {\n      this.wildcardAggregator = new WildcardCountAggregator(expr);\n    }\n  }\n\n  /**\n   * The spec says to throw an error when a set function is called on an empty\n   * set (unless explicitly mentioned otherwise like COUNT).\n   * However, aggregate error handling says to not bind the result in case of an\n   * error. So to simplify logic in the caller, we return undefined by default.\n   *\n   * @param expr the aggregate expression\n   * @param throwError whether this function should respect the spec and throw an error if no empty value is defined\n   */\n  public static emptyValue(expr: Algebra.AggregateExpression, throwError = false): RDF.Term | undefined {\n    let val: RDF.Term | undefined;\n    if (expr.expression.expressionType === Algebra.expressionTypes.WILDCARD) {\n      val = WildcardCountAggregator.emptyValue();\n    } else {\n      val = Aggregator.emptyValue(aggregators[<SetFunction> expr.aggregator]);\n    }\n    if (val === undefined && throwError) {\n      throw new Err.EmptyAggregateError();\n    }\n    return val;\n  }\n\n  public result(): RDF.Term | undefined {\n    if (this.errorOccurred) {\n      return undefined;\n    }\n    if (this.isWildcard) {\n      return this.wildcardAggregator!.result();\n    }\n    return this.aggregator.result();\n  }\n\n  /**\n   * Put a binding from the result stream in the aggregate state.\n   *\n   * If any binding evaluation errors, the corresponding aggregate variable should be unbound.\n   * If this happens, calling @see result() will return @constant undefined\n   *\n   * @param bindings the bindings to pass to the expression\n   */\n  public abstract put(bindings: RDF.Bindings): void | Promise<void>;\n\n  protected abstract safeThrow(err: unknown): void;\n}\n"]}