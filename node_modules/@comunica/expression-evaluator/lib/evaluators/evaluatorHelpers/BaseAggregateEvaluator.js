"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseAggregateEvaluator = void 0;
const sparqlalgebrajs_1 = require("sparqlalgebrajs");
const aggregators_1 = require("../../aggregators");
const Aggregator_1 = require("../../aggregators/Aggregator");
const WildcardCountAggregator_1 = require("../../aggregators/WildcardCountAggregator");
const Err = require("../../util/Errors");
class BaseAggregateEvaluator {
    constructor(expr, sharedContext, throwError) {
        this.throwError = false;
        this.isWildcard = false;
        this.errorOccurred = false;
        this.expression = expr;
        this.aggregator = new Aggregator_1.Aggregator(expr, new aggregators_1.aggregators[expr.aggregator](expr, sharedContext));
        this.throwError = throwError ?? false;
        this.isWildcard = expr.expression.expressionType === sparqlalgebrajs_1.Algebra.expressionTypes.WILDCARD;
        if (this.isWildcard) {
            this.wildcardAggregator = new WildcardCountAggregator_1.WildcardCountAggregator(expr);
        }
    }
    /**
     * The spec says to throw an error when a set function is called on an empty
     * set (unless explicitly mentioned otherwise like COUNT).
     * However, aggregate error handling says to not bind the result in case of an
     * error. So to simplify logic in the caller, we return undefined by default.
     *
     * @param expr the aggregate expression
     * @param throwError whether this function should respect the spec and throw an error if no empty value is defined
     */
    static emptyValue(expr, throwError = false) {
        let val;
        if (expr.expression.expressionType === sparqlalgebrajs_1.Algebra.expressionTypes.WILDCARD) {
            val = WildcardCountAggregator_1.WildcardCountAggregator.emptyValue();
        }
        else {
            val = Aggregator_1.Aggregator.emptyValue(aggregators_1.aggregators[expr.aggregator]);
        }
        if (val === undefined && throwError) {
            throw new Err.EmptyAggregateError();
        }
        return val;
    }
    result() {
        if (this.errorOccurred) {
            return undefined;
        }
        if (this.isWildcard) {
            return this.wildcardAggregator.result();
        }
        return this.aggregator.result();
    }
}
exports.BaseAggregateEvaluator = BaseAggregateEvaluator;
//# sourceMappingURL=BaseAggregateEvaluator.js.map