import type * as RDF from '@rdfjs/types';
import { Algebra } from 'sparqlalgebrajs';
import { Aggregator } from '../../aggregators/Aggregator';
import { WildcardCountAggregator } from '../../aggregators/WildcardCountAggregator';
import type { ICompleteSharedContext } from './BaseExpressionEvaluator';
export declare abstract class BaseAggregateEvaluator {
    protected expression: Algebra.AggregateExpression;
    protected aggregator: Aggregator;
    protected throwError: boolean;
    protected isWildcard: boolean;
    protected wildcardAggregator: WildcardCountAggregator | undefined;
    protected errorOccurred: boolean;
    protected constructor(expr: Algebra.AggregateExpression, sharedContext: ICompleteSharedContext, throwError?: boolean);
    /**
     * The spec says to throw an error when a set function is called on an empty
     * set (unless explicitly mentioned otherwise like COUNT).
     * However, aggregate error handling says to not bind the result in case of an
     * error. So to simplify logic in the caller, we return undefined by default.
     *
     * @param expr the aggregate expression
     * @param throwError whether this function should respect the spec and throw an error if no empty value is defined
     */
    static emptyValue(expr: Algebra.AggregateExpression, throwError?: boolean): RDF.Term | undefined;
    result(): RDF.Term | undefined;
    /**
     * Put a binding from the result stream in the aggregate state.
     *
     * If any binding evaluation errors, the corresponding aggregate variable should be unbound.
     * If this happens, calling @see result() will return @constant undefined
     *
     * @param bindings the bindings to pass to the expression
     */
    abstract put(bindings: RDF.Bindings): void | Promise<void>;
    protected abstract safeThrow(err: unknown): void;
}
