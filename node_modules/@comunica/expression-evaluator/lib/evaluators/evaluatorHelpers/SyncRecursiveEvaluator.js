"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SyncRecursiveEvaluator = void 0;
const E = require("../../expressions");
const TermTransformer_1 = require("../../transformers/TermTransformer");
const Err = require("../../util/Errors");
const BaseExpressionEvaluator_1 = require("./BaseExpressionEvaluator");
class SyncRecursiveEvaluator extends BaseExpressionEvaluator_1.BaseExpressionEvaluator {
    constructor(context, termTransformer) {
        super(termTransformer ?? new TermTransformer_1.TermTransformer(context.superTypeProvider));
        this.context = context;
        this.subEvaluators = {
            // Shared
            [E.ExpressionType.Term]: (expr, _mapping) => this.term(expr),
            [E.ExpressionType.Variable]: (expr, mapping) => this.variable(expr, mapping),
            // Sync
            [E.ExpressionType.Operator]: (expr, mapping) => this.evalOperator(expr, mapping),
            [E.ExpressionType.SpecialOperator]: (expr, mapping) => this.evalSpecialOperator(expr, mapping),
            [E.ExpressionType.Named]: (expr, mapping) => this.evalNamed(expr, mapping),
            [E.ExpressionType.Existence]: (expr, mapping) => this.evalExistence(expr, mapping),
            [E.ExpressionType.Aggregate]: (expr, _mapping) => this.evalAggregate(expr),
            [E.ExpressionType.SyncExtension]: (expr, mapping) => this.evalSyncExtension(expr, mapping),
        };
    }
    evaluate(expr, mapping) {
        const evaluator = this.subEvaluators[expr.expressionType];
        if (!evaluator) {
            throw new Err.InvalidExpressionType(expr);
        }
        return evaluator.bind(this)(expr, mapping);
    }
    evalOperator(expr, mapping) {
        const args = expr.args.map(arg => this.evaluate(arg, mapping));
        return expr.apply(args);
    }
    evalSpecialOperator(expr, mapping) {
        const evaluate = this.evaluate.bind(this);
        const context = {
            args: expr.args,
            mapping,
            superTypeProvider: this.context.superTypeProvider,
            now: this.context.now,
            baseIRI: this.context.baseIRI,
            functionArgumentsCache: this.context.functionArgumentsCache,
            evaluate,
            bnode: this.context.bnode,
            defaultTimeZone: this.context.defaultTimeZone,
        };
        return expr.applySynchronously(context);
    }
    evalNamed(expr, mapping) {
        const args = expr.args.map(arg => this.evaluate(arg, mapping));
        return expr.apply(args);
    }
    evalSyncExtension(expr, mapping) {
        const args = expr.args.map(arg => this.evaluate(arg, mapping));
        return expr.apply(args);
    }
    evalExistence(expr, mapping) {
        if (!this.context.exists) {
            throw new Err.NoExistenceHook();
        }
        return new E.BooleanLiteral(this.context.exists(expr.expression, mapping));
    }
    evalAggregate(expr) {
        if (!this.context.aggregate) {
            throw new Err.NoAggregator();
        }
        return this.termTransformer.transformRDFTermUnsafe(this.context.aggregate(expr.expression));
    }
}
exports.SyncRecursiveEvaluator = SyncRecursiveEvaluator;
//# sourceMappingURL=SyncRecursiveEvaluator.js.map