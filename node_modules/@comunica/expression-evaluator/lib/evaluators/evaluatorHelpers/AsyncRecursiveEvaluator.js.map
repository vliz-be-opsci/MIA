{"version":3,"file":"AsyncRecursiveEvaluator.js","sourceRoot":"","sources":["AsyncRecursiveEvaluator.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport type { Algebra as Alg } from 'sparqlalgebrajs';\nimport * as E from '../../expressions';\nimport type { AsyncExtension } from '../../expressions';\nimport type { EvalContextAsync } from '../../functions';\nimport type { ITermTransformer } from '../../transformers/TermTransformer';\nimport { TermTransformer } from '../../transformers/TermTransformer';\nimport type { IExpressionEvaluator } from '../../Types';\nimport * as Err from '../../util/Errors';\nimport type { ISuperTypeProvider } from '../../util/TypeHandling';\nimport type { AsyncExtensionFunctionCreator } from '../AsyncEvaluator';\nimport { BaseExpressionEvaluator } from './BaseExpressionEvaluator';\nimport type { ICompleteSharedContext } from './BaseExpressionEvaluator';\n\nexport interface ICompleteAsyncEvaluatorContext extends ICompleteSharedContext {\n  exists?: (expression: Alg.ExistenceExpression, mapping: RDF.Bindings) => Promise<boolean>;\n  aggregate?: (expression: Alg.AggregateExpression) => Promise<RDF.Term>;\n  bnode?: (input?: string) => Promise<RDF.BlankNode>;\n  extensionFunctionCreator?: AsyncExtensionFunctionCreator;\n}\n\nexport class AsyncRecursiveEvaluator extends BaseExpressionEvaluator\n  implements IExpressionEvaluator<E.Expression, Promise<E.Term>> {\n  protected openWorldType: ISuperTypeProvider;\n  private readonly subEvaluators: Record<string, (expr: E.Expression, mapping: RDF.Bindings) =>\n  Promise<E.Term> | E.Term> = {\n    // Shared\n      [E.ExpressionType.Term]: (expr, _mapping) => this.term(<E.Term> expr),\n      [E.ExpressionType.Variable]: (expr, mapping) => this.variable(<E.Variable> expr, mapping),\n\n      // Sync\n      [E.ExpressionType.Operator]: (expr, mapping) => this.evalOperator(<E.Operator> expr, mapping),\n      [E.ExpressionType.SpecialOperator]: (expr, mapping) => this\n        .evalSpecialOperator(<E.SpecialOperator> expr, mapping),\n      [E.ExpressionType.Named]: (expr, mapping) => this.evalNamed(<E.Named> expr, mapping),\n      [E.ExpressionType.Existence]: (expr, mapping) => this.evalExistence(<E.Existence> expr, mapping),\n      [E.ExpressionType.Aggregate]: (expr, _mapping) => this.evalAggregate(<E.Aggregate> expr),\n      [E.ExpressionType.AsyncExtension]: (expr, mapping) => this.evalAsyncExtension(<E.AsyncExtension> expr, mapping),\n    };\n\n  public constructor(private readonly context: ICompleteAsyncEvaluatorContext, termTransformer?: ITermTransformer) {\n    super(termTransformer ?? new TermTransformer(context.superTypeProvider));\n  }\n\n  public async evaluate(expr: E.Expression, mapping: RDF.Bindings): Promise<E.Term> {\n    const evaluator = this.subEvaluators[expr.expressionType];\n    if (!evaluator) {\n      throw new Err.InvalidExpressionType(expr);\n    }\n    return evaluator.bind(this)(expr, mapping);\n  }\n\n  private async evalOperator(expr: E.Operator, mapping: RDF.Bindings): Promise<E.Term> {\n    const argPromises = expr.args.map(arg => this.evaluate(arg, mapping));\n    const argResults = await Promise.all(argPromises);\n    return expr.apply(argResults);\n  }\n\n  private async evalSpecialOperator(expr: E.SpecialOperator, mapping: RDF.Bindings): Promise<E.Term> {\n    const evaluate = this.evaluate.bind(this);\n    const context: EvalContextAsync = {\n      args: expr.args,\n      mapping,\n\n      superTypeProvider: this.context.superTypeProvider,\n      now: this.context.now,\n      baseIRI: this.context.baseIRI,\n      functionArgumentsCache: this.context.functionArgumentsCache,\n\n      evaluate,\n      bnode: this.context.bnode,\n      defaultTimeZone: this.context.defaultTimeZone,\n    };\n    return expr.applyAsync(context);\n  }\n\n  private async _evalAsyncArgs(args: E.Expression[], mapping: RDF.Bindings): Promise<E.TermExpression[]> {\n    const argPromises = args.map(arg => this.evaluate(arg, mapping));\n    return await Promise.all(argPromises);\n  }\n\n  private async evalNamed(expr: E.Named, mapping: RDF.Bindings): Promise<E.Term> {\n    return expr.apply(await this._evalAsyncArgs(expr.args, mapping));\n  }\n\n  private async evalAsyncExtension(expr: AsyncExtension, mapping: RDF.Bindings): Promise<E.Term> {\n    return await expr.apply(await this._evalAsyncArgs(expr.args, mapping));\n  }\n\n  private async evalExistence(expr: E.Existence, mapping: RDF.Bindings): Promise<E.Term> {\n    if (!this.context.exists) {\n      throw new Err.NoExistenceHook();\n    }\n\n    return new E.BooleanLiteral(await this.context.exists(expr.expression, mapping));\n  }\n\n  // TODO: Remove?\n  private async evalAggregate(expr: E.Aggregate): Promise<E.Term> {\n    if (!this.context.aggregate) {\n      throw new Err.NoAggregator();\n    }\n\n    return this.termTransformer.transformRDFTermUnsafe(await this.context.aggregate(expr.expression));\n  }\n}\n"]}