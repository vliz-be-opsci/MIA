{"version":3,"file":"SyncRecursiveEvaluator.js","sourceRoot":"","sources":["SyncRecursiveEvaluator.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport type { Algebra as Alg } from 'sparqlalgebrajs';\nimport * as E from '../../expressions';\nimport type { SyncExtension } from '../../expressions';\nimport type { EvalContextSync } from '../../functions';\nimport type { ITermTransformer } from '../../transformers/TermTransformer';\nimport { TermTransformer } from '../../transformers/TermTransformer';\nimport type { IExpressionEvaluator } from '../../Types';\nimport * as Err from '../../util/Errors';\nimport type { ISuperTypeProvider } from '../../util/TypeHandling';\nimport type { SyncExtensionFunctionCreator } from '../SyncEvaluator';\nimport type { ICompleteSharedContext } from './BaseExpressionEvaluator';\nimport { BaseExpressionEvaluator } from './BaseExpressionEvaluator';\n\nexport interface ICompleteSyncEvaluatorContext extends ICompleteSharedContext {\n  exists?: (expression: Alg.ExistenceExpression, mapping: RDF.Bindings) => boolean;\n  aggregate?: (expression: Alg.AggregateExpression) => RDF.Term;\n  bnode?: (input?: string) => RDF.BlankNode;\n  extensionFunctionCreator?: SyncExtensionFunctionCreator;\n}\n\nexport class SyncRecursiveEvaluator extends BaseExpressionEvaluator\n  implements IExpressionEvaluator<E.Expression, E.Term> {\n  protected openWorldType: ISuperTypeProvider;\n  private readonly subEvaluators: Record<string, (expr: E.Expression, mapping: RDF.Bindings) => E.Term> = {\n    // Shared\n    [E.ExpressionType.Term]: (expr, _mapping) => this.term(<E.Term> expr),\n    [E.ExpressionType.Variable]: (expr, mapping) => this.variable(<E.Variable> expr, mapping),\n\n    // Sync\n    [E.ExpressionType.Operator]: (expr, mapping) => this.evalOperator(<E.Operator> expr, mapping),\n    [E.ExpressionType.SpecialOperator]: (expr, mapping) => this.evalSpecialOperator(<E.SpecialOperator> expr, mapping),\n    [E.ExpressionType.Named]: (expr, mapping) => this.evalNamed(<E.Named> expr, mapping),\n    [E.ExpressionType.Existence]: (expr, mapping) => this.evalExistence(<E.Existence> expr, mapping),\n    [E.ExpressionType.Aggregate]: (expr, _mapping) => this.evalAggregate(<E.Aggregate> expr),\n    [E.ExpressionType.SyncExtension]: (expr, mapping) => this.evalSyncExtension(<E.SyncExtension> expr, mapping),\n  };\n\n  public constructor(private readonly context: ICompleteSyncEvaluatorContext, termTransformer?: ITermTransformer) {\n    super(termTransformer ?? new TermTransformer(context.superTypeProvider));\n  }\n\n  public evaluate(expr: E.Expression, mapping: RDF.Bindings): E.Term {\n    const evaluator = this.subEvaluators[expr.expressionType];\n    if (!evaluator) {\n      throw new Err.InvalidExpressionType(expr);\n    }\n    return evaluator.bind(this)(expr, mapping);\n  }\n\n  private evalOperator(expr: E.Operator, mapping: RDF.Bindings): E.Term {\n    const args = expr.args.map(arg => this.evaluate(arg, mapping));\n    return expr.apply(args);\n  }\n\n  private evalSpecialOperator(expr: E.SpecialOperator, mapping: RDF.Bindings): E.Term {\n    const evaluate = this.evaluate.bind(this);\n    const context: EvalContextSync = {\n      args: expr.args,\n      mapping,\n\n      superTypeProvider: this.context.superTypeProvider,\n      now: this.context.now,\n      baseIRI: this.context.baseIRI,\n      functionArgumentsCache: this.context.functionArgumentsCache,\n\n      evaluate,\n      bnode: this.context.bnode,\n      defaultTimeZone: this.context.defaultTimeZone,\n    };\n    return expr.applySynchronously(context);\n  }\n\n  private evalNamed(expr: E.Named, mapping: RDF.Bindings): E.Term {\n    const args = expr.args.map(arg => this.evaluate(arg, mapping));\n    return expr.apply(args);\n  }\n\n  private evalSyncExtension(expr: SyncExtension, mapping: RDF.Bindings): E.Term {\n    const args = expr.args.map(arg => this.evaluate(arg, mapping));\n    return expr.apply(args);\n  }\n\n  private evalExistence(expr: E.Existence, mapping: RDF.Bindings): E.Term {\n    if (!this.context.exists) {\n      throw new Err.NoExistenceHook();\n    }\n\n    return new E.BooleanLiteral(this.context.exists(expr.expression, mapping));\n  }\n\n  private evalAggregate(expr: E.Aggregate): E.Term {\n    if (!this.context.aggregate) {\n      throw new Err.NoAggregator();\n    }\n\n    return this.termTransformer.transformRDFTermUnsafe(this.context.aggregate(expr.expression));\n  }\n}\n"]}