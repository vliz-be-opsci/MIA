"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AsyncEvaluator = void 0;
const lru_cache_1 = require("lru-cache");
const AlgebraTransformer_1 = require("../transformers/AlgebraTransformer");
const DateTimeHelpers_1 = require("../util/DateTimeHelpers");
const AsyncRecursiveEvaluator_1 = require("./evaluatorHelpers/AsyncRecursiveEvaluator");
class AsyncEvaluator {
    static completeContext(context) {
        const now = context.now ?? new Date(Date.now());
        return {
            now,
            baseIRI: context.baseIRI ?? undefined,
            functionArgumentsCache: context.functionArgumentsCache ?? {},
            superTypeProvider: {
                cache: context.typeCache ?? new lru_cache_1.LRUCache({ max: 1_000 }),
                discoverer: context.getSuperType ?? (() => 'term'),
            },
            extensionFunctionCreator: context.extensionFunctionCreator,
            exists: context.exists,
            aggregate: context.aggregate,
            bnode: context.bnode,
            defaultTimeZone: context.defaultTimeZone ?? (0, DateTimeHelpers_1.extractTimeZone)(now),
        };
    }
    constructor(algExpr, context = {}) {
        this.algExpr = algExpr;
        // eslint-disable-next-line unicorn/no-useless-undefined
        const creator = context.extensionFunctionCreator ?? (() => undefined);
        const baseContext = AsyncEvaluator.completeContext(context);
        const transformer = new AlgebraTransformer_1.AlgebraTransformer({
            type: 'async',
            creator,
            ...baseContext,
        });
        this.expr = transformer.transformAlgebra(algExpr);
        this.evaluator = new AsyncRecursiveEvaluator_1.AsyncRecursiveEvaluator(baseContext, transformer);
    }
    async evaluate(mapping) {
        const result = await this.evaluator.evaluate(this.expr, mapping);
        return result.toRDF();
    }
    async evaluateAsEBV(mapping) {
        const result = await this.evaluator.evaluate(this.expr, mapping);
        return result.coerceEBV();
    }
    async evaluateAsInternal(mapping) {
        return await this.evaluator.evaluate(this.expr, mapping);
    }
}
exports.AsyncEvaluator = AsyncEvaluator;
//# sourceMappingURL=AsyncEvaluator.js.map