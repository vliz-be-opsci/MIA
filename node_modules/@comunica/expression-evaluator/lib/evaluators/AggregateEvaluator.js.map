{"version":3,"file":"AggregateEvaluator.js","sourceRoot":"","sources":["AggregateEvaluator.ts"],"names":[],"mappings":";;;AAEA,sFAAmF;AAEnF,mDAAgD;AAEhD,8DAA8D;AAC9D,MAAa,kBAAmB,SAAQ,+CAAsB;IAG5D,YAAmB,IAAiC,EAAE,OAA+B,EAAE,UAAoB;QACzG,KAAK,CAAC,IAAI,EAAE,6BAAa,CAAC,eAAe,CAAC,OAAO,IAAI,EAAE,CAAC,EAAE,UAAU,CAAC,CAAC;QACtE,IAAI,CAAC,SAAS,GAAG,IAAI,6BAAa,CAAC,IAAI,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;IAC/D,CAAC;IAEM,GAAG,CAAC,QAAsB;QAC/B,IAAI,IAAI,CAAC,aAAa,EAAE,CAAC;YACvB,OAAO;QACT,CAAC;QACD,IAAI,IAAI,CAAC,UAAU,EAAE,CAAC;YACpB,IAAI,CAAC,kBAAmB,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;QACjD,CAAC;aAAM,CAAC;YACN,IAAI,CAAC;gBACH,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;gBACpD,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;YACjC,CAAC;YAAC,OAAO,KAAc,EAAE,CAAC;gBACxB,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;YACxB,CAAC;QACH,CAAC;IACH,CAAC;IAES,SAAS,CAAC,GAAY;QAC9B,IAAI,IAAI,CAAC,UAAU,EAAE,CAAC;YACpB,MAAM,GAAG,CAAC;QACZ,CAAC;aAAM,CAAC;YACN,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;QAC5B,CAAC;IACH,CAAC;CACF;AA/BD,gDA+BC","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport type { Algebra } from 'sparqlalgebrajs';\nimport { BaseAggregateEvaluator } from './evaluatorHelpers/BaseAggregateEvaluator';\nimport type { ISyncEvaluatorContext } from './SyncEvaluator';\nimport { SyncEvaluator } from './SyncEvaluator';\n\n// TODO: Support hooks & change name to SyncAggregateEvaluator\nexport class AggregateEvaluator extends BaseAggregateEvaluator {\n  private readonly evaluator: SyncEvaluator;\n\n  public constructor(expr: Algebra.AggregateExpression, context?: ISyncEvaluatorContext, throwError?: boolean) {\n    super(expr, SyncEvaluator.completeContext(context ?? {}), throwError);\n    this.evaluator = new SyncEvaluator(expr.expression, context);\n  }\n\n  public put(bindings: RDF.Bindings): void {\n    if (this.errorOccurred) {\n      return;\n    }\n    if (this.isWildcard) {\n      this.wildcardAggregator!.putBindings(bindings);\n    } else {\n      try {\n        const startTerm = this.evaluator.evaluate(bindings);\n        this.aggregator.put(startTerm);\n      } catch (error: unknown) {\n        this.safeThrow(error);\n      }\n    }\n  }\n\n  protected safeThrow(err: unknown): void {\n    if (this.throwError) {\n      throw err;\n    } else {\n      this.errorOccurred = true;\n    }\n  }\n}\n"]}