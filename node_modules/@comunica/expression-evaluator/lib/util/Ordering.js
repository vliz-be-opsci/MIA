"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.orderTypes = void 0;
const lru_cache_1 = require("lru-cache");
const functions_1 = require("../functions");
const TermTransformer_1 = require("../transformers/TermTransformer");
const C = require("./Consts");
const Err = require("./Errors");
// Determine the relative numerical order of the two given terms.
// In accordance with https://www.w3.org/TR/sparql11-query/#modOrderBy
function orderTypes(termA, termB, strict = false, typeDiscoveryCallback, typeCache) {
    // Check if terms are the same by reference
    if (termA === termB) {
        return 0;
    }
    // We handle undefined that is lower than everything else.
    if (termA === undefined) {
        return -1;
    }
    if (termB === undefined) {
        return 1;
    }
    //
    if (termA.termType !== termB.termType) {
        return _TERM_ORDERING_PRIORITY[termA.termType] < _TERM_ORDERING_PRIORITY[termB.termType] ? -1 : 1;
    }
    // Check exact term equality
    if (termA.equals(termB)) {
        return 0;
    }
    // Handle quoted triples
    if (termA.termType === 'Quad' && termB.termType === 'Quad') {
        const orderSubject = orderTypes(termA.subject, termB.subject, strict, typeDiscoveryCallback, typeCache);
        if (orderSubject !== 0) {
            return orderSubject;
        }
        const orderPredicate = orderTypes(termA.predicate, termB.predicate, strict, typeDiscoveryCallback, typeCache);
        if (orderPredicate !== 0) {
            return orderPredicate;
        }
        const orderObject = orderTypes(termA.object, termB.object, strict, typeDiscoveryCallback, typeCache);
        if (orderObject !== 0) {
            return orderObject;
        }
        return orderTypes(termA.graph, termB.graph, strict, typeDiscoveryCallback, typeCache);
    }
    // Handle literals
    if (termA.termType === 'Literal') {
        return orderLiteralTypes(termA, termB, typeDiscoveryCallback, typeCache);
    }
    // Handle all other types
    if (strict) {
        throw new Err.InvalidCompareArgumentTypes(termA, termB);
    }
    return comparePrimitives(termA.value, termB.value);
}
exports.orderTypes = orderTypes;
function orderLiteralTypes(litA, litB, typeDiscoveryCallback, typeCache) {
    const isGreater = functions_1.regularFunctions[C.RegularOperator.GT];
    const isEqual = functions_1.regularFunctions[C.RegularOperator.EQUAL];
    const context = {
        now: new Date(),
        functionArgumentsCache: {},
        superTypeProvider: {
            discoverer: typeDiscoveryCallback ?? (() => 'term'),
            cache: typeCache ?? new lru_cache_1.LRUCache({ max: 1_000 }),
        },
        defaultTimeZone: { zoneHours: 0, zoneMinutes: 0 },
    };
    const termTransformer = new TermTransformer_1.TermTransformer(context.superTypeProvider);
    const myLitA = termTransformer.transformLiteral(litA);
    const myLitB = termTransformer.transformLiteral(litB);
    try {
        if (isEqual.apply([myLitA, myLitB], context).typedValue) {
            return 0;
        }
        if (isGreater.apply([myLitA, myLitB], context).typedValue) {
            return 1;
        }
        return -1;
    }
    catch {
        // Fallback to string-based comparison
        const compareType = comparePrimitives(myLitA.dataType, myLitB.dataType);
        if (compareType !== 0) {
            return compareType;
        }
        return comparePrimitives(myLitA.str(), myLitB.str());
    }
}
function comparePrimitives(valueA, valueB) {
    return valueA === valueB ? 0 : (valueA < valueB ? -1 : 1);
}
// SPARQL specifies that blankNode < namedNode < literal.
const _TERM_ORDERING_PRIORITY = {
    Variable: 0,
    BlankNode: 1,
    NamedNode: 2,
    Literal: 3,
    Quad: 4,
    DefaultGraph: 5,
};
//# sourceMappingURL=Ordering.js.map