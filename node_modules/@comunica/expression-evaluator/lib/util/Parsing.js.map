{"version":3,"file":"Parsing.js","sourceRoot":"","sources":["Parsing.ts"],"names":[],"mappings":"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","sourcesContent":["// TODO: Find a library for this, because this is basically an xsd datatypes parser\n\nimport type {\n  IDateRepresentation,\n  IDateTimeRepresentation,\n  IDayTimeDurationRepresentation,\n  IDurationRepresentation,\n  ITimeRepresentation,\n  ITimeZoneRepresentation,\n  IYearMonthDurationRepresentation,\n} from './DateTimeHelpers';\n\nimport { simplifyDurationRepresentation } from './DateTimeHelpers';\nimport { ParseError } from './Errors';\nimport { maximumDayInMonthFor } from './SpecAlgos';\n\n/**\n * TODO: Fix decently\n * Parses float datatypes (double, float).\n *\n * All invalid lexical values return undefined.\n *\n * @param value the string to interpret as a number\n */\nexport function parseXSDFloat(value: string): number | undefined {\n  const numb = Number(value);\n  if (Number.isNaN(numb)) {\n    if (value === 'NaN') {\n      return Number.NaN;\n    }\n    if (value === 'INF' || value === '+INF') {\n      return Number.POSITIVE_INFINITY;\n    }\n    if (value === '-INF') {\n      return Number.NEGATIVE_INFINITY;\n    }\n    return undefined;\n  }\n  return numb;\n}\n\n/**\n * Parses decimal datatypes (decimal, int, byte, nonPositiveInteger, etc...).\n *\n * All other values, including NaN, INF, and floating point numbers all\n * return undefined;\n *\n * @param value the string to interpret as a number\n */\nexport function parseXSDDecimal(value: string): number | undefined {\n  const numb = Number(value);\n  return Number.isNaN(numb) ? undefined : numb;\n}\n\n/**\n * Parses integer datatypes (decimal, int, byte, nonPositiveInteger, etc...).\n *\n * All other values, including NaN, INF, and floating point numbers all\n * return undefined;\n *\n * @param value the string to interpret as a number\n */\nexport function parseXSDInteger(value: string): number | undefined {\n  const numb: number = Number.parseInt(value, 10);\n  return Number.isNaN(numb) ? undefined : numb;\n}\n\nexport function parseDateTime(dateTimeStr: string): IDateTimeRepresentation {\n  // https://www.w3.org/TR/xmlschema-2/#dateTime\n  const [ date, time ] = dateTimeStr.split('T');\n  return { ...parseDate(date), ...__parseTime(time) };\n}\n\nfunction parseTimeZone(timeZoneStr: string): Partial<ITimeZoneRepresentation> {\n  // https://www.w3.org/TR/xmlschema-2/#dateTime-timezones\n  if (timeZoneStr === '') {\n    return { zoneHours: undefined, zoneMinutes: undefined };\n  }\n  if (timeZoneStr === 'Z') {\n    return { zoneHours: 0, zoneMinutes: 0 };\n  }\n  const timeZoneStrings = timeZoneStr.replaceAll(/^([+|-])(\\d\\d):(\\d\\d)$/gu, '$11!$2!$3').split('!');\n  const timeZone = timeZoneStrings.map(Number);\n  return {\n    zoneHours: timeZone[0] * timeZone[1],\n    zoneMinutes: timeZone[0] * timeZone[2],\n  };\n}\n\nexport function parseDate(dateStr: string): IDateRepresentation {\n  // https://www.w3.org/TR/xmlschema-2/#date-lexical-representation\n  const formatted = dateStr.replaceAll(\n    /^(-)?([123456789]*\\d{4})-(\\d\\d)-(\\d\\d)(Z|([+-]\\d\\d:\\d\\d))?$/gu,\n    '$11!$2!$3!$4!$5',\n  );\n  if (formatted === dateStr) {\n    throw new ParseError(dateStr, 'date');\n  }\n  const dateStrings = formatted.split('!');\n  const date = dateStrings.slice(0, -1).map(Number);\n\n  const res = {\n    year: date[0] * date[1],\n    month: date[2],\n    day: date[3],\n    ...parseTimeZone(dateStrings[4]),\n  };\n  if (!(res.month >= 1 && res.month <= 12) || !(res.day >= 1 && res.day <= maximumDayInMonthFor(res.year, res.month))) {\n    throw new ParseError(dateStr, 'date');\n  }\n  return res;\n}\n\nfunction __parseTime(timeStr: string): ITimeRepresentation {\n  // https://www.w3.org/TR/xmlschema-2/#time-lexical-repr\n  const formatted = timeStr.replaceAll(/^(\\d\\d):(\\d\\d):(\\d\\d(\\.\\d+)?)(Z|([+-]\\d\\d:\\d\\d))?$/gu, '$1!$2!$3!$5');\n  if (formatted === timeStr) {\n    throw new ParseError(timeStr, 'time');\n  }\n  const timeStrings = formatted.split('!');\n  const time = timeStrings.slice(0, -1).map(Number);\n\n  const res = {\n    hours: time[0],\n    minutes: time[1],\n    seconds: time[2],\n    ...parseTimeZone(timeStrings[3]),\n  };\n\n  if (res.seconds >= 60 || res.minutes >= 60 || res.hours > 24 ||\n    (res.hours === 24 && (res.minutes !== 0 || res.seconds !== 0))) {\n    throw new ParseError(timeStr, 'time');\n  }\n  return res;\n}\n\n// We make a separation in internal and external since dateTime will have hour-date rollover,\n// but time just does modulo the time.\nexport function parseTime(timeStr: string): ITimeRepresentation {\n  // https://www.w3.org/TR/xmlschema-2/#time-lexical-repr\n  const res = __parseTime(timeStr);\n  res.hours %= 24;\n  return res;\n}\n\nexport function parseDuration(durationStr: string): Partial<IDurationRepresentation> {\n  // https://www.w3.org/TR/xmlschema-2/#duration-lexical-repr\n  const [ dayNotation, timeNotation ] = durationStr.split('T');\n\n  // Handle date part\n  const formattedDayDur = dayNotation.replaceAll(/^(-)?P(\\d+Y)?(\\d+M)?(\\d+D)?$/gu, '$11S!$2!$3!$4');\n  if (formattedDayDur === dayNotation) {\n    throw new ParseError(durationStr, 'duration');\n  }\n\n  const durationStrings = formattedDayDur.split('!');\n  if (timeNotation !== undefined) {\n    const formattedTimeDur = timeNotation.replaceAll(/^(\\d+H)?(\\d+M)?(\\d+(\\.\\d+)?S)?$/gu, '$1!$2!$3');\n\n    if (timeNotation === '' || timeNotation === formattedTimeDur) {\n      throw new ParseError(durationStr, 'duration');\n    }\n    durationStrings.push(...formattedTimeDur.split('!'));\n  }\n  const duration = durationStrings.map(str => str.slice(0, -1));\n  if (!duration.slice(1).some(Boolean)) {\n    throw new ParseError(durationStr, 'duration');\n  }\n\n  const sign = <-1 | 1> Number(duration[0]);\n  return simplifyDurationRepresentation({\n    year: duration[1] ? sign * Number(duration[1]) : undefined,\n    month: duration[2] ? sign * Number(duration[2]) : undefined,\n    day: duration[3] ? sign * Number(duration[3]) : undefined,\n    hours: duration[4] ? sign * Number(duration[4]) : undefined,\n    minutes: duration[5] ? sign * Number(duration[5]) : undefined,\n    seconds: duration[6] ? sign * Number(duration[6]) : undefined,\n  });\n}\n\nexport function parseYearMonthDuration(durationStr: string): Partial<IYearMonthDurationRepresentation> {\n  const res = parseDuration(durationStr);\n  if ([ 'hours', 'minutes', 'seconds', 'day' ].some(key => Boolean((<any> res)[key]))) {\n    throw new ParseError(durationStr, 'yearMonthDuration');\n  }\n  return res;\n}\n\nexport function parseDayTimeDuration(durationStr: string): Partial<IDayTimeDurationRepresentation> {\n  const res = parseDuration(durationStr);\n  if ([ 'year', 'month' ].some(key => Boolean((<any> res)[key]))) {\n    throw new ParseError(durationStr, 'dayTimeDuration');\n  }\n  return res;\n}\n"]}