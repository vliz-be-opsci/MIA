{"version":3,"file":"Ordering.js","sourceRoot":"","sources":["Ordering.ts"],"names":[],"mappings":";;;AACA,yCAAqC;AAErC,4CAAgD;AAChD,qEAAkE;AAClE,8BAA8B;AAC9B,gCAAgC;AAGhC,iEAAiE;AACjE,sEAAsE;AACtE,SAAgB,UAAU,CACxB,KAA2B,EAC3B,KAA2B,EAC3B,MAAM,GAAG,KAAK,EACd,qBAAyC,EACzC,SAAqB;IAErB,2CAA2C;IAC3C,IAAI,KAAK,KAAK,KAAK,EAAE,CAAC;QACpB,OAAO,CAAC,CAAC;IACX,CAAC;IAED,0DAA0D;IAC1D,IAAI,KAAK,KAAK,SAAS,EAAE,CAAC;QACxB,OAAO,CAAC,CAAC,CAAC;IACZ,CAAC;IACD,IAAI,KAAK,KAAK,SAAS,EAAE,CAAC;QACxB,OAAO,CAAC,CAAC;IACX,CAAC;IAED,EAAE;IACF,IAAI,KAAK,CAAC,QAAQ,KAAK,KAAK,CAAC,QAAQ,EAAE,CAAC;QACtC,OAAO,uBAAuB,CAAC,KAAK,CAAC,QAAQ,CAAC,GAAG,uBAAuB,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACpG,CAAC;IAED,4BAA4B;IAC5B,IAAI,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC;QACxB,OAAO,CAAC,CAAC;IACX,CAAC;IAED,wBAAwB;IACxB,IAAI,KAAK,CAAC,QAAQ,KAAK,MAAM,IAAI,KAAK,CAAC,QAAQ,KAAK,MAAM,EAAE,CAAC;QAC3D,MAAM,YAAY,GAAG,UAAU,CAC7B,KAAK,CAAC,OAAO,EACb,KAAK,CAAC,OAAO,EACb,MAAM,EACN,qBAAqB,EACrB,SAAS,CACV,CAAC;QACF,IAAI,YAAY,KAAK,CAAC,EAAE,CAAC;YACvB,OAAO,YAAY,CAAC;QACtB,CAAC;QACD,MAAM,cAAc,GAAG,UAAU,CAC/B,KAAK,CAAC,SAAS,EACf,KAAK,CAAC,SAAS,EACf,MAAM,EACN,qBAAqB,EACrB,SAAS,CACV,CAAC;QACF,IAAI,cAAc,KAAK,CAAC,EAAE,CAAC;YACzB,OAAO,cAAc,CAAC;QACxB,CAAC;QACD,MAAM,WAAW,GAAG,UAAU,CAC5B,KAAK,CAAC,MAAM,EACZ,KAAK,CAAC,MAAM,EACZ,MAAM,EACN,qBAAqB,EACrB,SAAS,CACV,CAAC;QACF,IAAI,WAAW,KAAK,CAAC,EAAE,CAAC;YACtB,OAAO,WAAW,CAAC;QACrB,CAAC;QACD,OAAO,UAAU,CACf,KAAK,CAAC,KAAK,EACX,KAAK,CAAC,KAAK,EACX,MAAM,EACN,qBAAqB,EACrB,SAAS,CACV,CAAC;IACJ,CAAC;IAED,kBAAkB;IAClB,IAAI,KAAK,CAAC,QAAQ,KAAK,SAAS,EAAE,CAAC;QACjC,OAAO,iBAAiB,CAAC,KAAK,EAAe,KAAK,EAAE,qBAAqB,EAAE,SAAS,CAAC,CAAC;IACxF,CAAC;IAED,yBAAyB;IACzB,IAAI,MAAM,EAAE,CAAC;QACX,MAAM,IAAI,GAAG,CAAC,2BAA2B,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;IAC1D,CAAC;IACD,OAAO,iBAAiB,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,KAAK,CAAC,CAAC;AACrD,CAAC;AAjFD,gCAiFC;AAED,SAAS,iBAAiB,CACxB,IAAiB,EACjB,IAAiB,EACjB,qBAAyC,EACzC,SAAqB;IAErB,MAAM,SAAS,GAAG,4BAAgB,CAAC,CAAC,CAAC,eAAe,CAAC,EAAE,CAAC,CAAC;IACzD,MAAM,OAAO,GAAG,4BAAgB,CAAC,CAAC,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC;IAC1D,MAAM,OAAO,GAAG;QACd,GAAG,EAAE,IAAI,IAAI,EAAE;QACf,sBAAsB,EAAE,EAAE;QAC1B,iBAAiB,EAAE;YACjB,UAAU,EAAE,qBAAqB,IAAI,CAAC,GAAG,EAAE,CAAC,MAAM,CAAC;YACnD,KAAK,EAAE,SAAS,IAAI,IAAI,oBAAQ,CAAC,EAAE,GAAG,EAAE,KAAK,EAAE,CAAC;SACjD;QACD,eAAe,EAAE,EAAE,SAAS,EAAE,CAAC,EAAE,WAAW,EAAE,CAAC,EAAE;KAClD,CAAC;IAEF,MAAM,eAAe,GAAG,IAAI,iCAAe,CAAC,OAAO,CAAC,iBAAiB,CAAC,CAAC;IACvE,MAAM,MAAM,GAAG,eAAe,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;IACtD,MAAM,MAAM,GAAG,eAAe,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC;IAEtD,IAAI,CAAC;QACH,IAAwB,OAAO,CAAC,KAAK,CAAC,CAAE,MAAM,EAAE,MAAM,CAAE,EAAE,OAAO,CAAE,CAAC,UAAU,EAAE,CAAC;YAC/E,OAAO,CAAC,CAAC;QACX,CAAC;QACD,IAAwB,SAAS,CAAC,KAAK,CAAC,CAAE,MAAM,EAAE,MAAM,CAAE,EAAE,OAAO,CAAE,CAAC,UAAU,EAAE,CAAC;YACjF,OAAO,CAAC,CAAC;QACX,CAAC;QACD,OAAO,CAAC,CAAC,CAAC;IACZ,CAAC;IAAC,MAAM,CAAC;QACP,sCAAsC;QACtC,MAAM,WAAW,GAAG,iBAAiB,CAAC,MAAM,CAAC,QAAQ,EAAE,MAAM,CAAC,QAAQ,CAAC,CAAC;QACxE,IAAI,WAAW,KAAK,CAAC,EAAE,CAAC;YACtB,OAAO,WAAW,CAAC;QACrB,CAAC;QACD,OAAO,iBAAiB,CAAC,MAAM,CAAC,GAAG,EAAE,EAAE,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC;IACvD,CAAC;AACH,CAAC;AAED,SAAS,iBAAiB,CAAC,MAAW,EAAE,MAAW;IACjD,OAAO,MAAM,KAAK,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC5D,CAAC;AAED,yDAAyD;AACzD,MAAM,uBAAuB,GAAG;IAC9B,QAAQ,EAAE,CAAC;IACX,SAAS,EAAE,CAAC;IACZ,SAAS,EAAE,CAAC;IACZ,OAAO,EAAE,CAAC;IACV,IAAI,EAAE,CAAC;IACP,YAAY,EAAE,CAAC;CAChB,CAAC","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport { LRUCache } from 'lru-cache';\nimport type * as E from '../expressions';\nimport { regularFunctions } from '../functions';\nimport { TermTransformer } from '../transformers/TermTransformer';\nimport * as C from './Consts';\nimport * as Err from './Errors';\nimport type { SuperTypeCallback, TypeCache } from './TypeHandling';\n\n// Determine the relative numerical order of the two given terms.\n// In accordance with https://www.w3.org/TR/sparql11-query/#modOrderBy\nexport function orderTypes(\n  termA: RDF.Term | undefined,\n  termB: RDF.Term | undefined,\n  strict = false,\n  typeDiscoveryCallback?: SuperTypeCallback,\n  typeCache?: TypeCache,\n): -1 | 0 | 1 {\n  // Check if terms are the same by reference\n  if (termA === termB) {\n    return 0;\n  }\n\n  // We handle undefined that is lower than everything else.\n  if (termA === undefined) {\n    return -1;\n  }\n  if (termB === undefined) {\n    return 1;\n  }\n\n  //\n  if (termA.termType !== termB.termType) {\n    return _TERM_ORDERING_PRIORITY[termA.termType] < _TERM_ORDERING_PRIORITY[termB.termType] ? -1 : 1;\n  }\n\n  // Check exact term equality\n  if (termA.equals(termB)) {\n    return 0;\n  }\n\n  // Handle quoted triples\n  if (termA.termType === 'Quad' && termB.termType === 'Quad') {\n    const orderSubject = orderTypes(\n      termA.subject,\n      termB.subject,\n      strict,\n      typeDiscoveryCallback,\n      typeCache,\n    );\n    if (orderSubject !== 0) {\n      return orderSubject;\n    }\n    const orderPredicate = orderTypes(\n      termA.predicate,\n      termB.predicate,\n      strict,\n      typeDiscoveryCallback,\n      typeCache,\n    );\n    if (orderPredicate !== 0) {\n      return orderPredicate;\n    }\n    const orderObject = orderTypes(\n      termA.object,\n      termB.object,\n      strict,\n      typeDiscoveryCallback,\n      typeCache,\n    );\n    if (orderObject !== 0) {\n      return orderObject;\n    }\n    return orderTypes(\n      termA.graph,\n      termB.graph,\n      strict,\n      typeDiscoveryCallback,\n      typeCache,\n    );\n  }\n\n  // Handle literals\n  if (termA.termType === 'Literal') {\n    return orderLiteralTypes(termA, <RDF.Literal>termB, typeDiscoveryCallback, typeCache);\n  }\n\n  // Handle all other types\n  if (strict) {\n    throw new Err.InvalidCompareArgumentTypes(termA, termB);\n  }\n  return comparePrimitives(termA.value, termB.value);\n}\n\nfunction orderLiteralTypes(\n  litA: RDF.Literal,\n  litB: RDF.Literal,\n  typeDiscoveryCallback?: SuperTypeCallback,\n  typeCache?: TypeCache,\n): -1 | 0 | 1 {\n  const isGreater = regularFunctions[C.RegularOperator.GT];\n  const isEqual = regularFunctions[C.RegularOperator.EQUAL];\n  const context = {\n    now: new Date(),\n    functionArgumentsCache: {},\n    superTypeProvider: {\n      discoverer: typeDiscoveryCallback ?? (() => 'term'),\n      cache: typeCache ?? new LRUCache({ max: 1_000 }),\n    },\n    defaultTimeZone: { zoneHours: 0, zoneMinutes: 0 },\n  };\n\n  const termTransformer = new TermTransformer(context.superTypeProvider);\n  const myLitA = termTransformer.transformLiteral(litA);\n  const myLitB = termTransformer.transformLiteral(litB);\n\n  try {\n    if ((<E.BooleanLiteral> isEqual.apply([ myLitA, myLitB ], context)).typedValue) {\n      return 0;\n    }\n    if ((<E.BooleanLiteral> isGreater.apply([ myLitA, myLitB ], context)).typedValue) {\n      return 1;\n    }\n    return -1;\n  } catch {\n    // Fallback to string-based comparison\n    const compareType = comparePrimitives(myLitA.dataType, myLitB.dataType);\n    if (compareType !== 0) {\n      return compareType;\n    }\n    return comparePrimitives(myLitA.str(), myLitB.str());\n  }\n}\n\nfunction comparePrimitives(valueA: any, valueB: any): -1 | 0 | 1 {\n  return valueA === valueB ? 0 : (valueA < valueB ? -1 : 1);\n}\n\n// SPARQL specifies that blankNode < namedNode < literal.\nconst _TERM_ORDERING_PRIORITY = {\n  Variable: 0,\n  BlankNode: 1,\n  NamedNode: 2,\n  Literal: 3,\n  Quad: 4,\n  DefaultGraph: 5,\n};\n"]}