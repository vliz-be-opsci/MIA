{"version":3,"file":"TypeHandling.js","sourceRoot":"","sources":["TypeHandling.ts"],"names":[],"mappings":"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","sourcesContent":["import type { LRUCache } from 'lru-cache';\nimport type * as E from '../expressions';\nimport { asTermType } from '../expressions';\nimport type { ArgumentType } from '../functions';\nimport { double, float, string } from '../functions/Helpers';\nimport type { KnownLiteralTypes } from './Consts';\nimport { TypeAlias, TypeURL } from './Consts';\n\nexport type OverrideType = KnownLiteralTypes | 'term';\n\n/**\n * Types that are not mentioned just map to 'term'.\n * When editing this, make sure type promotion and substitution don't start interfering.\n * e.g. when saying something like string -> stringly -> anyUri -> term.\n * This would make substitution on types that promote to each other possible. We and the specs don't want that!\n * A DAG will be created based on this. Make sure it doesn't have any cycles!\n */\nexport const extensionTableInput: Record<KnownLiteralTypes, OverrideType> = {\n  // Datetime types\n  [TypeURL.XSD_DATE_TIME_STAMP]: TypeURL.XSD_DATE_TIME,\n\n  // Duration types\n  [TypeURL.XSD_DAY_TIME_DURATION]: TypeURL.XSD_DURATION,\n  [TypeURL.XSD_YEAR_MONTH_DURATION]: TypeURL.XSD_DURATION,\n\n  // Stringly types\n  [TypeURL.RDF_LANG_STRING]: TypeAlias.SPARQL_STRINGLY,\n  [TypeURL.XSD_STRING]: TypeAlias.SPARQL_STRINGLY,\n\n  // String types\n  [TypeURL.XSD_NORMALIZED_STRING]: TypeURL.XSD_STRING,\n  [TypeURL.XSD_TOKEN]: TypeURL.XSD_NORMALIZED_STRING,\n  [TypeURL.XSD_LANGUAGE]: TypeURL.XSD_TOKEN,\n  [TypeURL.XSD_NM_TOKEN]: TypeURL.XSD_TOKEN,\n  [TypeURL.XSD_NAME]: TypeURL.XSD_TOKEN,\n  [TypeURL.XSD_NC_NAME]: TypeURL.XSD_NAME,\n  [TypeURL.XSD_ENTITY]: TypeURL.XSD_NC_NAME,\n  [TypeURL.XSD_ID]: TypeURL.XSD_NC_NAME,\n  [TypeURL.XSD_ID_REF]: TypeURL.XSD_NC_NAME,\n\n  // Numeric types\n  // https://www.w3.org/TR/sparql11-query/#operandDataTypes\n  // > numeric denotes typed literals with datatypes xsd:integer, xsd:decimal, xsd:float, and xsd:double\n  [TypeURL.XSD_DOUBLE]: TypeAlias.SPARQL_NUMERIC,\n  [TypeURL.XSD_FLOAT]: TypeAlias.SPARQL_NUMERIC,\n  [TypeURL.XSD_DECIMAL]: TypeAlias.SPARQL_NUMERIC,\n\n  // Decimal types\n  [TypeURL.XSD_INTEGER]: TypeURL.XSD_DECIMAL,\n\n  [TypeURL.XSD_NON_POSITIVE_INTEGER]: TypeURL.XSD_INTEGER,\n  [TypeURL.XSD_NEGATIVE_INTEGER]: TypeURL.XSD_NON_POSITIVE_INTEGER,\n\n  [TypeURL.XSD_LONG]: TypeURL.XSD_INTEGER,\n  [TypeURL.XSD_INT]: TypeURL.XSD_LONG,\n  [TypeURL.XSD_SHORT]: TypeURL.XSD_INT,\n  [TypeURL.XSD_BYTE]: TypeURL.XSD_SHORT,\n\n  [TypeURL.XSD_NON_NEGATIVE_INTEGER]: TypeURL.XSD_INTEGER,\n  [TypeURL.XSD_POSITIVE_INTEGER]: TypeURL.XSD_NON_NEGATIVE_INTEGER,\n  [TypeURL.XSD_UNSIGNED_LONG]: TypeURL.XSD_NON_NEGATIVE_INTEGER,\n  [TypeURL.XSD_UNSIGNED_INT]: TypeURL.XSD_UNSIGNED_LONG,\n  [TypeURL.XSD_UNSIGNED_SHORT]: TypeURL.XSD_UNSIGNED_INT,\n  [TypeURL.XSD_UNSIGNED_BYTE]: TypeURL.XSD_UNSIGNED_SHORT,\n\n  [TypeURL.XSD_DATE_TIME]: 'term',\n  [TypeURL.XSD_BOOLEAN]: 'term',\n  [TypeURL.XSD_DATE]: 'term',\n  [TypeURL.XSD_G_MONTH]: 'term',\n  [TypeURL.XSD_G_MONTHDAY]: 'term',\n  [TypeURL.XSD_G_YEAR]: 'term',\n  [TypeURL.XSD_G_YEAR_MONTH]: 'term',\n  [TypeURL.XSD_TIME]: 'term',\n  [TypeURL.XSD_G_DAY]: 'term',\n  [TypeURL.XSD_DURATION]: 'term',\n  [TypeAlias.SPARQL_NUMERIC]: 'term',\n  [TypeAlias.SPARQL_STRINGLY]: 'term',\n  [TypeURL.XSD_ANY_URI]: 'term',\n};\ntype SuperTypeDict = Record<KnownLiteralTypes, number> & { __depth: number };\ntype SuperTypeDictTable = Record<KnownLiteralTypes, SuperTypeDict>;\n// The key 'term' is not included in these keys. Something that is just a term will map to number 0.\nexport type GeneralSuperTypeDict = Record<string, number> & { __depth: number };\nexport const superTypeDictTable: SuperTypeDictTable = Object.create(null);\n\n/**\n * This will return the super types of a type and cache them.\n * @param type IRI we will decide the super types of.\n * @param openWorldType the enabler that provides a way to find super types.\n */\nexport function getSuperTypes(type: string, openWorldType: ISuperTypeProvider): GeneralSuperTypeDict {\n  const cached = openWorldType.cache.get(type);\n  if (cached) {\n    return cached;\n  }\n  const value = openWorldType.discoverer(type);\n  if (value === 'term') {\n    const res: GeneralSuperTypeDict = Object.create(null);\n    res.__depth = 0;\n    res[type] = 0;\n    openWorldType.cache.set(type, res);\n    return res;\n  }\n  let subExtension: GeneralSuperTypeDict;\n  const knownValue = asKnownLiteralType(value);\n  if (knownValue) {\n    subExtension = { ...superTypeDictTable[knownValue] };\n  } else {\n    subExtension = { ...getSuperTypes(value, openWorldType) };\n  }\n  subExtension.__depth++;\n  subExtension[type] = subExtension.__depth;\n  openWorldType.cache.set(type, subExtension);\n  return subExtension;\n}\n\n// No circular structure allowed! & No other keys allowed!\nexport function extensionTableInit(): void {\n  for (const [ _key, value ] of Object.entries(extensionTableInput)) {\n    const key = <KnownLiteralTypes>_key;\n    if (superTypeDictTable[key]) {\n      continue;\n    }\n    extensionTableBuilderInitKey(key, value, superTypeDictTable);\n  }\n}\nextensionTableInit();\n\nfunction extensionTableBuilderInitKey(key: KnownLiteralTypes, value: OverrideType, res: SuperTypeDictTable): void {\n  if (value === 'term' || value === undefined) {\n    const baseRes: SuperTypeDict = Object.create(null);\n    baseRes.__depth = 0;\n    baseRes[key] = 0;\n    res[key] = baseRes;\n    return;\n  }\n  if (!res[value]) {\n    extensionTableBuilderInitKey(value, extensionTableInput[value], res);\n  }\n  res[key] = { ...res[value], [key]: res[value].__depth + 1, __depth: res[value].__depth + 1 };\n}\n\nexport const typeAliasCheck: Record<TypeAlias, boolean> = Object.create(null);\nfunction initTypeAliasCheck(): void {\n  for (const val of Object.values(TypeAlias)) {\n    typeAliasCheck[val] = true;\n  }\n}\ninitTypeAliasCheck();\n\nexport function asTypeAlias(type: string): TypeAlias | undefined {\n  if (type in typeAliasCheck) {\n    return <TypeAlias> type;\n  }\n  return undefined;\n}\n\nexport function asKnownLiteralType(type: string): KnownLiteralTypes | undefined {\n  if (type in superTypeDictTable) {\n    return <KnownLiteralTypes> type;\n  }\n  return undefined;\n}\n\nexport function asOverrideType(type: string): OverrideType | undefined {\n  if (asKnownLiteralType(type) ?? type === 'term') {\n    return <OverrideType> type;\n  }\n  return undefined;\n}\n\nexport function asGeneralType(type: string): 'term' | E.TermType | undefined {\n  if (type === 'term' || asTermType(type)) {\n    return <'term' | E.TermType> type;\n  }\n  return undefined;\n}\n\nexport type TypeCache = LRUCache<string, GeneralSuperTypeDict>;\nexport type SuperTypeCallback = (unknownType: string) => string;\nexport interface ISuperTypeProvider {\n  cache: TypeCache;\n  discoverer: SuperTypeCallback;\n}\n\n/**\n * Internal type of @see isSubTypeOf This only takes knownTypes but doesn't need an enabler\n */\nexport function isInternalSubType(baseType: OverrideType, argumentType: KnownLiteralTypes): boolean {\n  return baseType !== 'term' &&\n    (superTypeDictTable[baseType] && superTypeDictTable[baseType][argumentType] !== undefined);\n}\n\n/**\n * This function can be used to check the base type is a restriction on a type in the dict.\n * If we want to check if type x is a restriction on string we do this by calling:\n * 'http://www.w3.org/2001/XMLSchema#string' in getSuperTypeDict(X, superTypeProvider)\n * @param baseType\n * @param superTypeProvider\n */\nexport function getSuperTypeDict(baseType: string, superTypeProvider: ISuperTypeProvider): GeneralSuperTypeDict {\n  const concreteType: KnownLiteralTypes | undefined = asKnownLiteralType(baseType);\n  if (concreteType) {\n    // Concrete dataType is known by expression-evaluator.\n    return superTypeDictTable[concreteType];\n  }\n  // Datatype is a custom datatype\n  return getSuperTypes(baseType, superTypeProvider);\n}\n\n/**\n * This function needs to be O(1)! The execution time of this function is vital!\n * We define typeA isSubtypeOf typeA as true.\n * If you find yourself using this function a lot (e.g. in a case) please use getSuperTypeDict instead.\n * @param baseType type you want to provide.\n * @param argumentType type you want to provide @param baseType to.\n * @param superTypeProvider the enabler to discover super types of unknown types.\n */\nexport function isSubTypeOf(\n  baseType: string,\n  argumentType: KnownLiteralTypes,\n  superTypeProvider: ISuperTypeProvider,\n): boolean {\n  if (baseType === 'term') {\n    return false;\n  }\n  return getSuperTypeDict(baseType, superTypeProvider)[argumentType] !== undefined;\n}\n\n// Defined by https://www.w3.org/TR/xpath-31/#promotion .\n// e.g. When a function takes a string, it can also accept a XSD_ANY_URI if it's cast first.\nexport const typePromotion: Partial<Record<ArgumentType, {\n  typeToPromote: KnownLiteralTypes;\n  conversionFunction: (arg: E.TermExpression) => E.TermExpression;\n}[]>> = {\n  [TypeURL.XSD_STRING]: [\n    { typeToPromote: TypeURL.XSD_ANY_URI, conversionFunction: arg => string(arg.str()) },\n  ],\n  [TypeURL.XSD_DOUBLE]: [\n    { typeToPromote: TypeURL.XSD_FLOAT, conversionFunction: arg => double((<E.NumericLiteral>arg).typedValue) },\n    // TODO: in case of decimal a round needs to happen.\n    { typeToPromote: TypeURL.XSD_DECIMAL, conversionFunction: arg => double((<E.NumericLiteral>arg).typedValue) },\n  ],\n  [TypeURL.XSD_FLOAT]: [\n    // TODO: in case of decimal a round needs to happen.\n    { typeToPromote: TypeURL.XSD_DECIMAL, conversionFunction: arg => float((<E.NumericLiteral>arg).typedValue) },\n  ],\n};\n"]}