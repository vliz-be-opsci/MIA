{"version":3,"file":"MediatorCombinePipeline.js","sourceRoot":"","sources":["MediatorCombinePipeline.ts"],"names":[],"mappings":";;;AACA,yCAA0C;AAG1C;;;GAGG;AACH,MAAa,uBAKX,SAAQ,eAAoB;IAK5B,YAAmB,IAA8C;QAC/D,KAAK,CAAC,IAAI,CAAC,CAAC;IACd,CAAC;IAEe,KAAK,CAAC,OAAO,CAAC,MAAS;QACrC,IAAI,WAAiE,CAAC;QACtE,IAAI,CAAC;YACH,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;QACrC,CAAC;QAAC,MAAM,CAAC;YACP,8DAA8D;YAC9D,OAAO,MAAM,CAAC;QAChB,CAAC;QAED,IAAI,IAAI,CAAC,YAAY,EAAE,CAAC;YACtB,MAAM,YAAY,GAA8B,EAAE,CAAC;YACnD,KAAK,MAAM,MAAM,IAAI,WAAW,EAAE,CAAC;gBACjC,IAAI,CAAC;oBACH,MAAM,MAAM,CAAC,KAAK,CAAC;oBACnB,YAAY,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;gBAC5B,CAAC;gBAAC,MAAM,CAAC;oBACP,gBAAgB;gBAClB,CAAC;YACH,CAAC;YACD,WAAW,GAAG,YAAY,CAAC;QAC7B,CAAC;QAED,wBAAwB;QACxB,WAAW,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC,WAAW,CAAC,GAAG,CAAC,KAAK,EAAC,EAAE,KAAK,EAAE,KAAK,EAAE,EAAE,EAAE,CAAC,CAAC,EAAE,KAAK,EAAE,KAAK,EAAE,MAAM,KAAK,EAAE,CAAC,CAAC,CAAC,CAAC;QAE7G,gDAAgD;QAChD,IAAI,IAAI,CAAC,KAAK,EAAE,CAAC;YACf,kEAAkE;YAClE,MAAM,QAAQ,GAAG,CAAC,IAAO,EAAU,EAAE;gBACnC,0DAA0D;gBAC1D,uBAAuB;gBACvB,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAQ,IAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;gBAE3D,uCAAuC;gBACvC,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE,CAAC;oBAC9B,MAAM,IAAI,SAAS,CAAC,6CAA6C,CAAC,CAAC;gBACrE,CAAC;gBACD,OAAO,KAAK,CAAC;YACf,CAAC,CAAC;YAEF,WAAW,GAAG,WAAW,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,MAAM,EAAE,EAAE,CAChD,CAAC,IAAI,CAAC,KAAK,KAAK,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBACtC,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QACvD,CAAC;QAED,8BAA8B;QAC9B,yDAAyD;QACzD,IAAI,MAAM,GAAM,MAAM,CAAC;QACvB,KAAK,MAAM,EAAE,KAAK,EAAE,IAAI,WAAW,EAAE,CAAC;YACpC,MAAM,GAAG,EAAE,GAAG,MAAM,EAAE,GAAG,MAAM,KAAK,CAAC,aAAa,CAAC,MAAM,CAAC,EAAE,CAAC;QAC/D,CAAC;QAED,gCAAgC;QAChC,OAAO,MAAM,CAAC;IAChB,CAAC;IAES,WAAW;QACnB,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;IAC3C,CAAC;CACF;AAzED,0DAyEC","sourcesContent":["import type { Actor, IAction, IActorOutput, IActorReply, IActorTest, IMediatorArgs } from '@comunica/core';\nimport { Mediator } from '@comunica/core';\nimport type { IActionContext } from '@comunica/types';\n\n/**\n * A comunica mediator that goes over all actors in sequence and forwards I/O.\n * This required the action input and the actor output to be of the same type.\n */\nexport class MediatorCombinePipeline<\n  A extends Actor<H, T, H>,\nH extends IAction | (IActorOutput & { context: IActionContext }),\nT extends IActorTest,\n>\n  extends Mediator<A, H, T, H> {\n  public readonly filterErrors: boolean | undefined;\n  public readonly order: 'increasing' | 'decreasing' | undefined;\n  public readonly field: string | undefined;\n\n  public constructor(args: IMediatorCombinePipelineArgs<A, H, T, H>) {\n    super(args);\n  }\n\n  public override async mediate(action: H): Promise<H> {\n    let testResults: IActorReply<A, H, T, H>[] | { actor: A; reply: T }[];\n    try {\n      testResults = this.publish(action);\n    } catch {\n      // If no actors are available, just return the input as output\n      return action;\n    }\n\n    if (this.filterErrors) {\n      const _testResults: IActorReply<A, H, T, H>[] = [];\n      for (const result of testResults) {\n        try {\n          await result.reply;\n          _testResults.push(result);\n        } catch {\n          // Ignore errors\n        }\n      }\n      testResults = _testResults;\n    }\n\n    // Delegate test errors.\n    testResults = await Promise.all(testResults.map(async({ actor, reply }) => ({ actor, reply: await reply })));\n\n    // Order the test results if ordering is enabled\n    if (this.order) {\n      // A function used to extract an ordering value from a test result\n      const getOrder = (elem: T): number => {\n        // If there is a field key use it, otherwise use the input\n        // element for ordering\n        const value = this.field ? (<any> elem)[this.field] : elem;\n\n        // Check the ordering value is a number\n        if (typeof value !== 'number') {\n          throw new TypeError('Cannot order elements that are not numbers.');\n        }\n        return value;\n      };\n\n      testResults = testResults.sort((actor1, actor2) =>\n        (this.order === 'increasing' ? 1 : -1) *\n        (getOrder(actor1.reply) - getOrder(actor2.reply)));\n    }\n\n    // Pass action to first actor,\n    // and each actor output as input to the following actor.\n    let handle: H = action;\n    for (const { actor } of testResults) {\n      handle = { ...handle, ...await actor.runObservable(handle) };\n    }\n\n    // Return the final actor output\n    return handle;\n  }\n\n  protected mediateWith(): Promise<A> {\n    throw new Error('Method not supported.');\n  }\n}\n\nexport interface IMediatorCombinePipelineArgs<\n  A extends Actor<I, T, O>,\nI extends IAction,\nT extends IActorTest,\nO extends IActorOutput,\n>\n  extends IMediatorArgs<A, I, T, O> {\n  /**\n   * If actors that throw test errors should be ignored\n   */\n  filterErrors?: boolean;\n  /**\n   * The field to use for ordering (if the ordering strategy is chosen).\n   * Leave undefined if the test output is a number rather than an object.\n   */\n  field?: string;\n  /**\n   * The strategy of ordering the pipeline (increasing or decreasing).\n   * For choosing to leave the order of the pipeline unchanged, leave this undefined.\n   * For choosing to order by increasing values: 'increasing'.\n   * For choosing to order by decreasing values: 'decreasing'.\n   */\n  order?: 'increasing' | 'decreasing' | undefined;\n}\n"]}