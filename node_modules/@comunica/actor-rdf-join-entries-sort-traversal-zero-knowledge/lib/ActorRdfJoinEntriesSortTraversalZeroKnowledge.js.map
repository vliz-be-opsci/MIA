{"version":3,"file":"ActorRdfJoinEntriesSortTraversalZeroKnowledge.js","sourceRoot":"","sources":["ActorRdfJoinEntriesSortTraversalZeroKnowledge.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IActionRdfJoinEntriesSort, IActorRdfJoinEntriesSortOutput } from '@comunica/bus-rdf-join-entries-sort';\nimport { ActorRdfJoinEntriesSort } from '@comunica/bus-rdf-join-entries-sort';\nimport { KeysQueryOperation } from '@comunica/context-entries';\nimport type { IActorArgs, IActorTest } from '@comunica/core';\nimport type { IJoinEntryWithMetadata, IQuerySourceWrapper } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport { getNamedNodes, getTerms, getVariables, QUAD_TERM_NAMES } from 'rdf-terms';\nimport { Algebra, Util as AlgebraUtil } from 'sparqlalgebrajs';\n\n/**\n * An actor that sorts join entries based on Hartig's heuristic for plan selection in link traversal environments.\n *\n * It first determines isolated connected graphs. (done by @comunica/actor-optimize-query-operation-join-connected)\n * For each of the connected graphs, it orders triple patterns in BGPs by the following priority:\n * 1. dependency-respecting: for each (non-first) pattern, at least one variable must occur in a preceding pattern.\n * 2. seed: try to make the first pattern contain a source URI.\n * 3. no vocab seed: avoid first triple pattern with vocab URI (variable predicate,\n *    or variable objects with rdf:type predicate)\n * 4. filtering: patterns only containing variables also contained in preceding triple patterns\n *    are placed as soon as possible.\n *\n * It does this in an adaptive way.\n * This means that this actor will only determine the first triple pattern,\n * execute it, and materialize the remaining BGP based on its results.\n * After that, the remaining BGP is evaluated recursively by this or another BGP actor.\n */\nexport class ActorRdfJoinEntriesSortTraversalZeroKnowledge extends ActorRdfJoinEntriesSort {\n  public constructor(\n    args: IActorArgs<IActionRdfJoinEntriesSort, IActorTest, IActorRdfJoinEntriesSortOutput>,\n  ) {\n    super(args);\n  }\n\n  /**\n   * Obtain all IRIs from the given pattern that are not related to vocabularies.\n   * Concretely, predicates will be omitted, and objects if predicate is http://www.w3.org/1999/02/22-rdf-syntax-ns#type\n   * @param pattern A quad pattern.\n   */\n  public static getPatternNonVocabUris(pattern: Algebra.Pattern | Algebra.Path): RDF.NamedNode[] {\n    let nonVocabTerms: RDF.Term[];\n    const predicates: RDF.Term[] = [];\n    if (pattern.type === 'pattern') {\n      predicates.push(pattern.predicate);\n    } else {\n      AlgebraUtil.recurseOperation(pattern, {\n        link(link: Algebra.Link) {\n          predicates.push(link.iri);\n          return false;\n        },\n        nps(nps: Algebra.Nps) {\n          for (const iri of nps.iris) {\n            predicates.push(iri);\n          }\n          return false;\n        },\n      });\n    }\n\n    if (predicates\n      .some(predicate => predicate.termType === 'NamedNode' &&\n        predicate.value === 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type')) {\n      nonVocabTerms = [ pattern.subject, pattern.graph ];\n    } else {\n      nonVocabTerms = [ pattern.subject, pattern.object, pattern.graph ];\n    }\n    return getNamedNodes(nonVocabTerms);\n  }\n\n  /**\n   * Determine the source IRI of a given IRI without hash.\n   * @param namedNode An IRI.\n   */\n  public static getSourceUri(namedNode: RDF.NamedNode): string {\n    const value = namedNode.value;\n    const hashPos = value.indexOf('#');\n    return hashPos > 0 ? value.slice(0, hashPos) : value;\n  }\n\n  /**\n   * Calculate a score for the given quad pattern based on a given set of sources.\n   * The more sources are present in the given pattern as non-vocab URIs, the higher the score.\n   * @param pattern A quad pattern.\n   * @param sources An array of sources.\n   */\n  public static getScoreSeedNonVocab(pattern: Algebra.Pattern | Algebra.Path, sources: string[]): number {\n    return ActorRdfJoinEntriesSortTraversalZeroKnowledge.getPatternNonVocabUris(pattern)\n      .map(term => ActorRdfJoinEntriesSortTraversalZeroKnowledge.getSourceUri(term))\n      .filter(uri => sources.includes(uri))\n      .length;\n  }\n\n  /**\n   * Determine a score for the selectivity of the given pattern.\n   * The fewer variables, the higher the score.\n   * @param pattern A quad pattern.\n   */\n  public static getScoreSelectivity(pattern: Algebra.Pattern | Algebra.Path): number {\n    const terms = pattern.type === 'pattern' ? getTerms(pattern) : [ pattern.subject, pattern.object, pattern.graph ];\n    return QUAD_TERM_NAMES.length - getVariables(terms).length;\n  }\n\n  /**\n   * This sorts join entries by first prioritizing triple patterns in BGPs, and then all other operation types.\n   *\n   * Sort the patterns in BGPs by the following priorities:\n   * 1. A source in S or O (not O if rdf:type) (seed rule, no vocab rule)\n   * 2. Most selective: fewest variables (filtering rule, dependency-respecting rule)\n   * @param entries Quad patterns.\n   * @param sources The sources that are currently being queried.\n   */\n  public static sortJoinEntries(entries: IJoinEntryWithMetadata[], sources: string[]): IJoinEntryWithMetadata[] {\n    return [ ...entries ].sort((entryA: IJoinEntryWithMetadata, entryB: IJoinEntryWithMetadata) => {\n      if ((entryA.operation.type === Algebra.types.PATTERN || entryA.operation.type === Algebra.types.PATH) &&\n        (entryB.operation.type === Algebra.types.PATTERN || entryB.operation.type === Algebra.types.PATH)) {\n        const compSeedNonVocab = ActorRdfJoinEntriesSortTraversalZeroKnowledge\n          .getScoreSeedNonVocab(entryB.operation, sources) -\n          ActorRdfJoinEntriesSortTraversalZeroKnowledge.getScoreSeedNonVocab(entryA.operation, sources);\n        if (compSeedNonVocab === 0) {\n          return ActorRdfJoinEntriesSortTraversalZeroKnowledge.getScoreSelectivity(entryB.operation) -\n            ActorRdfJoinEntriesSortTraversalZeroKnowledge.getScoreSelectivity(entryA.operation);\n        }\n        return compSeedNonVocab;\n      }\n      return entryA.operation.type === Algebra.types.PATTERN ? -1 : 1;\n    });\n  }\n\n  public async test(_action: IActionRdfJoinEntriesSort): Promise<IActorTest> {\n    return true;\n  }\n\n  public async run(action: IActionRdfJoinEntriesSort): Promise<IActorRdfJoinEntriesSortOutput> {\n    // Determine all current sources\n    const sources: string[] = [];\n    const dataSources: IQuerySourceWrapper[] | undefined = action.context\n      .get(KeysQueryOperation.querySources);\n    if (dataSources) {\n      for (const source of dataSources) {\n        const sourceValue = source.source.referenceValue;\n        if (typeof sourceValue === 'string') {\n          sources.push(sourceValue);\n        }\n      }\n    }\n\n    return { entries: ActorRdfJoinEntriesSortTraversalZeroKnowledge.sortJoinEntries(action.entries, sources) };\n  }\n}\n"]}