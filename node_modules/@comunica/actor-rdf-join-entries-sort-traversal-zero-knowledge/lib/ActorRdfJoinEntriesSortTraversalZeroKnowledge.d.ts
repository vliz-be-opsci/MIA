import type { IActionRdfJoinEntriesSort, IActorRdfJoinEntriesSortOutput } from '@comunica/bus-rdf-join-entries-sort';
import { ActorRdfJoinEntriesSort } from '@comunica/bus-rdf-join-entries-sort';
import type { IActorArgs, IActorTest } from '@comunica/core';
import type { IJoinEntryWithMetadata } from '@comunica/types';
import type * as RDF from '@rdfjs/types';
import { Algebra } from 'sparqlalgebrajs';
/**
 * An actor that sorts join entries based on Hartig's heuristic for plan selection in link traversal environments.
 *
 * It first determines isolated connected graphs. (done by @comunica/actor-optimize-query-operation-join-connected)
 * For each of the connected graphs, it orders triple patterns in BGPs by the following priority:
 * 1. dependency-respecting: for each (non-first) pattern, at least one variable must occur in a preceding pattern.
 * 2. seed: try to make the first pattern contain a source URI.
 * 3. no vocab seed: avoid first triple pattern with vocab URI (variable predicate,
 *    or variable objects with rdf:type predicate)
 * 4. filtering: patterns only containing variables also contained in preceding triple patterns
 *    are placed as soon as possible.
 *
 * It does this in an adaptive way.
 * This means that this actor will only determine the first triple pattern,
 * execute it, and materialize the remaining BGP based on its results.
 * After that, the remaining BGP is evaluated recursively by this or another BGP actor.
 */
export declare class ActorRdfJoinEntriesSortTraversalZeroKnowledge extends ActorRdfJoinEntriesSort {
    constructor(args: IActorArgs<IActionRdfJoinEntriesSort, IActorTest, IActorRdfJoinEntriesSortOutput>);
    /**
     * Obtain all IRIs from the given pattern that are not related to vocabularies.
     * Concretely, predicates will be omitted, and objects if predicate is http://www.w3.org/1999/02/22-rdf-syntax-ns#type
     * @param pattern A quad pattern.
     */
    static getPatternNonVocabUris(pattern: Algebra.Pattern | Algebra.Path): RDF.NamedNode[];
    /**
     * Determine the source IRI of a given IRI without hash.
     * @param namedNode An IRI.
     */
    static getSourceUri(namedNode: RDF.NamedNode): string;
    /**
     * Calculate a score for the given quad pattern based on a given set of sources.
     * The more sources are present in the given pattern as non-vocab URIs, the higher the score.
     * @param pattern A quad pattern.
     * @param sources An array of sources.
     */
    static getScoreSeedNonVocab(pattern: Algebra.Pattern | Algebra.Path, sources: string[]): number;
    /**
     * Determine a score for the selectivity of the given pattern.
     * The fewer variables, the higher the score.
     * @param pattern A quad pattern.
     */
    static getScoreSelectivity(pattern: Algebra.Pattern | Algebra.Path): number;
    /**
     * This sorts join entries by first prioritizing triple patterns in BGPs, and then all other operation types.
     *
     * Sort the patterns in BGPs by the following priorities:
     * 1. A source in S or O (not O if rdf:type) (seed rule, no vocab rule)
     * 2. Most selective: fewest variables (filtering rule, dependency-respecting rule)
     * @param entries Quad patterns.
     * @param sources The sources that are currently being queried.
     */
    static sortJoinEntries(entries: IJoinEntryWithMetadata[], sources: string[]): IJoinEntryWithMetadata[];
    test(_action: IActionRdfJoinEntriesSort): Promise<IActorTest>;
    run(action: IActionRdfJoinEntriesSort): Promise<IActorRdfJoinEntriesSortOutput>;
}
