"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KEY_CONTEXT_WITHPOLICIES = exports.KEY_CONTEXT_POLICIES = exports.ActorExtractLinksContentPolicies = void 0;
const actor_init_query_1 = require("@comunica/actor-init-query");
const bus_extract_links_1 = require("@comunica/bus-extract-links");
const context_entries_1 = require("@comunica/context-entries");
const core_1 = require("@comunica/core");
const rdf_store_stream_1 = require("rdf-store-stream");
const rdf_terms_1 = require("rdf-terms");
const SimpleSclParser_1 = require("./SimpleSclParser");
/**
 * A comunica Traverse Content Policies RDF Metadata Extract Actor.
 */
class ActorExtractLinksContentPolicies extends bus_extract_links_1.ActorExtractLinks {
    constructor(args) {
        super(args);
        this.sclParser = new SimpleSclParser_1.SimpleSclParser();
        this.queryEngine = new actor_init_query_1.QueryEngineBase(args.actorInitQuery);
    }
    async test(_action) {
        return true;
    }
    static getContentPolicies(context) {
        return context.get(exports.KEY_CONTEXT_POLICIES) ?? [];
    }
    async getContentPoliciesFromDocument(documentIri, store) {
        // Query the content policies that apply to the current document
        const bindingsStream = await this.queryEngine
            .queryBindings(`
        PREFIX scl: <https://w3id.org/scl/vocab#>
        SELECT ?scope WHERE {
          ?policy scl:appliesTo <${documentIri}>;
                  scl:scope ?scope.
        }`, { sources: [store] });
        // Parse all found content policies
        return (await bindingsStream.toArray())
            .map(binding => this.sclParser.parse(binding.get('scope').value, documentIri));
    }
    static getCurrentQuadPattern(context) {
        const currentQueryOperation = context.get(context_entries_1.KeysQueryOperation.operation);
        if (!currentQueryOperation || currentQueryOperation.type !== 'pattern') {
            return;
        }
        return currentQueryOperation;
    }
    static isContentPolicyApplicableForPattern(policy, queryingPattern) {
        if (!policy.filter || !queryingPattern) {
            return true;
        }
        for (const policyPattern of policy.filter.template) {
            if ((0, rdf_terms_1.matchPatternComplete)(policyPattern, queryingPattern) ||
                (0, rdf_terms_1.matchPatternComplete)(queryingPattern, policyPattern)) {
                return true;
            }
        }
        return false;
    }
    async run(action) {
        const contentPolicies = ActorExtractLinksContentPolicies
            .getContentPolicies(action.context);
        const currentQuadPattern = ActorExtractLinksContentPolicies.getCurrentQuadPattern(action.context);
        const links = [];
        let store;
        // If KEY_CONTEXT_WITHPOLICIES is enabled, extract all content policies from the metadata
        if (action.context && action.context.get(exports.KEY_CONTEXT_WITHPOLICIES)) {
            store = await (0, rdf_store_stream_1.storeStream)(action.metadata);
            for (const docPolicy of await this.getContentPoliciesFromDocument(action.url, store)) {
                // Only add policies that produce quads matching the currently querying quad pattern
                if (ActorExtractLinksContentPolicies
                    .isContentPolicyApplicableForPattern(docPolicy, currentQuadPattern)) {
                    contentPolicies.push(docPolicy);
                }
            }
        }
        // Send the policy's graph pattern into the query engine using the metadata stream as source
        for (const contentPolicy of contentPolicies) {
            // Load store only once
            if (!store) {
                store = await (0, rdf_store_stream_1.storeStream)(action.metadata);
            }
            // Find all matching results
            const bindingsStream = await this.queryEngine
                .queryBindings(contentPolicy.graphPattern, { sources: [store] });
            // Extract all bound named nodes from the policy's variables
            const bindings = await bindingsStream.toArray();
            for (const binding of bindings) {
                // If the content policy has a filter, apply it on the links to traverse
                let transform;
                if (contentPolicy.filter) {
                    transform = async (input) => {
                        const subStore = await (0, rdf_store_stream_1.storeStream)(input);
                        return await this.queryEngine.queryQuads(contentPolicy.filter, {
                            sources: [subStore],
                            // Apply the bindings to the INCLUDE WHERE clause
                            initialBindings: binding,
                        });
                    };
                }
                // Create a separate link for each followed variable
                for (const variable of contentPolicy.variables) {
                    const term = binding.get(variable.name);
                    if (term && term.termType === 'NamedNode') {
                        const link = {
                            url: term.value,
                            transform,
                            metadata: { producedByActor: { name: this.name, traverseConditional: this.traverseConditional } },
                        };
                        // Mark in the context if the linked document's policies should be considered
                        link.context = new core_1.ActionContext({ [exports.KEY_CONTEXT_WITHPOLICIES.name]: variable.withPolicies });
                        links.push(link);
                    }
                }
            }
        }
        return this.traverseConditional ? { linksConditional: links, links: [] } : { links };
    }
}
exports.ActorExtractLinksContentPolicies = ActorExtractLinksContentPolicies;
exports.KEY_CONTEXT_POLICIES = new core_1.ActionContextKey('@comunica/actor-extract-links-content-policies:policies');
exports.KEY_CONTEXT_WITHPOLICIES = new core_1.ActionContextKey('@comunica/actor-extract-links-content-policies:withPolicies');
//# sourceMappingURL=ActorExtractLinksContentPolicies.js.map