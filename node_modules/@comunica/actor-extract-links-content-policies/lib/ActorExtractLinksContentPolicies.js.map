{"version":3,"file":"ActorExtractLinksContentPolicies.js","sourceRoot":"","sources":["ActorExtractLinksContentPolicies.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ActorInitQueryBase } from '@comunica/actor-init-query';\nimport { QueryEngineBase } from '@comunica/actor-init-query';\nimport type { IActionExtractLinks, IActorExtractLinksOutput } from '@comunica/bus-extract-links';\nimport {\n  ActorExtractLinks,\n} from '@comunica/bus-extract-links';\nimport type { ILink } from '@comunica/bus-rdf-resolve-hypermedia-links';\nimport { KeysQueryOperation } from '@comunica/context-entries';\nimport type { IActorArgs, IActorTest } from '@comunica/core';\nimport { ActionContext, ActionContextKey } from '@comunica/core';\nimport type { Bindings, IActionContext } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport { storeStream } from 'rdf-store-stream';\nimport { matchPatternComplete } from 'rdf-terms';\nimport type { Algebra } from 'sparqlalgebrajs';\nimport type { ContentPolicy } from './ContentPolicy';\nimport { SimpleSclParser } from './SimpleSclParser';\n\n/**\n * A comunica Traverse Content Policies RDF Metadata Extract Actor.\n */\nexport class ActorExtractLinksContentPolicies extends ActorExtractLinks\n  implements IActorExtractLinksContentPoliciesArgs {\n  private readonly sclParser: SimpleSclParser;\n\n  public readonly actorInitQuery: ActorInitQueryBase;\n  public readonly traverseConditional: boolean;\n  public readonly queryEngine: QueryEngineBase;\n\n  public constructor(args: IActorExtractLinksContentPoliciesArgs) {\n    super(args);\n    this.sclParser = new SimpleSclParser();\n    this.queryEngine = new QueryEngineBase(args.actorInitQuery);\n  }\n\n  public async test(_action: IActionExtractLinks): Promise<IActorTest> {\n    return true;\n  }\n\n  public static getContentPolicies(context: IActionContext): ContentPolicy[] {\n    return context.get(KEY_CONTEXT_POLICIES) ?? [];\n  }\n\n  protected async getContentPoliciesFromDocument(documentIri: string, store: RDF.Store): Promise<ContentPolicy[]> {\n    // Query the content policies that apply to the current document\n    const bindingsStream = await this.queryEngine\n      .queryBindings(`\n        PREFIX scl: <https://w3id.org/scl/vocab#>\n        SELECT ?scope WHERE {\n          ?policy scl:appliesTo <${documentIri}>;\n                  scl:scope ?scope.\n        }`, { sources: [ store ]});\n\n    // Parse all found content policies\n    return (await bindingsStream.toArray())\n      .map(binding => this.sclParser.parse(binding.get('scope')!.value, documentIri));\n  }\n\n  public static getCurrentQuadPattern(context: IActionContext): Algebra.Pattern | undefined {\n    const currentQueryOperation: Algebra.Operation | undefined = context.get(KeysQueryOperation.operation);\n    if (!currentQueryOperation || currentQueryOperation.type !== 'pattern') {\n      return;\n    }\n    return currentQueryOperation;\n  }\n\n  public static isContentPolicyApplicableForPattern(policy: ContentPolicy, queryingPattern?: Algebra.Pattern): boolean {\n    if (!policy.filter || !queryingPattern) {\n      return true;\n    }\n    for (const policyPattern of policy.filter.template) {\n      if (matchPatternComplete(policyPattern, queryingPattern) ||\n        matchPatternComplete(queryingPattern, policyPattern)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  public async run(action: IActionExtractLinks): Promise<IActorExtractLinksOutput> {\n    const contentPolicies: ContentPolicy[] = ActorExtractLinksContentPolicies\n      .getContentPolicies(action.context);\n    const currentQuadPattern = ActorExtractLinksContentPolicies.getCurrentQuadPattern(action.context);\n    const links: ILink[] = [];\n    let store: RDF.Store | undefined;\n\n    // If KEY_CONTEXT_WITHPOLICIES is enabled, extract all content policies from the metadata\n    if (action.context && action.context.get(KEY_CONTEXT_WITHPOLICIES)) {\n      store = await storeStream(action.metadata);\n      for (const docPolicy of await this.getContentPoliciesFromDocument(action.url, store)) {\n        // Only add policies that produce quads matching the currently querying quad pattern\n        if (ActorExtractLinksContentPolicies\n          .isContentPolicyApplicableForPattern(docPolicy, currentQuadPattern)) {\n          contentPolicies.push(docPolicy);\n        }\n      }\n    }\n\n    // Send the policy's graph pattern into the query engine using the metadata stream as source\n    for (const contentPolicy of contentPolicies) {\n      // Load store only once\n      if (!store) {\n        store = await storeStream(action.metadata);\n      }\n\n      // Find all matching results\n      const bindingsStream = await this.queryEngine\n        .queryBindings(contentPolicy.graphPattern, { sources: [ store ]});\n\n      // Extract all bound named nodes from the policy's variables\n      const bindings: Bindings[] = await bindingsStream.toArray();\n      for (const binding of bindings) {\n        // If the content policy has a filter, apply it on the links to traverse\n        let transform: ((input: RDF.Stream) => Promise<RDF.Stream>) | undefined;\n        if (contentPolicy.filter) {\n          transform = async(input: RDF.Stream) => {\n            const subStore = await storeStream(input);\n            return await this.queryEngine.queryQuads(contentPolicy.filter!, {\n              sources: [ subStore ],\n              // Apply the bindings to the INCLUDE WHERE clause\n              initialBindings: binding,\n            });\n          };\n        }\n\n        // Create a separate link for each followed variable\n        for (const variable of contentPolicy.variables) {\n          const term = binding.get(variable.name);\n          if (term && term.termType === 'NamedNode') {\n            const link: ILink = {\n              url: term.value,\n              transform,\n              metadata: { producedByActor: { name: this.name, traverseConditional: this.traverseConditional }},\n            };\n\n            // Mark in the context if the linked document's policies should be considered\n            link.context = new ActionContext({ [KEY_CONTEXT_WITHPOLICIES.name]: variable.withPolicies });\n\n            links.push(link);\n          }\n        }\n      }\n    }\n    return this.traverseConditional ? { linksConditional: links, links: []} : { links };\n  }\n}\n\nexport interface IActorExtractLinksContentPoliciesArgs\n  extends IActorArgs<IActionExtractLinks, IActorTest, IActorExtractLinksOutput> {\n  /**\n   * An init query actor that is used to query all links to follow from a stream.\n   * @default {<urn:comunica:default:init/actors#query>}\n   */\n  actorInitQuery: ActorInitQueryBase;\n  /**\n   * If true (default), then content policies will be applied on links that are being detected by some other actor,\n   * if false, then links detected by content policies will forcefully be added to the link queue.\n   * @default {true}\n   */\n  traverseConditional: boolean;\n}\n\nexport const KEY_CONTEXT_POLICIES = new ActionContextKey<ContentPolicy[]>(\n  '@comunica/actor-extract-links-content-policies:policies',\n);\nexport const KEY_CONTEXT_WITHPOLICIES = new ActionContextKey<boolean>(\n  '@comunica/actor-extract-links-content-policies:withPolicies',\n);\n"]}