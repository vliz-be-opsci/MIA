{"version":3,"file":"ActorQueryOperationOrderBy.js","sourceRoot":"","sources":["ActorQueryOperationOrderBy.ts"],"names":[],"mappings":"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","sourcesContent":["import { BindingsFactory } from '@comunica/bindings-factory';\nimport type { MediatorMergeBindingsContext } from '@comunica/bus-merge-bindings-context';\nimport type { IActorQueryOperationTypedMediatedArgs } from '@comunica/bus-query-operation';\nimport {\n  ActorQueryOperation,\n  ActorQueryOperationTypedMediated,\n} from '@comunica/bus-query-operation';\nimport type { IActorTest } from '@comunica/core';\nimport { AsyncEvaluator, isExpressionError, orderTypes } from '@comunica/expression-evaluator';\nimport type { Bindings, IActionContext, IQueryOperationResult } from '@comunica/types';\nimport type { Term } from '@rdfjs/types';\nimport { Algebra } from 'sparqlalgebrajs';\nimport { SortIterator } from './SortIterator';\n\n/**\n * A comunica OrderBy Sparqlee Query Operation Actor.\n */\nexport class ActorQueryOperationOrderBy extends ActorQueryOperationTypedMediated<Algebra.OrderBy> {\n  private readonly window: number;\n  public readonly mediatorMergeBindingsContext: MediatorMergeBindingsContext;\n\n  public constructor(args: IActorQueryOperationOrderBySparqleeArgs) {\n    super(args, 'orderby');\n    this.window = args.window ?? Number.POSITIVE_INFINITY;\n  }\n\n  public async testOperation(operation: Algebra.OrderBy, context: IActionContext): Promise<IActorTest> {\n    // Will throw error for unsupported operators\n    const bindingsFactory = await BindingsFactory.create(this.mediatorMergeBindingsContext, context);\n\n    for (let expr of operation.expressions) {\n      expr = this.extractSortExpression(expr);\n      const _ = new AsyncEvaluator(\n        expr,\n        ActorQueryOperation.getAsyncExpressionContext(context, this.mediatorQueryOperation, bindingsFactory),\n      );\n    }\n    return true;\n  }\n\n  public async runOperation(operation: Algebra.OrderBy, context: IActionContext):\n  Promise<IQueryOperationResult> {\n    const outputRaw = await this.mediatorQueryOperation.mediate({ operation: operation.input, context });\n    const output = ActorQueryOperation.getSafeBindings(outputRaw);\n\n    const options = { window: this.window };\n    const bindingsFactory = await BindingsFactory.create(this.mediatorMergeBindingsContext, context);\n    const sparqleeConfig = {\n      ...ActorQueryOperation.getAsyncExpressionContext(context, this.mediatorQueryOperation, bindingsFactory),\n    };\n    let { bindingsStream } = output;\n\n    // Sorting backwards since the first one is the most important therefore should be ordered last.\n    for (let i = operation.expressions.length - 1; i >= 0; i--) {\n      let expr = operation.expressions[i];\n      const isAscending = this.isAscending(expr);\n      expr = this.extractSortExpression(expr);\n      // Transform the stream by annotating it with the expr result\n      const evaluator = new AsyncEvaluator(expr, sparqleeConfig);\n      interface IAnnotatedBinding {\n        bindings: Bindings;\n        result: Term | undefined;\n      }\n\n      const transform = async(bindings: Bindings, next: any, push: (result: IAnnotatedBinding) => void):\n      Promise<void> => {\n        try {\n          const result = await evaluator.evaluate(bindings);\n          push({ bindings, result });\n        } catch (error: unknown) {\n          // We ignore all Expression errors.\n          // Other errors (likely programming mistakes) are still propagated.\n          // I can't recall where this is defined in the spec.\n          if (!isExpressionError(<Error> error)) {\n            bindingsStream.emit('error', error);\n          }\n          push({ bindings, result: undefined });\n        }\n        next();\n      };\n      // eslint-disable-next-line ts/no-misused-promises\n      const transformedStream = bindingsStream.transform<IAnnotatedBinding>({ transform });\n\n      // Sort the annoted stream\n      const sortedStream = new SortIterator(transformedStream, (left, right) => {\n        let compare = orderTypes(left.result, right.result);\n        if (!isAscending) {\n          compare *= -1;\n        }\n        return compare;\n      }, options);\n\n      // Remove the annotation\n      bindingsStream = sortedStream.map(({ bindings }) => bindings);\n    }\n\n    return {\n      type: 'bindings',\n      bindingsStream,\n      metadata: output.metadata,\n    };\n  }\n\n  // Remove descending operator if necessary\n  private extractSortExpression(expr: Algebra.Expression): Algebra.Expression {\n    const { expressionType, operator } = expr;\n    if (expressionType !== Algebra.expressionTypes.OPERATOR) {\n      return expr;\n    }\n    return operator === 'desc' ?\n      expr.args[0] :\n      expr;\n  }\n\n  private isAscending(expr: Algebra.Expression): boolean {\n    const { expressionType, operator } = expr;\n    if (expressionType !== Algebra.expressionTypes.OPERATOR) {\n      return true;\n    }\n    return operator !== 'desc';\n  }\n}\n\n/**\n * The window parameter determines how many of the elements to consider when sorting.\n */\nexport interface IActorQueryOperationOrderBySparqleeArgs extends IActorQueryOperationTypedMediatedArgs {\n  /**\n   * A mediator for creating binding context merge handlers\n   */\n  mediatorMergeBindingsContext: MediatorMergeBindingsContext;\n  /**\n   * The size of the window for the sort iterator.\n   * @range {integer}\n   */\n  window?: number;\n}\n"]}