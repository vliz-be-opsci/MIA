"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorQueryOperationOrderBy = void 0;
const bindings_factory_1 = require("@comunica/bindings-factory");
const bus_query_operation_1 = require("@comunica/bus-query-operation");
const expression_evaluator_1 = require("@comunica/expression-evaluator");
const sparqlalgebrajs_1 = require("sparqlalgebrajs");
const SortIterator_1 = require("./SortIterator");
/**
 * A comunica OrderBy Sparqlee Query Operation Actor.
 */
class ActorQueryOperationOrderBy extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'orderby');
        this.window = args.window ?? Number.POSITIVE_INFINITY;
    }
    async testOperation(operation, context) {
        // Will throw error for unsupported operators
        const bindingsFactory = await bindings_factory_1.BindingsFactory.create(this.mediatorMergeBindingsContext, context);
        for (let expr of operation.expressions) {
            expr = this.extractSortExpression(expr);
            const _ = new expression_evaluator_1.AsyncEvaluator(expr, bus_query_operation_1.ActorQueryOperation.getAsyncExpressionContext(context, this.mediatorQueryOperation, bindingsFactory));
        }
        return true;
    }
    async runOperation(operation, context) {
        const outputRaw = await this.mediatorQueryOperation.mediate({ operation: operation.input, context });
        const output = bus_query_operation_1.ActorQueryOperation.getSafeBindings(outputRaw);
        const options = { window: this.window };
        const bindingsFactory = await bindings_factory_1.BindingsFactory.create(this.mediatorMergeBindingsContext, context);
        const sparqleeConfig = {
            ...bus_query_operation_1.ActorQueryOperation.getAsyncExpressionContext(context, this.mediatorQueryOperation, bindingsFactory),
        };
        let { bindingsStream } = output;
        // Sorting backwards since the first one is the most important therefore should be ordered last.
        for (let i = operation.expressions.length - 1; i >= 0; i--) {
            let expr = operation.expressions[i];
            const isAscending = this.isAscending(expr);
            expr = this.extractSortExpression(expr);
            // Transform the stream by annotating it with the expr result
            const evaluator = new expression_evaluator_1.AsyncEvaluator(expr, sparqleeConfig);
            const transform = async (bindings, next, push) => {
                try {
                    const result = await evaluator.evaluate(bindings);
                    push({ bindings, result });
                }
                catch (error) {
                    // We ignore all Expression errors.
                    // Other errors (likely programming mistakes) are still propagated.
                    // I can't recall where this is defined in the spec.
                    if (!(0, expression_evaluator_1.isExpressionError)(error)) {
                        bindingsStream.emit('error', error);
                    }
                    push({ bindings, result: undefined });
                }
                next();
            };
            // eslint-disable-next-line ts/no-misused-promises
            const transformedStream = bindingsStream.transform({ transform });
            // Sort the annoted stream
            const sortedStream = new SortIterator_1.SortIterator(transformedStream, (left, right) => {
                let compare = (0, expression_evaluator_1.orderTypes)(left.result, right.result);
                if (!isAscending) {
                    compare *= -1;
                }
                return compare;
            }, options);
            // Remove the annotation
            bindingsStream = sortedStream.map(({ bindings }) => bindings);
        }
        return {
            type: 'bindings',
            bindingsStream,
            metadata: output.metadata,
        };
    }
    // Remove descending operator if necessary
    extractSortExpression(expr) {
        const { expressionType, operator } = expr;
        if (expressionType !== sparqlalgebrajs_1.Algebra.expressionTypes.OPERATOR) {
            return expr;
        }
        return operator === 'desc' ?
            expr.args[0] :
            expr;
    }
    isAscending(expr) {
        const { expressionType, operator } = expr;
        if (expressionType !== sparqlalgebrajs_1.Algebra.expressionTypes.OPERATOR) {
            return true;
        }
        return operator !== 'desc';
    }
}
exports.ActorQueryOperationOrderBy = ActorQueryOperationOrderBy;
//# sourceMappingURL=ActorQueryOperationOrderBy.js.map