{"version":3,"file":"ActorOptimizeQueryOperationPruneEmptySourceOperations.js","sourceRoot":"","sources":["ActorOptimizeQueryOperationPruneEmptySourceOperations.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  IActionOptimizeQueryOperation,\n  IActorOptimizeQueryOperationOutput,\n  IActorOptimizeQueryOperationArgs,\n} from '@comunica/bus-optimize-query-operation';\nimport { ActorOptimizeQueryOperation } from '@comunica/bus-optimize-query-operation';\nimport { ActorQueryOperation } from '@comunica/bus-query-operation';\nimport { KeysQuerySourceIdentify } from '@comunica/context-entries';\nimport type { IActorTest } from '@comunica/core';\nimport type { IActionContext, IQuerySourceWrapper, MetadataBindings } from '@comunica/types';\nimport { DataFactory } from 'rdf-data-factory';\nimport { Algebra, Factory, Util } from 'sparqlalgebrajs';\n\nconst AF = new Factory();\nconst DF = new DataFactory();\n\n/**\n * A comunica Prune Empty Source Operations Optimize Query Operation Actor.\n */\nexport class ActorOptimizeQueryOperationPruneEmptySourceOperations extends ActorOptimizeQueryOperation {\n  private readonly useAskIfSupported: boolean;\n\n  public constructor(args: IActorOptimizeQueryOperationPruneEmptySourceOperationsArgs) {\n    super(args);\n  }\n\n  public async test(action: IActionOptimizeQueryOperation): Promise<IActorTest> {\n    if (ActorQueryOperation.getOperationSource(action.operation)) {\n      throw new Error(`Actor ${this.name} does not work with top-level operation sources.`);\n    }\n    return true;\n  }\n\n  public async run(action: IActionOptimizeQueryOperation): Promise<IActorOptimizeQueryOperationOutput> {\n    let operation = action.operation;\n\n    // Collect all operations with source types\n    // Only consider unions of patterns or alts of links, since these are created during exhaustive source assignment.\n    const collectedOperations: (Algebra.Pattern | Algebra.Link)[] = [];\n    // eslint-disable-next-line ts/no-this-alias\n    const self = this;\n    Util.recurseOperation(operation, {\n      [Algebra.types.UNION](subOperation) {\n        self.collectMultiOperationInputs(subOperation.input, collectedOperations, Algebra.types.PATTERN);\n        return true;\n      },\n      [Algebra.types.ALT](subOperation) {\n        self.collectMultiOperationInputs(subOperation.input, collectedOperations, Algebra.types.LINK);\n        return false;\n      },\n      [Algebra.types.SERVICE]() {\n        return false;\n      },\n    });\n\n    // Determine in an async manner whether or not these sources return non-empty results\n    const emptyOperations: Set<Algebra.Operation> = new Set();\n    await Promise.all(collectedOperations.map(async(collectedOperation) => {\n      const checkOperation = collectedOperation.type === 'link' ?\n        AF.createPattern(DF.variable('?s'), collectedOperation.iri, DF.variable('?o')) :\n        collectedOperation;\n      if (!await this.hasSourceResults(\n        ActorQueryOperation.getOperationSource(collectedOperation)!,\n        checkOperation,\n        action.context,\n      )) {\n        emptyOperations.add(collectedOperation);\n      }\n    }));\n\n    // Only perform next mapping if we have at least one empty operation\n    if (emptyOperations.size > 0) {\n      this.logDebug(action.context, `Pruning ${emptyOperations.size} source-specific operations`);\n      // Rewrite operations by removing the empty children\n      operation = Util.mapOperation(operation, {\n        [Algebra.types.UNION](subOperation, factory) {\n          return self.mapMultiOperation(subOperation, emptyOperations, children => factory.createUnion(children));\n        },\n        [Algebra.types.ALT](subOperation, factory) {\n          return self.mapMultiOperation(subOperation, emptyOperations, children => factory.createAlt(children));\n        },\n      });\n\n      // Identify and remove projections that have become empty now due to missing variables\n      operation = Util.mapOperation(operation, {\n        [Algebra.types.PROJECT](subOperation, factory) {\n          let emptyProject = false;\n          Util.recurseOperation(subOperation, {\n            [Algebra.types.UNION](subSubOperation) {\n              if (subSubOperation.input.length === 0) {\n                emptyProject = true;\n              }\n              return true;\n            },\n            [Algebra.types.ALT](subSubOperation) {\n              if (subSubOperation.input.length === 0) {\n                emptyProject = true;\n              }\n              return true;\n            },\n          });\n\n          if (emptyProject) {\n            return {\n              recurse: false,\n              result: factory.createUnion([]),\n            };\n          }\n          return {\n            recurse: true,\n            result: subOperation,\n          };\n        },\n      });\n    }\n\n    return { operation, context: action.context };\n  }\n\n  protected collectMultiOperationInputs(\n    inputs: Algebra.Operation[],\n    collectedOperations: (Algebra.Pattern | Algebra.Link)[],\n    inputType: (Algebra.Pattern | Algebra.Link)['type'],\n  ): void {\n    for (const input of inputs) {\n      if (ActorQueryOperation.getOperationSource(input) && input.type === inputType) {\n        collectedOperations.push(input);\n      }\n    }\n  }\n\n  protected mapMultiOperation<O extends Algebra.Union | Algebra.Alt>(\n    operation: O,\n    emptyOperations: Set<Algebra.Operation>,\n    multiOperationFactory: (input: O['input']) => Algebra.Operation,\n  ): {\n      result: Algebra.Operation;\n      recurse: boolean;\n    } {\n    // Determine which operations return non-empty results\n    const nonEmptyInputs = operation.input.filter(input => !emptyOperations.has(input));\n\n    // Remove empty operations\n    if (nonEmptyInputs.length === operation.input.length) {\n      return { result: operation, recurse: true };\n    }\n    if (nonEmptyInputs.length === 0) {\n      return { result: multiOperationFactory([]), recurse: false };\n    }\n    if (nonEmptyInputs.length === 1) {\n      return { result: nonEmptyInputs[0], recurse: true };\n    }\n    return { result: multiOperationFactory(nonEmptyInputs), recurse: true };\n  }\n\n  /**\n   * Check if the given query operation will produce at least one result in the given source.\n   * @param source A query source.\n   * @param input A query operation.\n   * @param context The query context.\n   */\n  public async hasSourceResults(\n    source: IQuerySourceWrapper,\n    input: Algebra.Operation,\n    context: IActionContext,\n  ): Promise<boolean> {\n    // Traversal sources should never be considered empty at optimization time.\n    if (source.context?.get(KeysQuerySourceIdentify.traverse)) {\n      return true;\n    }\n\n    // Send an ASK query\n    if (this.useAskIfSupported) {\n      const askOperation = AF.createAsk(input);\n      if (ActorQueryOperation\n        .doesShapeAcceptOperation(await source.source.getSelectorShape(context), askOperation)) {\n        return source.source.queryBoolean(askOperation, context);\n      }\n    }\n\n    // Send the operation as-is and check the response cardinality\n    const bindingsStream = source.source.queryBindings(input, context);\n    return new Promise((resolve, reject) => {\n      bindingsStream.on('error', reject);\n      bindingsStream.getProperty('metadata', (metadata: MetadataBindings) => {\n        bindingsStream.destroy();\n        resolve(metadata.cardinality.value > 0);\n      });\n    });\n  }\n}\n\nexport interface IActorOptimizeQueryOperationPruneEmptySourceOperationsArgs extends IActorOptimizeQueryOperationArgs {\n  /**\n   * If true, ASK queries will be sent to the source instead of COUNT queries to check emptiness for patterns.\n   * This will only be done for sources that accept ASK queries.\n   * @default {false}\n   */\n  useAskIfSupported: boolean;\n}\n"]}