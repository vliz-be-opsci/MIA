"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorRdfJoinMultiBindSource = void 0;
const bus_query_operation_1 = require("@comunica/bus-query-operation");
const bus_rdf_join_1 = require("@comunica/bus-rdf-join");
const asynciterator_1 = require("asynciterator");
const sparqlalgebrajs_1 = require("sparqlalgebrajs");
const AF = new sparqlalgebrajs_1.Factory();
/**
 * A comunica Inner Multi Bind Source RDF Join Actor.
 */
class ActorRdfJoinMultiBindSource extends bus_rdf_join_1.ActorRdfJoin {
    constructor(args) {
        super(args, {
            logicalType: 'inner',
            physicalName: 'bind-source',
            canHandleUndefs: true,
        });
    }
    async getOutput(action) {
        // Order the entries so we can pick the first one (usually the one with the lowest cardinality)
        const entriesUnsorted = await bus_rdf_join_1.ActorRdfJoin.getEntriesWithMetadatas(action.entries);
        const entries = await this.sortJoinEntries(entriesUnsorted, action.context);
        this.logDebug(action.context, 'First entry for Bind Join Source: ', () => ({ entry: entries[0].operation, metadata: entries[0].metadata }));
        // Close the non-smallest streams
        for (const [i, element] of entries.entries()) {
            if (i !== 0) {
                element.output.bindingsStream.close();
            }
        }
        // Take the stream with the lowest cardinality
        const smallestStream = entries[0].output;
        const smallestMetadata = entries[0].metadata;
        const remainingEntries = [...entries];
        remainingEntries.splice(0, 1);
        // Get source for remaining entries (guaranteed thanks to prior check in getJoinCoefficients())
        const sourceWrapper = bus_query_operation_1.ActorQueryOperation.getOperationSource(remainingEntries[0].operation);
        // Determine the operation to pass
        const operation = this.createOperationFromEntries(remainingEntries);
        // Slice the smallest stream into chunks according to the block size, so we avoid blocking too long.
        const chunkedStreams = new bus_rdf_join_1.ChunkedIterator(smallestStream.bindingsStream, this.blockSize, { autoStart: false });
        // For each chunk, pass the query and the bindings to the source for execution
        const bindingsStream = new asynciterator_1.UnionIterator(chunkedStreams.map(chunk => sourceWrapper.source.queryBindings(operation, sourceWrapper.context ? action.context.merge(sourceWrapper.context) : action.context, { joinBindings: { bindings: chunk, metadata: smallestMetadata } })));
        return {
            result: {
                type: 'bindings',
                bindingsStream,
                metadata: () => this.constructResultMetadata(entries, entries.map(entry => entry.metadata), action.context),
            },
            physicalPlanMetadata: {
                bindIndex: entriesUnsorted.indexOf(entries[0]),
            },
        };
    }
    async sortJoinEntries(entries, context) {
        entries = await bus_rdf_join_1.ActorRdfJoin.sortJoinEntries(this.mediatorJoinEntriesSort, entries, context);
        // Prioritize entries with modified operations, so these are not re-executed
        entries = entries.sort((entryLeft, entryRight) => {
            if (entryLeft.operationModified && !entryRight.operationModified) {
                return -1;
            }
            return 0;
        });
        return entries;
    }
    async getJoinCoefficients(action, metadatas) {
        // Order the entries so we can pick the first one (usually the one with the lowest cardinality)
        const entries = await this.sortJoinEntries(action.entries
            .map((entry, i) => ({ ...entry, metadata: metadatas[i] })), action.context);
        metadatas = entries.map(entry => entry.metadata);
        const requestInitialTimes = bus_rdf_join_1.ActorRdfJoin.getRequestInitialTimes(metadatas);
        const requestItemTimes = bus_rdf_join_1.ActorRdfJoin.getRequestItemTimes(metadatas);
        // Determine first stream and remaining ones
        const remainingEntries = [...entries];
        const remainingRequestInitialTimes = [...requestInitialTimes];
        const remainingRequestItemTimes = [...requestItemTimes];
        remainingEntries.splice(0, 1);
        remainingRequestInitialTimes.splice(0, 1);
        remainingRequestItemTimes.splice(0, 1);
        // Reject binding on operations without sources
        const sources = remainingEntries.map(entry => bus_query_operation_1.ActorQueryOperation.getOperationSource(entry.operation));
        if (sources.some(source => !source)) {
            throw new Error(`Actor ${this.name} can not bind on remaining operations without source annotation`);
        }
        // Reject binding on operations with un-equal sources
        if (sources.some(source => source !== sources[0])) {
            throw new Error(`Actor ${this.name} can not bind on remaining operations with non-equal source annotation`);
        }
        // Reject if the source can not handle bindings
        const sourceWrapper = sources[0];
        const testingOperation = this.createOperationFromEntries(remainingEntries);
        const selectorShape = await sourceWrapper.source.getSelectorShape(action.context);
        if (!bus_query_operation_1.ActorQueryOperation
            .doesShapeAcceptOperation(selectorShape, testingOperation, { joinBindings: true })) {
            throw new Error(`Actor ${this.name} detected a source that can not handle passing down join bindings`);
        }
        // Determine selectivities of smallest entry with all other entries
        const selectivities = await Promise.all(remainingEntries
            .map(async (entry) => (await this.mediatorJoinSelectivity.mediate({
            entries: [entries[0], entry],
            context: action.context,
        })).selectivity * this.selectivityModifier));
        // Determine coefficients for remaining entries
        const cardinalityRemaining = remainingEntries
            .map((entry, i) => entry.metadata.cardinality.value * selectivities[i])
            .reduce((sum, element) => sum + element, 0);
        return {
            iterations: 1,
            persistedItems: metadatas[0].cardinality.value,
            blockingItems: metadatas[0].cardinality.value,
            requestTime: requestInitialTimes[0] + metadatas[0].cardinality.value * requestItemTimes[0] +
                requestInitialTimes[1] + cardinalityRemaining * requestItemTimes[1],
        };
    }
    createOperationFromEntries(remainingEntries) {
        if (remainingEntries.length === 1) {
            return remainingEntries[0].operation;
        }
        return AF.createJoin(remainingEntries.map(entry => entry.operation), true);
    }
}
exports.ActorRdfJoinMultiBindSource = ActorRdfJoinMultiBindSource;
//# sourceMappingURL=ActorRdfJoinMultiBindSource.js.map