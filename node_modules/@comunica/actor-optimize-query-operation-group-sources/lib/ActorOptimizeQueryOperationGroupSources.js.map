{"version":3,"file":"ActorOptimizeQueryOperationGroupSources.js","sourceRoot":"","sources":["ActorOptimizeQueryOperationGroupSources.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  IActionOptimizeQueryOperation,\n  IActorOptimizeQueryOperationOutput,\n  IActorOptimizeQueryOperationArgs,\n} from '@comunica/bus-optimize-query-operation';\nimport { ActorOptimizeQueryOperation } from '@comunica/bus-optimize-query-operation';\nimport { ActorQueryOperation } from '@comunica/bus-query-operation';\nimport type { IActorTest } from '@comunica/core';\nimport type { IActionContext, IQuerySourceWrapper } from '@comunica/types';\nimport { Algebra, Factory } from 'sparqlalgebrajs';\n\nconst AF = new Factory();\n\n/**\n * A comunica Group Sources Optimize Query Operation Actor.\n */\nexport class ActorOptimizeQueryOperationGroupSources extends ActorOptimizeQueryOperation {\n  public constructor(args: IActorOptimizeQueryOperationArgs) {\n    super(args);\n  }\n\n  public async test(action: IActionOptimizeQueryOperation): Promise<IActorTest> {\n    if (ActorQueryOperation.getOperationSource(action.operation)) {\n      throw new Error(`Actor ${this.name} does not work with top-level operation sources.`);\n    }\n    return true;\n  }\n\n  public async run(action: IActionOptimizeQueryOperation): Promise<IActorOptimizeQueryOperationOutput> {\n    return { operation: await this.groupOperation(action.operation, action.context), context: action.context };\n  }\n\n  /**\n   * Group operations belonging to the same source together, only if that source accepts the grouped operations.\n   * This grouping will be done recursively for the whole operation tree.\n   * Operations annotated with sources are considered leaves in the tree.\n   * @param operation An operation to group.\n   * @param context The action context.\n   */\n  public async groupOperation(operation: Algebra.Operation, context: IActionContext): Promise<Algebra.Operation> {\n    // Return operation as-is if the operation already has a single source, or if the operation has no children.\n    if (ActorQueryOperation.getOperationSource(operation) ?? !('input' in operation)) {\n      return operation;\n    }\n\n    // If operation has a single input, move source annotation upwards if the source can handle it.\n    if (!Array.isArray(operation.input)) {\n      const groupedInput = await this.groupOperation(operation.input, context);\n      if (groupedInput.metadata?.scopedSource) {\n        const source: IQuerySourceWrapper = ActorQueryOperation.getOperationSource(groupedInput)!;\n        if (ActorQueryOperation\n          .doesShapeAcceptOperation(await source.source.getSelectorShape(context), operation)) {\n          this.logDebug(context, `Hoist 1 source-specific operation into a single ${operation.type} operation for ${source.source.toString()}`);\n          ActorQueryOperation.removeOperationSource(groupedInput);\n          operation = ActorQueryOperation.assignOperationSource(operation, source);\n        }\n      }\n      return <Algebra.Operation> { ...operation, input: groupedInput };\n    }\n\n    // If operation has multiple inputs, cluster source annotations.\n    const inputs: Algebra.Operation[] = await Promise.all(operation.input\n      .map(subInput => this.groupOperation(subInput, context)));\n    const clusters = this.clusterOperationsWithEqualSources(inputs);\n\n    // If we just have a single cluster, move the source annotation upwards\n    if (clusters.length === 1) {\n      const newInputs = clusters[0];\n      const source = ActorQueryOperation.getOperationSource(clusters[0][0])!;\n      return <Algebra.Operation> {\n        ...await this.moveSourceAnnotationUpwardsIfPossible(operation, newInputs, source, context),\n        input: newInputs,\n      };\n    }\n\n    // If the number of clusters is equal to the number of original inputs, do nothing.\n    if (clusters.length === inputs.length) {\n      return <Algebra.Operation> { ...operation, input: inputs };\n    }\n\n    // If we have multiple clusters, created nested multi-operations\n    let multiFactoryMethod: (children: Algebra.Operation[], flatten: boolean) => Algebra.Operation;\n    switch (operation.type) {\n      case Algebra.types.JOIN:\n        multiFactoryMethod = AF.createJoin.bind(AF);\n        break;\n      case Algebra.types.UNION:\n        multiFactoryMethod = AF.createUnion.bind(AF);\n        break;\n      case Algebra.types.ALT:\n        multiFactoryMethod = <any> AF.createAlt.bind(AF);\n        break;\n      case Algebra.types.SEQ:\n        multiFactoryMethod = <any> AF.createSeq.bind(AF);\n        break;\n      default:\n        // While LeftJoin and Minus are also multi-operations,\n        // these can never occur because they only have 2 inputs,\n        // so these cases will always be captured by one of the 2 if-cases above\n        // (clusters.length === 1 or clusters.length === input.length)\n\n        // In all other cases, error\n        throw new Error(`Unsupported operation '${operation.type}' detected while grouping sources`);\n    }\n    return await this.groupOperationMulti(clusters, multiFactoryMethod, context);\n  }\n\n  protected async groupOperationMulti(\n    clusters: Algebra.Operation[][],\n    factoryMethod: (children: Algebra.Operation[], flatten: boolean) => Algebra.Operation,\n    context: IActionContext,\n  ): Promise<Algebra.Operation> {\n    let flatten = true;\n    const nestedMerges = await Promise.all(clusters.map(async(cluster) => {\n      const source = ActorQueryOperation.getOperationSource(cluster[0])!;\n      const merged = await this\n        .moveSourceAnnotationUpwardsIfPossible(factoryMethod(cluster, true), cluster, source, context);\n      if (ActorQueryOperation.getOperationSource(merged)) {\n        flatten = false;\n      }\n      return merged;\n    }));\n    return factoryMethod(nestedMerges, flatten);\n  }\n\n  /**\n   * Cluster the given operations by equal source annotations.\n   * @param operationsIn An array of operations to cluster.\n   */\n  public clusterOperationsWithEqualSources(operationsIn: Algebra.Operation[]): Algebra.Operation[][] {\n    // Operations can have a source, or no source at all\n    const sourceOperations: Map<IQuerySourceWrapper, Algebra.Operation[]> = new Map();\n    const sourcelessOperations: Algebra.Operation[] = [];\n\n    // Cluster by source\n    for (const operation of operationsIn) {\n      const source: IQuerySourceWrapper = ActorQueryOperation.getOperationSource(operation)!;\n      if (source) {\n        if (!sourceOperations.has(source)) {\n          sourceOperations.set(source, []);\n        }\n        sourceOperations.get(source)!.push(operation);\n      } else {\n        sourcelessOperations.push(operation);\n      }\n    }\n\n    // Return clusters\n    const clusters: Algebra.Operation[][] = [];\n    if (sourcelessOperations.length > 0) {\n      clusters.push(sourcelessOperations);\n    }\n    for (const [ source, operations ] of sourceOperations.entries()) {\n      clusters.push(operations\n        .map(operation => ActorQueryOperation.assignOperationSource(operation, source)));\n    }\n    return clusters;\n  }\n\n  /**\n   * If the given source accepts the grouped operation, annotate the grouped operation with the source,\n   * and remove the source annotation from the seperate input operations.\n   * Otherwise, return the grouped operation unchanged.\n   * @param operation A grouped operation consisting of all given input operations.\n   * @param inputs An array of operations that share the same source annotation.\n   * @param source The common source.\n   * @param context The action context.\n   */\n  public async moveSourceAnnotationUpwardsIfPossible<O extends Algebra.Operation>(\n    operation: O,\n    inputs: Algebra.Operation[],\n    source: IQuerySourceWrapper | undefined,\n    context: IActionContext,\n  ): Promise<O> {\n    if (source && ActorQueryOperation\n      .doesShapeAcceptOperation(await source.source.getSelectorShape(context), operation)) {\n      this.logDebug(context, `Hoist ${inputs.length} source-specific operations into a single ${operation.type} operation for ${source.source.toString()}`);\n      operation = ActorQueryOperation.assignOperationSource(operation, source);\n      for (const input of inputs) {\n        ActorQueryOperation.removeOperationSource(input);\n      }\n    }\n    return operation;\n  }\n}\n"]}