"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorOptimizeQueryOperationSetSeedSourcesQuadpatternIris = void 0;
const bus_optimize_query_operation_1 = require("@comunica/bus-optimize-query-operation");
const context_entries_1 = require("@comunica/context-entries");
const core_1 = require("@comunica/core");
const sparqlalgebrajs_1 = require("sparqlalgebrajs");
/**
 * A comunica Set Seed Sources Quadpattern IRIs Optimize Query Operation Actor.
 */
class ActorOptimizeQueryOperationSetSeedSourcesQuadpatternIris extends bus_optimize_query_operation_1.ActorOptimizeQueryOperation {
    constructor(args) {
        super(args);
    }
    async test(_action) {
        return true;
    }
    async run(action) {
        let sources = action.context.get(context_entries_1.KeysQueryOperation.querySources);
        if (!sources || sources.length === 0) {
            sources = await Promise.all([...new Set(this.extractIrisFromOperation(action.operation))]
                .map(async (source) => {
                // Remove fragment from URL
                const hashPosition = source.indexOf('#');
                if (hashPosition >= 0) {
                    source = source.slice(0, hashPosition);
                }
                return (await this.mediatorQuerySourceIdentify.mediate({
                    querySourceUnidentified: {
                        value: source,
                        context: new core_1.ActionContext().set(context_entries_1.KeysQuerySourceIdentify.traverse, true),
                    },
                    context: action.context,
                })).querySource;
            }));
            action.context = action.context.set(context_entries_1.KeysQueryOperation.querySources, sources);
        }
        return { ...action, context: action.context };
    }
    extractIrisFromOperation(operation) {
        const iris = [];
        sparqlalgebrajs_1.Util.recurseOperation(operation, {
            [sparqlalgebrajs_1.Algebra.types.PATH]: (path) => {
                if (this.extractSubjects && path.subject.termType === 'NamedNode') {
                    iris.push(path.subject.value);
                }
                // Predicates are ignored
                if (this.extractObjects && path.object.termType === 'NamedNode') {
                    iris.push(path.object.value);
                }
                if (this.extractGraphs && path.graph.termType === 'NamedNode') {
                    iris.push(path.graph.value);
                }
                return false;
            },
            [sparqlalgebrajs_1.Algebra.types.PATTERN]: (pattern) => {
                if (this.extractSubjects && pattern.subject.termType === 'NamedNode') {
                    iris.push(pattern.subject.value);
                }
                if (this.extractPredicates && pattern.predicate.termType === 'NamedNode') {
                    iris.push(pattern.predicate.value);
                }
                if (this.extractObjects && pattern.object.termType === 'NamedNode' &&
                    (this.extractVocabIris || pattern.predicate.value !== 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type')) {
                    iris.push(pattern.object.value);
                }
                if (this.extractGraphs && pattern.graph.termType === 'NamedNode') {
                    iris.push(pattern.graph.value);
                }
                return false;
            },
        });
        return iris;
    }
}
exports.ActorOptimizeQueryOperationSetSeedSourcesQuadpatternIris = ActorOptimizeQueryOperationSetSeedSourcesQuadpatternIris;
//# sourceMappingURL=ActorOptimizeQueryOperationSetSeedSourcesQuadpatternIris.js.map