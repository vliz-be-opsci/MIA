{"version":3,"file":"ActorOptimizeQueryOperationSetSeedSourcesQuadpatternIris.js","sourceRoot":"","sources":["ActorOptimizeQueryOperationSetSeedSourcesQuadpatternIris.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  IActionOptimizeQueryOperation,\n  IActorOptimizeQueryOperationOutput,\n} from '@comunica/bus-optimize-query-operation';\nimport { ActorOptimizeQueryOperation } from '@comunica/bus-optimize-query-operation';\nimport type { MediatorQuerySourceIdentify } from '@comunica/bus-query-source-identify';\nimport { KeysQueryOperation, KeysQuerySourceIdentify } from '@comunica/context-entries';\nimport type { IActorArgs, IActorTest } from '@comunica/core';\nimport { ActionContext } from '@comunica/core';\nimport type { IQuerySourceWrapper } from '@comunica/types';\nimport { Algebra, Util } from 'sparqlalgebrajs';\n\n/**\n * A comunica Set Seed Sources Quadpattern IRIs Optimize Query Operation Actor.\n */\nexport class ActorOptimizeQueryOperationSetSeedSourcesQuadpatternIris extends ActorOptimizeQueryOperation {\n  public readonly mediatorQuerySourceIdentify: MediatorQuerySourceIdentify;\n  private readonly extractSubjects: boolean;\n  private readonly extractPredicates: boolean;\n  private readonly extractObjects: boolean;\n  private readonly extractGraphs: boolean;\n  private readonly extractVocabIris: boolean;\n\n  public constructor(args: IActorOptimizeQueryOperationSetSeedSourcesQuadpatternIrisArgs) {\n    super(args);\n  }\n\n  public async test(_action: IActionOptimizeQueryOperation): Promise<IActorTest> {\n    return true;\n  }\n\n  public async run(action: IActionOptimizeQueryOperation): Promise<IActorOptimizeQueryOperationOutput> {\n    let sources: IQuerySourceWrapper[] | undefined = action.context.get(KeysQueryOperation.querySources);\n    if (!sources || sources.length === 0) {\n      sources = await Promise.all(\n        [ ...new Set(this.extractIrisFromOperation(action.operation)) ]\n          .map(async(source) => {\n            // Remove fragment from URL\n            const hashPosition = source.indexOf('#');\n            if (hashPosition >= 0) {\n              source = source.slice(0, hashPosition);\n            }\n\n            return (await this.mediatorQuerySourceIdentify.mediate({\n              querySourceUnidentified: {\n                value: source,\n                context: new ActionContext().set(KeysQuerySourceIdentify.traverse, true),\n              },\n              context: action.context,\n            })).querySource;\n          }),\n      );\n      action.context = action.context.set(KeysQueryOperation.querySources, sources);\n    }\n    return { ...action, context: action.context };\n  }\n\n  public extractIrisFromOperation(operation: Algebra.Operation): string[] {\n    const iris: string[] = [];\n    Util.recurseOperation(operation, {\n      [Algebra.types.PATH]: (path) => {\n        if (this.extractSubjects && path.subject.termType === 'NamedNode') {\n          iris.push(path.subject.value);\n        }\n        // Predicates are ignored\n        if (this.extractObjects && path.object.termType === 'NamedNode') {\n          iris.push(path.object.value);\n        }\n        if (this.extractGraphs && path.graph.termType === 'NamedNode') {\n          iris.push(path.graph.value);\n        }\n        return false;\n      },\n      [Algebra.types.PATTERN]: (pattern) => {\n        if (this.extractSubjects && pattern.subject.termType === 'NamedNode') {\n          iris.push(pattern.subject.value);\n        }\n        if (this.extractPredicates && pattern.predicate.termType === 'NamedNode') {\n          iris.push(pattern.predicate.value);\n        }\n        if (this.extractObjects && pattern.object.termType === 'NamedNode' &&\n          (this.extractVocabIris || pattern.predicate.value !== 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type')) {\n          iris.push(pattern.object.value);\n        }\n        if (this.extractGraphs && pattern.graph.termType === 'NamedNode') {\n          iris.push(pattern.graph.value);\n        }\n        return false;\n      },\n    });\n    return iris;\n  }\n}\n\nexport interface IActorOptimizeQueryOperationSetSeedSourcesQuadpatternIrisArgs\n  extends IActorArgs<IActionOptimizeQueryOperation, IActorTest, IActorOptimizeQueryOperationOutput> {\n  /**\n   * Mediator for identifying query sources.\n   */\n  mediatorQuerySourceIdentify: MediatorQuerySourceIdentify;\n  /**\n   * If IRIs should be extracted from subject positions.\n   * @default {true}\n   */\n  extractSubjects: boolean;\n  /**\n   * If IRIs should be extracted from predicate positions.\n   * @default {false}\n   */\n  extractPredicates: boolean;\n  /**\n   * If IRIs should be extracted from object positions.\n   * @default {true}\n   */\n  extractObjects: boolean;\n  /**\n   * If IRIs should be extracted from graph positions.\n   * @default {true}\n   */\n  extractGraphs: boolean;\n  /**\n   * If object IRIs should be extracted if the predicate is rdf:type.\n   * @default {false}\n   */\n  extractVocabIris: boolean;\n}\n"]}