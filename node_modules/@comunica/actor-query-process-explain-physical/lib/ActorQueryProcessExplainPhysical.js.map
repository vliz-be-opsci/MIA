{"version":3,"file":"ActorQueryProcessExplainPhysical.js","sourceRoot":"","sources":["ActorQueryProcessExplainPhysical.ts"],"names":[],"mappings":";;;AAMA,mEAEqC;AACrC,+DAA0D;AAE1D,yCAAkD;AAClD,mFAAgF;AAEhF;;GAEG;AACH,MAAa,gCAAiC,SAAQ,qCAAiB;IAGrE,YAAmB,IAA2C;QAC5D,KAAK,CAAC,IAAI,CAAC,CAAC;IACd,CAAC;IAEM,KAAK,CAAC,IAAI,CAAC,MAA2B;QAC3C,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,+BAAa,CAAC,OAAO,CAAC;YAC5C,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,uBAAgB,CAAC,SAAS,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE,CAAC;YACtE,MAAM,IAAI,KAAK,CAAC,GAAG,IAAI,CAAC,IAAI,uCAAuC,CAAC,CAAC;QACvE,CAAC;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IAEM,KAAK,CAAC,GAAG,CAAC,MAA2B;QAC1C,6CAA6C;QAE7C,IAAI,EAAE,SAAS,EAAE,OAAO,EAAE,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,OAAO,CAAC,CAAC;QAC3F,CAAC,EAAE,SAAS,EAAE,OAAO,EAAE,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC,CAAC;QAElF,iHAAiH;QACjH,MAAM,uBAAuB,GAAG,IAAI,6DAA6B,EAAE,CAAC;QACpE,OAAO,GAAG,OAAO,CAAC,GAAG,CAAC,+BAAa,CAAC,uBAAuB,EAAE,uBAAuB,CAAC,CAAC;QAEtF,MAAM,MAAM,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,SAAS,EAAE,OAAO,CAAC,CAAC;QAEtE,yCAAyC;QACzC,QAAQ,MAAM,CAAC,IAAI,EAAE,CAAC;YACpB,KAAK,UAAU;gBACb,MAAM,MAAM,CAAC,cAAc,CAAC,OAAO,EAAE,CAAC;gBACtC,MAAM;YACR,KAAK,OAAO;gBACV,MAAM,MAAM,CAAC,UAAU,CAAC,OAAO,EAAE,CAAC;gBAClC,MAAM;YACR,KAAK,SAAS;gBACZ,MAAM,MAAM,CAAC,OAAO,EAAE,CAAC;gBACvB,MAAM;YACR,KAAK,MAAM;gBACT,MAAM,MAAM,CAAC,OAAO,EAAE,CAAC;gBACvB,MAAM;QACV,CAAC;QAED,OAAO;YACL,MAAM,EAAE;gBACN,OAAO,EAAE,IAAI;gBACb,IAAI,EAAE,UAAU;gBAChB,IAAI,EAAE,uBAAuB,CAAC,MAAM,EAAE;aACvC;SACF,CAAC;IACJ,CAAC;CACF;AAnDD,4EAmDC","sourcesContent":["import type {\n  IActionQueryProcess,\n  IActorQueryProcessOutput,\n  IActorQueryProcessArgs,\n  IQueryProcessSequential,\n} from '@comunica/bus-query-process';\nimport {\n  ActorQueryProcess,\n} from '@comunica/bus-query-process';\nimport { KeysInitQuery } from '@comunica/context-entries';\nimport type { IActorTest } from '@comunica/core';\nimport { ActionContextKey } from '@comunica/core';\nimport { MemoryPhysicalQueryPlanLogger } from './MemoryPhysicalQueryPlanLogger';\n\n/**\n * A comunica Explain Physical Query Process Actor.\n */\nexport class ActorQueryProcessExplainPhysical extends ActorQueryProcess {\n  public readonly queryProcessor: IQueryProcessSequential;\n\n  public constructor(args: IActorQueryProcessExplainPhysicalArgs) {\n    super(args);\n  }\n\n  public async test(action: IActionQueryProcess): Promise<IActorTest> {\n    if ((action.context.get(KeysInitQuery.explain) ||\n      action.context.get(new ActionContextKey('explain'))) !== 'physical') {\n      throw new Error(`${this.name} can only explain in 'physical' mode.`);\n    }\n    return true;\n  }\n\n  public async run(action: IActionQueryProcess): Promise<IActorQueryProcessOutput> {\n    // Run all query processing steps in sequence\n\n    let { operation, context } = await this.queryProcessor.parse(action.query, action.context);\n    ({ operation, context } = await this.queryProcessor.optimize(operation, context));\n\n    // If we need a physical query plan, store a physical query plan logger in the context, and collect it after exec\n    const physicalQueryPlanLogger = new MemoryPhysicalQueryPlanLogger();\n    context = context.set(KeysInitQuery.physicalQueryPlanLogger, physicalQueryPlanLogger);\n\n    const output = await this.queryProcessor.evaluate(operation, context);\n\n    // Make sure the whole result is produced\n    switch (output.type) {\n      case 'bindings':\n        await output.bindingsStream.toArray();\n        break;\n      case 'quads':\n        await output.quadStream.toArray();\n        break;\n      case 'boolean':\n        await output.execute();\n        break;\n      case 'void':\n        await output.execute();\n        break;\n    }\n\n    return {\n      result: {\n        explain: true,\n        type: 'physical',\n        data: physicalQueryPlanLogger.toJson(),\n      },\n    };\n  }\n}\n\nexport interface IActorQueryProcessExplainPhysicalArgs extends IActorQueryProcessArgs {\n  queryProcessor: IQueryProcessSequential;\n}\n"]}