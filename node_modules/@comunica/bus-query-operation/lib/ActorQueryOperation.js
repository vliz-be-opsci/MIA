"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorQueryOperation = void 0;
const context_entries_1 = require("@comunica/context-entries");
const core_1 = require("@comunica/core");
const data_factory_1 = require("@comunica/data-factory");
const Bindings_1 = require("./Bindings");
/**
 * A counter that keeps track blank node generated through BNODE() SPARQL
 * expressions.
 *
 * @type {number}
 */
let bnodeCounter = 0;
/**
 * A comunica actor for query-operation events.
 *
 * Actor types:
 * * Input:  IActionQueryOperation:      A SPARQL Algebra operation.
 * * Test:   <none>
 * * Output: IActorQueryOperationOutput: A bindings stream.
 *
 * @see IActionQueryOperation
 * @see IQueryOperationResult
 */
class ActorQueryOperation extends core_1.Actor {
    /**
     * @param args - @defaultNested {<default_bus> a <cbqo:components/BusQueryOperation.jsonld#BusQueryOperation>} bus
     */
    constructor(args) {
        super(args);
    }
    /**
     * Safely cast a query operation output to a bindings output.
     * This will throw a runtime error if the output is of the incorrect type.
     * @param {IQueryOperationResult} output A query operation output.
     * @return {IQueryOperationResultBindings} A bindings query operation output.
     */
    static getSafeBindings(output) {
        ActorQueryOperation.validateQueryOutput(output, 'bindings');
        return output;
    }
    /**
     * Safely cast a query operation output to a quads output.
     * This will throw a runtime error if the output is of the incorrect type.
     * @param {IQueryOperationResult} output A query operation output.
     * @return {IQueryOperationResultQuads} A quads query operation output.
     */
    static getSafeQuads(output) {
        ActorQueryOperation.validateQueryOutput(output, 'quads');
        return output;
    }
    /**
     * Safely cast a query operation output to a boolean output.
     * This will throw a runtime error if the output is of the incorrect type.
     * @param {IQueryOperationResult} output A query operation output.
     * @return {IQueryOperationResultBoolean} A boolean query operation output.
     */
    static getSafeBoolean(output) {
        ActorQueryOperation.validateQueryOutput(output, 'boolean');
        return output;
    }
    /**
     * Safely cast a query operation output to a void output.
     * This will throw a runtime error if the output is of the incorrect type.
     * @param {IQueryOperationResult} output A query operation output.
     * @return {IQueryOperationResultVoid} A void query operation output.
     */
    static getSafeVoid(output) {
        ActorQueryOperation.validateQueryOutput(output, 'void');
        return output;
    }
    /**
     * Throw an error if the output type does not match the expected type.
     * @param {IQueryOperationResult} output A query operation output.
     * @param {string} expectedType The expected output type.
     */
    static validateQueryOutput(output, expectedType) {
        if (output.type !== expectedType) {
            throw new Error(`Invalid query output type: Expected '${expectedType}' but got '${output.type}'`);
        }
    }
    static getBaseExpressionContext(context) {
        const now = context.get(context_entries_1.KeysInitQuery.queryTimestamp);
        const baseIRI = context.get(context_entries_1.KeysInitQuery.baseIRI);
        const functionArgumentsCache = context.get(context_entries_1.KeysInitQuery.functionArgumentsCache) ?? {};
        // Handle two variants of providing extension functions
        if (context.has(context_entries_1.KeysInitQuery.extensionFunctionCreator) && context.has(context_entries_1.KeysInitQuery.extensionFunctions)) {
            throw new Error('Illegal simultaneous usage of extensionFunctionCreator and extensionFunctions in context');
        }
        let extensionFunctionCreator = context
            .get(context_entries_1.KeysInitQuery.extensionFunctionCreator);
        // Convert dictionary-based variant to callback
        const extensionFunctions = context
            .get(context_entries_1.KeysInitQuery.extensionFunctions);
        if (extensionFunctions) {
            extensionFunctionCreator = functionNamedNode => extensionFunctions[functionNamedNode.value];
        }
        return { now, baseIRI, extensionFunctionCreator, functionArgumentsCache };
    }
    /**
     * Create an options object that can be used to construct a expression-evaluator synchronous evaluator.
     * @param context An action context.
     * @param _mediatorQueryOperation An optional query query operation mediator.
     *                                If defined, the existence resolver will be defined as `exists`.
     */
    static getExpressionContext(context, _mediatorQueryOperation) {
        return {
            ...this.getBaseExpressionContext(context),
            bnode: (input) => new data_factory_1.BlankNodeBindingsScoped(input ?? `BNODE_${bnodeCounter++}`),
        };
    }
    /**
     * Create an options object that can be used to construct a expression-evaluator asynchronous evaluator.
     * @param context An action context.
     * @param mediatorQueryOperation A query query operation mediator for resolving `exists`.
     * @param bindingsFactory The bindings factory.
     */
    static getAsyncExpressionContext(context, mediatorQueryOperation, bindingsFactory) {
        return {
            ...this.getBaseExpressionContext(context),
            bnode: (input) => Promise.resolve(new data_factory_1.BlankNodeBindingsScoped(input ?? `BNODE_${bnodeCounter++}`)),
            exists: ActorQueryOperation.createExistenceResolver(context, mediatorQueryOperation, bindingsFactory),
        };
    }
    /**
     * Create an existence resolver for usage within an expression context.
     * @param context An action context.
     * @param mediatorQueryOperation A query operation mediator.
     * @param bindingsFactory The bindings factory.
     */
    static createExistenceResolver(context, mediatorQueryOperation, bindingsFactory) {
        return async (expr, bindings) => {
            const operation = (0, Bindings_1.materializeOperation)(expr.input, bindings, bindingsFactory);
            const outputRaw = await mediatorQueryOperation.mediate({ operation, context });
            const output = ActorQueryOperation.getSafeBindings(outputRaw);
            return expr.not !== ((await output.bindingsStream.take(1).toArray()).length === 1);
        };
    }
    /**
     * Throw an error if the context contains the readOnly flag.
     * @param context An action context.
     */
    static throwOnReadOnly(context) {
        if (context.get(context_entries_1.KeysQueryOperation.readOnly)) {
            throw new Error(`Attempted a write operation in read-only mode`);
        }
    }
    /**
     * Obtain the query source attached to the given operation.
     * @param operation An algebra operation.
     */
    static getOperationSource(operation) {
        return operation.metadata?.scopedSource;
    }
    /**
     * Assign a source wrapper to the given operation.
     * The operation is copied and returned.
     * @param operation An operation.
     * @param source A source wrapper.
     */
    static assignOperationSource(operation, source) {
        operation = { ...operation };
        operation.metadata = operation.metadata ? { ...operation.metadata } : {};
        operation.metadata.scopedSource = source;
        return operation;
    }
    /**
     * Remove the source wrapper from the given operation.
     * The operation is mutated.
     * @param operation An operation.
     */
    static removeOperationSource(operation) {
        delete operation.metadata?.scopedSource;
        if (operation.metadata && Object.keys(operation.metadata).length === 0) {
            delete operation.metadata;
        }
    }
    /**
     * Check if the given shape accepts the given query operation.
     * @param shape A shape to test the query operation against.
     * @param operation A query operation to test.
     * @param options Additional options to consider.
     * @param options.joinBindings If additional bindings will be pushed down to the source for joining.
     * @param options.filterBindings If additional bindings will be pushed down to the source for filtering.
     */
    static doesShapeAcceptOperation(shape, operation, options) {
        if (shape.type === 'conjunction') {
            return shape.children.every(child => ActorQueryOperation.doesShapeAcceptOperation(child, operation, options));
        }
        if (shape.type === 'disjunction') {
            return shape.children.some(child => ActorQueryOperation.doesShapeAcceptOperation(child, operation, options));
        }
        if (shape.type === 'arity') {
            return ActorQueryOperation.doesShapeAcceptOperation(shape.child, operation, options);
        }
        if ((options?.joinBindings && !shape.joinBindings) ?? (options?.filterBindings && !shape.filterBindings)) {
            return false;
        }
        if (shape.operation.operationType === 'type') {
            return shape.operation.type === 'project' || shape.operation.type === operation.type;
        }
        return shape.operation.pattern.type === operation.type;
    }
}
exports.ActorQueryOperation = ActorQueryOperation;
//# sourceMappingURL=ActorQueryOperation.js.map