{"version":3,"file":"Bindings.js","sourceRoot":"","sources":["Bindings.ts"],"names":[],"mappings":"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","sourcesContent":["import type { BindingsFactory } from '@comunica/bindings-factory';\nimport type { Bindings } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport { DataFactory } from 'rdf-data-factory';\nimport { termToString } from 'rdf-string';\nimport { mapTermsNested, someTermsNested } from 'rdf-terms';\nimport type { Algebra, Factory } from 'sparqlalgebrajs';\nimport { Util } from 'sparqlalgebrajs';\n\nconst DF = new DataFactory();\n\nconst TRUE = DF.literal('true', DF.namedNode('http://www.w3.org/2001/XMLSchema#boolean'));\n\n/**\n * Materialize a term with the given binding.\n *\n * If the given term is a variable,\n * and that variable exist in the given bindings object,\n * the value of that binding is returned.\n * In all other cases, the term itself is returned.\n *\n * @param {RDF.Term} term A term.\n * @param {Bindings} bindings A bindings object.\n * @return {RDF.Term} The materialized term.\n */\nexport function materializeTerm(term: RDF.Term, bindings: Bindings): RDF.Term {\n  if (term.termType === 'Variable') {\n    const value = bindings.get(term);\n    if (value) {\n      return value;\n    }\n  }\n  if (term.termType === 'Quad' && someTermsNested(term, value => value.termType === 'Variable')) {\n    return mapTermsNested(term, subTerm => materializeTerm(subTerm, bindings));\n  }\n  return term;\n}\n\n/**\n * Materialize the given operation (recursively) with the given bindings.\n * Essentially, all variables in the given operation will be replaced\n * by the terms bound to the variables in the given bindings.\n * @param {Algebra.Operation} operation SPARQL algebra operation.\n * @param {Bindings} bindings A bindings object.\n * @param bindingsFactory The bindings factory.\n * @param options Options for materializations.\n * @param options.strictTargetVariables If target variable bindings (such as on SELECT or BIND) should not be allowed.\n * @param options.bindFilter If filter expressions should be materialized\n * @return Algebra.Operation A new operation materialized with the given bindings.\n */\nexport function materializeOperation(\n  operation: Algebra.Operation,\n  bindings: Bindings,\n  bindingsFactory: BindingsFactory,\n  options: {\n    strictTargetVariables?: boolean;\n    bindFilter?: boolean;\n  } = {},\n): Algebra.Operation {\n  options = {\n    strictTargetVariables: 'strictTargetVariables' in options ? options.strictTargetVariables : false,\n    bindFilter: 'bindFilter' in options ? options.bindFilter : true,\n  };\n\n  return Util.mapOperation(operation, {\n    path(op: Algebra.Path, factory: Factory) {\n      // Materialize variables in a path expression.\n      // The predicate expression will be recursed.\n      return {\n        recurse: false,\n        result: Object.assign(factory.createPath(\n          materializeTerm(op.subject, bindings),\n          op.predicate,\n          materializeTerm(op.object, bindings),\n          materializeTerm(op.graph, bindings),\n        ), { metadata: op.metadata }),\n      };\n    },\n    pattern(op: Algebra.Pattern, factory: Factory) {\n      // Materialize variables in the quad pattern.\n      return {\n        recurse: false,\n        result: Object.assign(factory.createPattern(\n          materializeTerm(op.subject, bindings),\n          materializeTerm(op.predicate, bindings),\n          materializeTerm(op.object, bindings),\n          materializeTerm(op.graph, bindings),\n        ), { metadata: op.metadata }),\n      };\n    },\n    extend(op: Algebra.Extend) {\n      // Materialize an extend operation.\n      // If strictTargetVariables is true, we throw if the extension target variable is attempted to be bound.\n      // Otherwise, we remove the extend operation.\n      if (bindings.has(op.variable)) {\n        if (options.strictTargetVariables) {\n          throw new Error(`Tried to bind variable ${termToString(op.variable)} in a BIND operator.`);\n        } else {\n          return {\n            recurse: true,\n            result: materializeOperation(op.input, bindings, bindingsFactory, options),\n          };\n        }\n      }\n      return {\n        recurse: true,\n        result: op,\n      };\n    },\n    group(op: Algebra.Group, factory: Factory) {\n      // Materialize a group operation.\n      // If strictTargetVariables is true, we throw if the group target variable is attempted to be bound.\n      // Otherwise, we just filter out the bound variables.\n      if (options.strictTargetVariables) {\n        for (const variable of op.variables) {\n          if (bindings.has(variable)) {\n            throw new Error(`Tried to bind variable ${termToString(variable)} in a GROUP BY operator.`);\n          }\n        }\n        return {\n          recurse: true,\n          result: op,\n        };\n      }\n      const variables = op.variables.filter(variable => !bindings.has(variable));\n      return {\n        recurse: true,\n        result: factory.createGroup(\n          op.input,\n          variables,\n          op.aggregates,\n        ),\n      };\n    },\n    project(op: Algebra.Project, factory: Factory) {\n      // Materialize a project operation.\n      // If strictTargetVariables is true, we throw if the project target variable is attempted to be bound.\n      // Otherwise, we just filter out the bound variables.\n      if (options.strictTargetVariables) {\n        for (const variable of op.variables) {\n          if (bindings.has(variable)) {\n            throw new Error(`Tried to bind variable ${termToString(variable)} in a SELECT operator.`);\n          }\n        }\n        return {\n          recurse: true,\n          result: op,\n        };\n      }\n\n      const variables = op.variables.filter(variable => !bindings.has(variable));\n\n      // Only include projected variables in the sub-bindings that will be passed down recursively.\n      // If we don't do this, we may be binding variables that may have the same label, but are not considered equal.\n      const subBindings = bindingsFactory.bindings(<[RDF.Variable, RDF.Term][]> op.variables.map((variable) => {\n        const binding = bindings.get(variable);\n        if (binding) {\n          return [ variable, binding ];\n        }\n        // eslint-disable-next-line no-useless-return,array-callback-return\n        return;\n      }).filter(Boolean));\n\n      return {\n        recurse: false,\n        result: factory.createProject(\n          materializeOperation(\n            op.input,\n            subBindings,\n            bindingsFactory,\n            options,\n          ),\n          variables,\n        ),\n      };\n    },\n    values(op: Algebra.Values, factory: Factory) {\n      // Materialize a values operation.\n      // If strictTargetVariables is true, we throw if the values target variable is attempted to be bound.\n      // Otherwise, we just filter out the bound variables and their bindings.\n      if (options.strictTargetVariables) {\n        for (const variable of op.variables) {\n          if (bindings.has(variable)) {\n            throw new Error(`Tried to bind variable ${termToString(variable)} in a VALUES operator.`);\n          }\n        }\n      } else {\n        const variables = op.variables.filter(variable => !bindings.has(variable));\n        const valueBindings: Record<string, RDF.Literal | RDF.NamedNode>[] = <any> op.bindings.map((binding) => {\n          const newBinding = { ...binding };\n          let valid = true;\n          // eslint-disable-next-line unicorn/no-array-for-each\n          bindings.forEach((value: RDF.Term, key: RDF.Variable) => {\n            const keyString = termToString(key);\n            if (keyString in newBinding) {\n              if (!value.equals(newBinding[keyString])) {\n                // If the value of the binding is not equal, remove this binding completely from the VALUES clause\n                valid = false;\n              }\n              delete newBinding[keyString];\n            }\n          });\n          return valid ? newBinding : undefined;\n        }).filter(Boolean);\n        return {\n          recurse: true,\n          result: factory.createValues(\n            variables,\n            valueBindings,\n          ),\n        };\n      }\n      return {\n        recurse: false,\n        result: op,\n      };\n    },\n    expression(op: Algebra.Expression, factory: Factory) {\n      if (!options.bindFilter) {\n        return {\n          recurse: false,\n          result: op,\n        };\n      }\n\n      if (op.expressionType === 'term') {\n        // Materialize a term expression\n        return {\n          recurse: false,\n          result: factory.createTermExpression(materializeTerm(op.term, bindings)),\n        };\n      }\n      if (op.expressionType === 'operator') {\n        if (op.operator === 'bound' && op.args.length === 1 && op.args[0].expressionType === 'term' &&\n          [ ...bindings.keys() ].some(variable => op.args[0].term.equals(variable))) {\n          return {\n            recurse: false,\n            result: factory.createTermExpression(TRUE),\n          };\n        }\n        return {\n          recurse: true,\n          result: op,\n        };\n      }\n      if (op.expressionType === 'aggregate' &&\n        'variable' in op &&\n        bindings.has(<RDF.Variable> op.variable)) {\n        // Materialize a bound aggregate operation.\n        // If strictTargetVariables is true, we throw if the expression target variable is attempted to be bound.\n        // Otherwise, we ignore this operation.\n        if (options.strictTargetVariables) {\n          throw new Error(`Tried to bind ${termToString(op.variable)} in a ${op.aggregator} aggregate.`);\n        } else {\n          return {\n            recurse: true,\n            result: op,\n          };\n        }\n      }\n      return {\n        recurse: true,\n        result: op,\n      };\n    },\n  });\n}\n"]}