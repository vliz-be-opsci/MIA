import type { BindingsFactory } from '@comunica/bindings-factory';
import type { IActorArgs, IActorTest, IAction, Mediate } from '@comunica/core';
import { Actor } from '@comunica/core';
import type { IQueryOperationResult, IQueryOperationResultBindings, IQueryOperationResultBoolean, IQueryOperationResultQuads, IQueryOperationResultVoid, Bindings, IActionContext, FunctionArgumentsCache, IQuerySourceWrapper, FragmentSelectorShape } from '@comunica/types';
import type * as RDF from '@rdfjs/types';
import type { Algebra } from 'sparqlalgebrajs';
/**
 * A comunica actor for query-operation events.
 *
 * Actor types:
 * * Input:  IActionQueryOperation:      A SPARQL Algebra operation.
 * * Test:   <none>
 * * Output: IActorQueryOperationOutput: A bindings stream.
 *
 * @see IActionQueryOperation
 * @see IQueryOperationResult
 */
export declare abstract class ActorQueryOperation extends Actor<IActionQueryOperation, IActorTest, IQueryOperationResult> {
    /**
     * @param args - @defaultNested {<default_bus> a <cbqo:components/BusQueryOperation.jsonld#BusQueryOperation>} bus
     */
    protected constructor(args: IActorQueryOperationArgs);
    /**
     * Safely cast a query operation output to a bindings output.
     * This will throw a runtime error if the output is of the incorrect type.
     * @param {IQueryOperationResult} output A query operation output.
     * @return {IQueryOperationResultBindings} A bindings query operation output.
     */
    static getSafeBindings(output: IQueryOperationResult): IQueryOperationResultBindings;
    /**
     * Safely cast a query operation output to a quads output.
     * This will throw a runtime error if the output is of the incorrect type.
     * @param {IQueryOperationResult} output A query operation output.
     * @return {IQueryOperationResultQuads} A quads query operation output.
     */
    static getSafeQuads(output: IQueryOperationResult): IQueryOperationResultQuads;
    /**
     * Safely cast a query operation output to a boolean output.
     * This will throw a runtime error if the output is of the incorrect type.
     * @param {IQueryOperationResult} output A query operation output.
     * @return {IQueryOperationResultBoolean} A boolean query operation output.
     */
    static getSafeBoolean(output: IQueryOperationResult): IQueryOperationResultBoolean;
    /**
     * Safely cast a query operation output to a void output.
     * This will throw a runtime error if the output is of the incorrect type.
     * @param {IQueryOperationResult} output A query operation output.
     * @return {IQueryOperationResultVoid} A void query operation output.
     */
    static getSafeVoid(output: IQueryOperationResult): IQueryOperationResultVoid;
    /**
     * Throw an error if the output type does not match the expected type.
     * @param {IQueryOperationResult} output A query operation output.
     * @param {string} expectedType The expected output type.
     */
    static validateQueryOutput(output: IQueryOperationResult, expectedType: IQueryOperationResult['type']): void;
    protected static getBaseExpressionContext(context: IActionContext): IBaseExpressionContext;
    /**
     * Create an options object that can be used to construct a expression-evaluator synchronous evaluator.
     * @param context An action context.
     * @param _mediatorQueryOperation An optional query query operation mediator.
     *                                If defined, the existence resolver will be defined as `exists`.
     */
    static getExpressionContext(context: IActionContext, _mediatorQueryOperation?: MediatorQueryOperation): ISyncExpressionContext;
    /**
     * Create an options object that can be used to construct a expression-evaluator asynchronous evaluator.
     * @param context An action context.
     * @param mediatorQueryOperation A query query operation mediator for resolving `exists`.
     * @param bindingsFactory The bindings factory.
     */
    static getAsyncExpressionContext(context: IActionContext, mediatorQueryOperation: MediatorQueryOperation, bindingsFactory: BindingsFactory): IAsyncExpressionContext;
    /**
     * Create an existence resolver for usage within an expression context.
     * @param context An action context.
     * @param mediatorQueryOperation A query operation mediator.
     * @param bindingsFactory The bindings factory.
     */
    static createExistenceResolver(context: IActionContext, mediatorQueryOperation: MediatorQueryOperation, bindingsFactory: BindingsFactory): (expr: Algebra.ExistenceExpression, bindings: Bindings) => Promise<boolean>;
    /**
     * Throw an error if the context contains the readOnly flag.
     * @param context An action context.
     */
    static throwOnReadOnly(context: IActionContext): void;
    /**
     * Obtain the query source attached to the given operation.
     * @param operation An algebra operation.
     */
    static getOperationSource(operation: Algebra.Operation): IQuerySourceWrapper | undefined;
    /**
     * Assign a source wrapper to the given operation.
     * The operation is copied and returned.
     * @param operation An operation.
     * @param source A source wrapper.
     */
    static assignOperationSource<O extends Algebra.Operation>(operation: O, source: IQuerySourceWrapper): O;
    /**
     * Remove the source wrapper from the given operation.
     * The operation is mutated.
     * @param operation An operation.
     */
    static removeOperationSource(operation: Algebra.Operation): void;
    /**
     * Check if the given shape accepts the given query operation.
     * @param shape A shape to test the query operation against.
     * @param operation A query operation to test.
     * @param options Additional options to consider.
     * @param options.joinBindings If additional bindings will be pushed down to the source for joining.
     * @param options.filterBindings If additional bindings will be pushed down to the source for filtering.
     */
    static doesShapeAcceptOperation(shape: FragmentSelectorShape, operation: Algebra.Operation, options?: {
        joinBindings?: boolean;
        filterBindings?: boolean;
    }): boolean;
}
export interface IActionQueryOperation extends IAction {
    /**
     * The query operation to handle.
     */
    operation: Algebra.Operation;
}
export type IActorQueryOperationArgs = IActorArgs<IActionQueryOperation, IActorTest, IQueryOperationResult>;
export type MediatorQueryOperation = Mediate<IActionQueryOperation, IQueryOperationResult>;
export interface IBaseExpressionContext {
    now?: Date;
    baseIRI?: string;
    extensionFunctionCreator?: (functionNamedNode: RDF.NamedNode) => ((args: RDF.Term[]) => Promise<RDF.Term>) | undefined;
    functionArgumentsCache?: FunctionArgumentsCache;
}
export interface ISyncExpressionContext extends IBaseExpressionContext {
    bnode: (input?: string | undefined) => RDF.BlankNode;
}
export interface IAsyncExpressionContext extends IBaseExpressionContext {
    bnode: (input?: string | undefined) => Promise<RDF.BlankNode>;
    exists?: (expr: Algebra.ExistenceExpression, bindings: Bindings) => Promise<boolean>;
}
