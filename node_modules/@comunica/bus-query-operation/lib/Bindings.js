"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.materializeOperation = exports.materializeTerm = void 0;
const rdf_data_factory_1 = require("rdf-data-factory");
const rdf_string_1 = require("rdf-string");
const rdf_terms_1 = require("rdf-terms");
const sparqlalgebrajs_1 = require("sparqlalgebrajs");
const DF = new rdf_data_factory_1.DataFactory();
const TRUE = DF.literal('true', DF.namedNode('http://www.w3.org/2001/XMLSchema#boolean'));
/**
 * Materialize a term with the given binding.
 *
 * If the given term is a variable,
 * and that variable exist in the given bindings object,
 * the value of that binding is returned.
 * In all other cases, the term itself is returned.
 *
 * @param {RDF.Term} term A term.
 * @param {Bindings} bindings A bindings object.
 * @return {RDF.Term} The materialized term.
 */
function materializeTerm(term, bindings) {
    if (term.termType === 'Variable') {
        const value = bindings.get(term);
        if (value) {
            return value;
        }
    }
    if (term.termType === 'Quad' && (0, rdf_terms_1.someTermsNested)(term, value => value.termType === 'Variable')) {
        return (0, rdf_terms_1.mapTermsNested)(term, subTerm => materializeTerm(subTerm, bindings));
    }
    return term;
}
exports.materializeTerm = materializeTerm;
/**
 * Materialize the given operation (recursively) with the given bindings.
 * Essentially, all variables in the given operation will be replaced
 * by the terms bound to the variables in the given bindings.
 * @param {Algebra.Operation} operation SPARQL algebra operation.
 * @param {Bindings} bindings A bindings object.
 * @param bindingsFactory The bindings factory.
 * @param options Options for materializations.
 * @param options.strictTargetVariables If target variable bindings (such as on SELECT or BIND) should not be allowed.
 * @param options.bindFilter If filter expressions should be materialized
 * @return Algebra.Operation A new operation materialized with the given bindings.
 */
function materializeOperation(operation, bindings, bindingsFactory, options = {}) {
    options = {
        strictTargetVariables: 'strictTargetVariables' in options ? options.strictTargetVariables : false,
        bindFilter: 'bindFilter' in options ? options.bindFilter : true,
    };
    return sparqlalgebrajs_1.Util.mapOperation(operation, {
        path(op, factory) {
            // Materialize variables in a path expression.
            // The predicate expression will be recursed.
            return {
                recurse: false,
                result: Object.assign(factory.createPath(materializeTerm(op.subject, bindings), op.predicate, materializeTerm(op.object, bindings), materializeTerm(op.graph, bindings)), { metadata: op.metadata }),
            };
        },
        pattern(op, factory) {
            // Materialize variables in the quad pattern.
            return {
                recurse: false,
                result: Object.assign(factory.createPattern(materializeTerm(op.subject, bindings), materializeTerm(op.predicate, bindings), materializeTerm(op.object, bindings), materializeTerm(op.graph, bindings)), { metadata: op.metadata }),
            };
        },
        extend(op) {
            // Materialize an extend operation.
            // If strictTargetVariables is true, we throw if the extension target variable is attempted to be bound.
            // Otherwise, we remove the extend operation.
            if (bindings.has(op.variable)) {
                if (options.strictTargetVariables) {
                    throw new Error(`Tried to bind variable ${(0, rdf_string_1.termToString)(op.variable)} in a BIND operator.`);
                }
                else {
                    return {
                        recurse: true,
                        result: materializeOperation(op.input, bindings, bindingsFactory, options),
                    };
                }
            }
            return {
                recurse: true,
                result: op,
            };
        },
        group(op, factory) {
            // Materialize a group operation.
            // If strictTargetVariables is true, we throw if the group target variable is attempted to be bound.
            // Otherwise, we just filter out the bound variables.
            if (options.strictTargetVariables) {
                for (const variable of op.variables) {
                    if (bindings.has(variable)) {
                        throw new Error(`Tried to bind variable ${(0, rdf_string_1.termToString)(variable)} in a GROUP BY operator.`);
                    }
                }
                return {
                    recurse: true,
                    result: op,
                };
            }
            const variables = op.variables.filter(variable => !bindings.has(variable));
            return {
                recurse: true,
                result: factory.createGroup(op.input, variables, op.aggregates),
            };
        },
        project(op, factory) {
            // Materialize a project operation.
            // If strictTargetVariables is true, we throw if the project target variable is attempted to be bound.
            // Otherwise, we just filter out the bound variables.
            if (options.strictTargetVariables) {
                for (const variable of op.variables) {
                    if (bindings.has(variable)) {
                        throw new Error(`Tried to bind variable ${(0, rdf_string_1.termToString)(variable)} in a SELECT operator.`);
                    }
                }
                return {
                    recurse: true,
                    result: op,
                };
            }
            const variables = op.variables.filter(variable => !bindings.has(variable));
            // Only include projected variables in the sub-bindings that will be passed down recursively.
            // If we don't do this, we may be binding variables that may have the same label, but are not considered equal.
            const subBindings = bindingsFactory.bindings(op.variables.map((variable) => {
                const binding = bindings.get(variable);
                if (binding) {
                    return [variable, binding];
                }
                // eslint-disable-next-line no-useless-return,array-callback-return
                return;
            }).filter(Boolean));
            return {
                recurse: false,
                result: factory.createProject(materializeOperation(op.input, subBindings, bindingsFactory, options), variables),
            };
        },
        values(op, factory) {
            // Materialize a values operation.
            // If strictTargetVariables is true, we throw if the values target variable is attempted to be bound.
            // Otherwise, we just filter out the bound variables and their bindings.
            if (options.strictTargetVariables) {
                for (const variable of op.variables) {
                    if (bindings.has(variable)) {
                        throw new Error(`Tried to bind variable ${(0, rdf_string_1.termToString)(variable)} in a VALUES operator.`);
                    }
                }
            }
            else {
                const variables = op.variables.filter(variable => !bindings.has(variable));
                const valueBindings = op.bindings.map((binding) => {
                    const newBinding = { ...binding };
                    let valid = true;
                    // eslint-disable-next-line unicorn/no-array-for-each
                    bindings.forEach((value, key) => {
                        const keyString = (0, rdf_string_1.termToString)(key);
                        if (keyString in newBinding) {
                            if (!value.equals(newBinding[keyString])) {
                                // If the value of the binding is not equal, remove this binding completely from the VALUES clause
                                valid = false;
                            }
                            delete newBinding[keyString];
                        }
                    });
                    return valid ? newBinding : undefined;
                }).filter(Boolean);
                return {
                    recurse: true,
                    result: factory.createValues(variables, valueBindings),
                };
            }
            return {
                recurse: false,
                result: op,
            };
        },
        expression(op, factory) {
            if (!options.bindFilter) {
                return {
                    recurse: false,
                    result: op,
                };
            }
            if (op.expressionType === 'term') {
                // Materialize a term expression
                return {
                    recurse: false,
                    result: factory.createTermExpression(materializeTerm(op.term, bindings)),
                };
            }
            if (op.expressionType === 'operator') {
                if (op.operator === 'bound' && op.args.length === 1 && op.args[0].expressionType === 'term' &&
                    [...bindings.keys()].some(variable => op.args[0].term.equals(variable))) {
                    return {
                        recurse: false,
                        result: factory.createTermExpression(TRUE),
                    };
                }
                return {
                    recurse: true,
                    result: op,
                };
            }
            if (op.expressionType === 'aggregate' &&
                'variable' in op &&
                bindings.has(op.variable)) {
                // Materialize a bound aggregate operation.
                // If strictTargetVariables is true, we throw if the expression target variable is attempted to be bound.
                // Otherwise, we ignore this operation.
                if (options.strictTargetVariables) {
                    throw new Error(`Tried to bind ${(0, rdf_string_1.termToString)(op.variable)} in a ${op.aggregator} aggregate.`);
                }
                else {
                    return {
                        recurse: true,
                        result: op,
                    };
                }
            }
            return {
                recurse: true,
                result: op,
            };
        },
    });
}
exports.materializeOperation = materializeOperation;
//# sourceMappingURL=Bindings.js.map