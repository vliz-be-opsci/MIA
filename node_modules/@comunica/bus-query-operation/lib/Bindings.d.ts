import type { BindingsFactory } from '@comunica/bindings-factory';
import type { Bindings } from '@comunica/types';
import type * as RDF from '@rdfjs/types';
import type { Algebra } from 'sparqlalgebrajs';
/**
 * Materialize a term with the given binding.
 *
 * If the given term is a variable,
 * and that variable exist in the given bindings object,
 * the value of that binding is returned.
 * In all other cases, the term itself is returned.
 *
 * @param {RDF.Term} term A term.
 * @param {Bindings} bindings A bindings object.
 * @return {RDF.Term} The materialized term.
 */
export declare function materializeTerm(term: RDF.Term, bindings: Bindings): RDF.Term;
/**
 * Materialize the given operation (recursively) with the given bindings.
 * Essentially, all variables in the given operation will be replaced
 * by the terms bound to the variables in the given bindings.
 * @param {Algebra.Operation} operation SPARQL algebra operation.
 * @param {Bindings} bindings A bindings object.
 * @param bindingsFactory The bindings factory.
 * @param options Options for materializations.
 * @param options.strictTargetVariables If target variable bindings (such as on SELECT or BIND) should not be allowed.
 * @param options.bindFilter If filter expressions should be materialized
 * @return Algebra.Operation A new operation materialized with the given bindings.
 */
export declare function materializeOperation(operation: Algebra.Operation, bindings: Bindings, bindingsFactory: BindingsFactory, options?: {
    strictTargetVariables?: boolean;
    bindFilter?: boolean;
}): Algebra.Operation;
