{"version":3,"file":"QuerySourceSparql.js","sourceRoot":"","sources":["QuerySourceSparql.ts"],"names":[],"mappings":"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","sourcesContent":["import type { BindingsFactory } from '@comunica/bindings-factory';\nimport type { MediatorHttp } from '@comunica/bus-http';\nimport { KeysInitQuery } from '@comunica/context-entries';\nimport type {\n  IQuerySource,\n  BindingsStream,\n  IActionContext,\n  FragmentSelectorShape,\n  Bindings,\n  MetadataBindings,\n  IQueryBindingsOptions,\n} from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport type { AsyncIterator } from 'asynciterator';\nimport { wrap, TransformIterator } from 'asynciterator';\nimport { SparqlEndpointFetcher } from 'fetch-sparql-endpoint';\nimport { LRUCache } from 'lru-cache';\nimport { DataFactory } from 'rdf-data-factory';\nimport { Algebra, Factory, toSparql, Util } from 'sparqlalgebrajs';\nimport type { BindMethod } from './ActorQuerySourceIdentifyHypermediaSparql';\n\nconst AF = new Factory();\nconst DF = new DataFactory<RDF.BaseQuad>();\nconst VAR_COUNT = DF.variable('count');\nconst COUNT_INFINITY: RDF.QueryResultCardinality = { type: 'estimate', value: Number.POSITIVE_INFINITY };\n\nexport class QuerySourceSparql implements IQuerySource {\n  protected static readonly SELECTOR_SHAPE: FragmentSelectorShape = {\n    type: 'disjunction',\n    children: [\n      {\n        type: 'operation',\n        operation: { operationType: 'type', type: Algebra.types.PROJECT },\n        joinBindings: true,\n      },\n      {\n        type: 'operation',\n        operation: { operationType: 'type', type: Algebra.types.CONSTRUCT },\n      },\n      {\n        type: 'operation',\n        operation: { operationType: 'type', type: Algebra.types.DESCRIBE },\n      },\n      {\n        type: 'operation',\n        operation: { operationType: 'type', type: Algebra.types.ASK },\n      },\n      {\n        type: 'operation',\n        operation: { operationType: 'type', type: Algebra.types.COMPOSITE_UPDATE },\n      },\n    ],\n  };\n\n  public readonly referenceValue: string;\n  private readonly url: string;\n  private readonly context: IActionContext;\n  private readonly mediatorHttp: MediatorHttp;\n  private readonly bindMethod: BindMethod;\n  private readonly countTimeout: number;\n  private readonly bindingsFactory: BindingsFactory;\n\n  private readonly endpointFetcher: SparqlEndpointFetcher;\n  private readonly cache: LRUCache<string, RDF.QueryResultCardinality> | undefined;\n\n  private lastSourceContext: IActionContext | undefined;\n\n  public constructor(\n    url: string,\n    context: IActionContext,\n    mediatorHttp: MediatorHttp,\n    bindMethod: BindMethod,\n    bindingsFactory: BindingsFactory,\n    forceHttpGet: boolean,\n    cacheSize: number,\n    countTimeout: number,\n  ) {\n    this.referenceValue = url;\n    this.url = url;\n    this.context = context;\n    this.mediatorHttp = mediatorHttp;\n    this.bindMethod = bindMethod;\n    this.bindingsFactory = bindingsFactory;\n    this.endpointFetcher = new SparqlEndpointFetcher({\n      method: forceHttpGet ? 'GET' : 'POST',\n      fetch: (input: Request | string, init?: RequestInit) => this.mediatorHttp.mediate(\n        { input, init, context: this.lastSourceContext! },\n      ),\n      prefixVariableQuestionMark: true,\n    });\n    this.cache = cacheSize > 0 ?\n      new LRUCache<string, RDF.QueryResultCardinality>({ max: cacheSize }) :\n      undefined;\n    this.countTimeout = countTimeout;\n  }\n\n  public async getSelectorShape(): Promise<FragmentSelectorShape> {\n    return QuerySourceSparql.SELECTOR_SHAPE;\n  }\n\n  public queryBindings(\n    operationIn: Algebra.Operation,\n    context: IActionContext,\n    options?: IQueryBindingsOptions,\n  ): BindingsStream {\n    // If bindings are passed, modify the operations\n    let operationPromise: Promise<Algebra.Operation>;\n    if (options?.joinBindings) {\n      operationPromise = QuerySourceSparql.addBindingsToOperation(this.bindMethod, operationIn, options.joinBindings);\n    } else {\n      operationPromise = Promise.resolve(operationIn);\n    }\n\n    const bindings: BindingsStream = new TransformIterator(async() => {\n      // Prepare queries\n      const operation = await operationPromise;\n      const variables: RDF.Variable[] = Util.inScopeVariables(operation);\n      const queryString = context.get<string>(KeysInitQuery.queryString);\n      const selectQuery: string = !options?.joinBindings && queryString ?\n        queryString :\n        QuerySourceSparql.operationToSelectQuery(operation, variables);\n\n      return this.queryBindingsRemote(this.url, selectQuery, variables, context);\n    }, { autoStart: false });\n    this.attachMetadata(bindings, context, operationPromise);\n\n    return bindings;\n  }\n\n  public queryQuads(operation: Algebra.Operation, context: IActionContext): AsyncIterator<RDF.Quad> {\n    this.lastSourceContext = this.context.merge(context);\n    const rawStream = this.endpointFetcher.fetchTriples(\n      this.url,\n      context.get(KeysInitQuery.queryString) ?? QuerySourceSparql.operationToQuery(operation),\n    );\n    this.lastSourceContext = undefined;\n    const quads = wrap<any>(rawStream, { autoStart: false, maxBufferSize: Number.POSITIVE_INFINITY });\n    this.attachMetadata(quads, context, Promise.resolve(operation.input));\n    return quads;\n  }\n\n  public queryBoolean(operation: Algebra.Ask, context: IActionContext): Promise<boolean> {\n    this.lastSourceContext = this.context.merge(context);\n    const promise = this.endpointFetcher.fetchAsk(\n      this.url,\n      context.get(KeysInitQuery.queryString) ?? QuerySourceSparql.operationToQuery(operation),\n    );\n    this.lastSourceContext = undefined;\n    return promise;\n  }\n\n  public queryVoid(operation: Algebra.Update, context: IActionContext): Promise<void> {\n    this.lastSourceContext = this.context.merge(context);\n    const promise = this.endpointFetcher.fetchUpdate(\n      this.url,\n      context.get(KeysInitQuery.queryString) ?? QuerySourceSparql.operationToQuery(operation),\n    );\n    this.lastSourceContext = undefined;\n    return promise;\n  }\n\n  protected attachMetadata(\n    target: AsyncIterator<any>,\n    context: IActionContext,\n    operationPromise: Promise<Algebra.Operation>,\n  ): void {\n    // Emit metadata containing the estimated count\n    let variablesCount: RDF.Variable[] = [];\n    // eslint-disable-next-line no-async-promise-executor,ts/no-misused-promises\n    new Promise<RDF.QueryResultCardinality>(async(resolve, reject) => {\n      // Prepare queries\n      let countQuery: string;\n      try {\n        const operation = await operationPromise;\n        variablesCount = Util.inScopeVariables(operation);\n        countQuery = QuerySourceSparql.operationToCountQuery(operation);\n\n        const cachedCardinality = this.cache?.get(countQuery);\n        if (cachedCardinality !== undefined) {\n          return resolve(cachedCardinality);\n        }\n\n        const timeoutHandler = setTimeout(() => resolve(COUNT_INFINITY), this.countTimeout);\n        const bindingsStream: BindingsStream = await this\n          .queryBindingsRemote(this.url, countQuery, [ VAR_COUNT ], context);\n        bindingsStream.on('data', (bindings: Bindings) => {\n          clearTimeout(timeoutHandler);\n          const count = bindings.get(VAR_COUNT);\n          const cardinality: RDF.QueryResultCardinality = { type: 'estimate', value: Number.POSITIVE_INFINITY };\n          if (count) {\n            const cardinalityValue: number = Number.parseInt(count.value, 10);\n            if (!Number.isNaN(cardinalityValue)) {\n              cardinality.type = 'exact';\n              cardinality.value = cardinalityValue;\n              this.cache?.set(countQuery, cardinality);\n            }\n          }\n          return resolve(cardinality);\n        });\n        bindingsStream.on('error', () => {\n          clearTimeout(timeoutHandler);\n          resolve(COUNT_INFINITY);\n        });\n        bindingsStream.on('end', () => {\n          clearTimeout(timeoutHandler);\n          resolve(COUNT_INFINITY);\n        });\n      } catch (error: unknown) {\n        return reject(error);\n      }\n    })\n      .then(cardinality => target.setProperty('metadata', {\n        cardinality,\n        canContainUndefs: false,\n        variables: variablesCount,\n      }))\n      .catch(() => target.setProperty('metadata', {\n        cardinality: COUNT_INFINITY,\n        canContainUndefs: false,\n        variables: variablesCount,\n      }));\n  }\n\n  /**\n   * Create an operation that includes the bindings from the given bindings stream.\n   * @param bindMethod A method for adding bindings to an operation.\n   * @param operation The operation to bind to.\n   * @param addBindings The bindings to add.\n   * @param addBindings.bindings The bindings stream.\n   * @param addBindings.metadata The bindings metadata.\n   */\n  public static async addBindingsToOperation(\n    bindMethod: BindMethod,\n    operation: Algebra.Operation,\n    addBindings: { bindings: BindingsStream; metadata: MetadataBindings },\n  ): Promise<Algebra.Operation> {\n    const bindings = await addBindings.bindings.toArray();\n\n    switch (bindMethod) {\n      case 'values':\n        return AF.createJoin([\n          AF.createValues(\n            addBindings.metadata.variables,\n            bindings.map(binding => Object.fromEntries([ ...binding ]\n              .map(([ key, value ]) => [ `?${key.value}`, <RDF.Literal | RDF.NamedNode> value ]))),\n          ),\n          operation,\n        ], false);\n      case 'union': { throw new Error('Not implemented yet: \"union\" case'); }\n      case 'filter': { throw new Error('Not implemented yet: \"filter\" case'); }\n    }\n  }\n\n  /**\n   * Convert an operation to a select query for this pattern.\n   * @param {Algebra.Operation} operation A query operation.\n   * @param {RDF.Variable[]} variables The variables in scope for the operation.\n   * @return {string} A select query string.\n   */\n  public static operationToSelectQuery(operation: Algebra.Operation, variables: RDF.Variable[]): string {\n    return QuerySourceSparql.operationToQuery(AF.createProject(operation, variables));\n  }\n\n  /**\n   * Convert an operation to a count query for the number of matching triples for this pattern.\n   * @param {Algebra.Operation} operation A query operation.\n   * @return {string} A count query string.\n   */\n  public static operationToCountQuery(operation: Algebra.Operation): string {\n    return QuerySourceSparql.operationToQuery(AF.createProject(\n      AF.createExtend(\n        AF.createGroup(\n          operation,\n          [],\n          [ AF.createBoundAggregate(\n            DF.variable('var0'),\n            'count',\n            AF.createWildcardExpression(),\n            false,\n          ) ],\n        ),\n        DF.variable('count'),\n        AF.createTermExpression(DF.variable('var0')),\n      ),\n      [ DF.variable('count') ],\n    ));\n  }\n\n  /**\n   * Convert an operation to a query for this pattern.\n   * @param {Algebra.Operation} operation A query operation.\n   * @return {string} A query string.\n   */\n  public static operationToQuery(operation: Algebra.Operation): string {\n    return toSparql(operation, { sparqlStar: true });\n  }\n\n  /**\n   * Send a SPARQL query to a SPARQL endpoint and retrieve its bindings as a stream.\n   * @param {string} endpoint A SPARQL endpoint URL.\n   * @param {string} query A SPARQL query string.\n   * @param {RDF.Variable[]} variables The expected variables.\n   * @param {IActionContext} context The source context.\n   * @return {BindingsStream} A stream of bindings.\n   */\n  public async queryBindingsRemote(\n    endpoint: string,\n    query: string,\n    variables: RDF.Variable[],\n    context: IActionContext,\n  ): Promise<BindingsStream> {\n    this.lastSourceContext = this.context.merge(context);\n    const rawStream = await this.endpointFetcher.fetchBindings(endpoint, query);\n    this.lastSourceContext = undefined;\n\n    const it = wrap<any>(rawStream, { autoStart: false, maxBufferSize: Number.POSITIVE_INFINITY })\n      .map<RDF.Bindings>((rawData: Record<string, RDF.Term>) => this.bindingsFactory.bindings(variables\n        .map((variable) => {\n          const value = rawData[`?${variable.value}`];\n          if (!value) {\n            it.emit('error', new Error(`The endpoint ${endpoint} failed to provide a binding for ${variable.value}.`));\n          }\n          return [ variable, value ];\n        })));\n    return it;\n  }\n\n  public toString(): string {\n    return `QuerySourceSparql(${this.url})`;\n  }\n}\n"]}