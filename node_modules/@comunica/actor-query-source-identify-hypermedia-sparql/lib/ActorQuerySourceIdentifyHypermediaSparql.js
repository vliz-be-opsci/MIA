"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorQuerySourceIdentifyHypermediaSparql = void 0;
const bindings_factory_1 = require("@comunica/bindings-factory");
const bus_query_source_identify_hypermedia_1 = require("@comunica/bus-query-source-identify-hypermedia");
const QuerySourceSparql_1 = require("./QuerySourceSparql");
/**
 * A comunica SPARQL Query Source Identify Hypermedia Actor.
 */
class ActorQuerySourceIdentifyHypermediaSparql extends bus_query_source_identify_hypermedia_1.ActorQuerySourceIdentifyHypermedia {
    constructor(args) {
        super(args, 'sparql');
    }
    async testMetadata(action) {
        if (!action.forceSourceType && !action.metadata.sparqlService &&
            !(this.checkUrlSuffix && action.url.endsWith('/sparql'))) {
            throw new Error(`Actor ${this.name} could not detect a SPARQL service description or URL ending on /sparql.`);
        }
        return { filterFactor: 1 };
    }
    async run(action) {
        this.logInfo(action.context, `Identified ${action.url} as sparql source with service URL: ${action.metadata.sparqlService || action.url}`);
        const source = new QuerySourceSparql_1.QuerySourceSparql(action.forceSourceType ? action.url : action.metadata.sparqlService || action.url, action.context, this.mediatorHttp, this.bindMethod, await bindings_factory_1.BindingsFactory.create(this.mediatorMergeBindingsContext, action.context), this.forceHttpGet, this.cacheSize, this.countTimeout);
        return { source };
    }
}
exports.ActorQuerySourceIdentifyHypermediaSparql = ActorQuerySourceIdentifyHypermediaSparql;
//# sourceMappingURL=ActorQuerySourceIdentifyHypermediaSparql.js.map