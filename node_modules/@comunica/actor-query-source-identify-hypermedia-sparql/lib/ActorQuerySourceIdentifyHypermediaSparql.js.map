{"version":3,"file":"ActorQuerySourceIdentifyHypermediaSparql.js","sourceRoot":"","sources":["ActorQuerySourceIdentifyHypermediaSparql.ts"],"names":[],"mappings":";;;AAAA,iEAA6D;AAS7D,yGAEwD;AACxD,2DAAwD;AAExD;;GAEG;AACH,MAAa,wCAAyC,SAAQ,yEAAkC;IAS9F,YAAmB,IAAmD;QACpE,KAAK,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;IACxB,CAAC;IAEM,KAAK,CAAC,YAAY,CACvB,MAA4C;QAE5C,IAAI,CAAC,MAAM,CAAC,eAAe,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,aAAa;YAC3D,CAAC,CAAC,IAAI,CAAC,cAAc,IAAI,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC;YAC3D,MAAM,IAAI,KAAK,CAAC,SAAS,IAAI,CAAC,IAAI,0EAA0E,CAAC,CAAC;QAChH,CAAC;QACD,OAAO,EAAE,YAAY,EAAE,CAAC,EAAE,CAAC;IAC7B,CAAC;IAEM,KAAK,CAAC,GAAG,CAAC,MAA4C;QAC3D,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,OAAO,EAAE,cAAc,MAAM,CAAC,GAAG,uCAAuC,MAAM,CAAC,QAAQ,CAAC,aAAa,IAAI,MAAM,CAAC,GAAG,EAAE,CAAC,CAAC;QAC3I,MAAM,MAAM,GAAG,IAAI,qCAAiB,CAClC,MAAM,CAAC,eAAe,CAAC,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,aAAa,IAAI,MAAM,CAAC,GAAG,EACjF,MAAM,CAAC,OAAO,EACd,IAAI,CAAC,YAAY,EACjB,IAAI,CAAC,UAAU,EACf,MAAM,kCAAe,CAAC,MAAM,CAAC,IAAI,CAAC,4BAA4B,EAAE,MAAM,CAAC,OAAO,CAAC,EAC/E,IAAI,CAAC,YAAY,EACjB,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,YAAY,CAClB,CAAC;QACF,OAAO,EAAE,MAAM,EAAE,CAAC;IACpB,CAAC;CACF;AArCD,4FAqCC","sourcesContent":["import { BindingsFactory } from '@comunica/bindings-factory';\nimport type { MediatorHttp } from '@comunica/bus-http';\nimport type { MediatorMergeBindingsContext } from '@comunica/bus-merge-bindings-context';\nimport type {\n  IActionQuerySourceIdentifyHypermedia,\n  IActorQuerySourceIdentifyHypermediaOutput,\n  IActorQuerySourceIdentifyHypermediaArgs,\n  IActorQuerySourceIdentifyHypermediaTest,\n} from '@comunica/bus-query-source-identify-hypermedia';\nimport {\n  ActorQuerySourceIdentifyHypermedia,\n} from '@comunica/bus-query-source-identify-hypermedia';\nimport { QuerySourceSparql } from './QuerySourceSparql';\n\n/**\n * A comunica SPARQL Query Source Identify Hypermedia Actor.\n */\nexport class ActorQuerySourceIdentifyHypermediaSparql extends ActorQuerySourceIdentifyHypermedia {\n  public readonly mediatorHttp: MediatorHttp;\n  public readonly mediatorMergeBindingsContext: MediatorMergeBindingsContext;\n  public readonly checkUrlSuffix: boolean;\n  public readonly forceHttpGet: boolean;\n  public readonly cacheSize: number;\n  public readonly bindMethod: BindMethod;\n  public readonly countTimeout: number;\n\n  public constructor(args: IActorQuerySourceIdentifyHypermediaSparqlArgs) {\n    super(args, 'sparql');\n  }\n\n  public async testMetadata(\n    action: IActionQuerySourceIdentifyHypermedia,\n  ): Promise<IActorQuerySourceIdentifyHypermediaTest> {\n    if (!action.forceSourceType && !action.metadata.sparqlService &&\n      !(this.checkUrlSuffix && action.url.endsWith('/sparql'))) {\n      throw new Error(`Actor ${this.name} could not detect a SPARQL service description or URL ending on /sparql.`);\n    }\n    return { filterFactor: 1 };\n  }\n\n  public async run(action: IActionQuerySourceIdentifyHypermedia): Promise<IActorQuerySourceIdentifyHypermediaOutput> {\n    this.logInfo(action.context, `Identified ${action.url} as sparql source with service URL: ${action.metadata.sparqlService || action.url}`);\n    const source = new QuerySourceSparql(\n      action.forceSourceType ? action.url : action.metadata.sparqlService || action.url,\n      action.context,\n      this.mediatorHttp,\n      this.bindMethod,\n      await BindingsFactory.create(this.mediatorMergeBindingsContext, action.context),\n      this.forceHttpGet,\n      this.cacheSize,\n      this.countTimeout,\n    );\n    return { source };\n  }\n}\n\nexport interface IActorQuerySourceIdentifyHypermediaSparqlArgs extends IActorQuerySourceIdentifyHypermediaArgs {\n  /**\n   * The HTTP mediator\n   */\n  mediatorHttp: MediatorHttp;\n  /**\n   * A mediator for creating binding context merge handlers\n   */\n  mediatorMergeBindingsContext: MediatorMergeBindingsContext;\n  /**\n   * If URLs ending with '/sparql' should also be considered SPARQL endpoints.\n   * @default {true}\n   */\n  checkUrlSuffix: boolean;\n  /**\n   * If non-update queries should be sent via HTTP GET instead of POST\n   * @default {false}\n   */\n  forceHttpGet: boolean;\n  /**\n   * The cache size for COUNT queries.\n   * @range {integer}\n   * @default {1024}\n   */\n  cacheSize?: number;\n  /**\n   * The query operation for communicating bindings.\n   * @default {values}\n   */\n  bindMethod: BindMethod;\n  /**\n   * Timeout in ms of how long count queries are allowed to take.\n   * If the timeout is reached, an infinity cardinality is returned.\n   * @default {3000}\n   */\n  countTimeout: number;\n}\n\nexport type BindMethod = 'values' | 'union' | 'filter';\n"]}