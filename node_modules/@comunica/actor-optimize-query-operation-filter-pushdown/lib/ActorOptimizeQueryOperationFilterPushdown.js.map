{"version":3,"file":"ActorOptimizeQueryOperationFilterPushdown.js","sourceRoot":"","sources":["ActorOptimizeQueryOperationFilterPushdown.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  IActionOptimizeQueryOperation,\n  IActorOptimizeQueryOperationOutput,\n  IActorOptimizeQueryOperationArgs,\n} from '@comunica/bus-optimize-query-operation';\nimport { ActorOptimizeQueryOperation } from '@comunica/bus-optimize-query-operation';\nimport type { IActorTest } from '@comunica/core';\nimport type { IActionContext } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport { uniqTerms } from 'rdf-terms';\nimport type { Factory } from 'sparqlalgebrajs';\nimport { Algebra, Util } from 'sparqlalgebrajs';\n\n/**\n * A comunica Filter Pushdown Optimize Query Operation Actor.\n */\nexport class ActorOptimizeQueryOperationFilterPushdown extends ActorOptimizeQueryOperation {\n  public constructor(args: IActorOptimizeQueryOperationArgs) {\n    super(args);\n  }\n\n  public async test(_action: IActionOptimizeQueryOperation): Promise<IActorTest> {\n    return true;\n  }\n\n  public async run(action: IActionOptimizeQueryOperation): Promise<IActorOptimizeQueryOperationOutput> {\n    // eslint-disable-next-line ts/no-this-alias\n    const self = this;\n    const operation = Util.mapOperation(action.operation, {\n      filter(op: Algebra.Filter, factory: Factory) {\n        // For all filter expressions in the operation,\n        // we attempt to push them down as deep as possible into the algebra.\n        const variables = self.getExpressionVariables(op.expression);\n        return {\n          recurse: true,\n          result: self.filterPushdown(op.expression, variables, op.input, factory, action.context),\n        };\n      },\n    });\n    return { operation, context: action.context };\n  }\n\n  /**\n   * Get all variables inside the given expression.\n   * @param expression An expression.\n   * @return An array of variables, or undefined if the expression is unsupported for pushdown.\n   */\n  public getExpressionVariables(expression: Algebra.Expression): RDF.Variable[] {\n    switch (expression.expressionType) {\n      case Algebra.expressionTypes.AGGREGATE:\n      case Algebra.expressionTypes.WILDCARD:\n        throw new Error(`Getting expression variables is not supported for ${expression.expressionType}`);\n      case Algebra.expressionTypes.EXISTENCE:\n        return Util.inScopeVariables(expression.input);\n      case Algebra.expressionTypes.NAMED:\n        return [];\n      case Algebra.expressionTypes.OPERATOR:\n        return uniqTerms(expression.args.flatMap(arg => this.getExpressionVariables(arg)));\n      case Algebra.expressionTypes.TERM:\n        if (expression.term.termType === 'Variable') {\n          return [ expression.term ];\n        }\n        return [];\n    }\n  }\n\n  protected getOverlappingOperations(\n    operation: Algebra.Operation,\n    expressionVariables: RDF.Variable[],\n  ): {\n      fullyOverlapping: Algebra.Operation[];\n      partiallyOverlapping: Algebra.Operation[];\n      notOverlapping: Algebra.Operation[];\n    } {\n    const fullyOverlapping: Algebra.Operation[] = [];\n    const partiallyOverlapping: Algebra.Operation[] = [];\n    const notOverlapping: Algebra.Operation[] = [];\n    for (const input of operation.input) {\n      const inputVariables = Util.inScopeVariables(input);\n      if (this.variablesSubSetOf(expressionVariables, inputVariables)) {\n        fullyOverlapping.push(input);\n      } else if (this.variablesIntersect(expressionVariables, inputVariables)) {\n        partiallyOverlapping.push(input);\n      } else {\n        notOverlapping.push(input);\n      }\n    }\n\n    return {\n      fullyOverlapping,\n      partiallyOverlapping,\n      notOverlapping,\n    };\n  }\n\n  /**\n   * Recursively push down the given expression into the given operation if possible.\n   * Different operators have different semantics for choosing whether or not to push down,\n   * and how this pushdown is done.\n   * For every passed operator, it is checked whether or not the filter will have any effect on the operation.\n   * If not, the filter is voided.\n   * @param expression An expression to push down.\n   * @param expressionVariables The variables inside the given expression.\n   * @param operation The operation to push down into.\n   * @param factory An algebra factory.\n   * @param context The action context.\n   * @return The modified operation.\n   */\n  public filterPushdown(\n    expression: Algebra.Expression,\n    expressionVariables: RDF.Variable[],\n    operation: Algebra.Operation,\n    factory: Factory,\n    context: IActionContext,\n  ): Algebra.Operation {\n    switch (operation.type) {\n      case Algebra.types.EXTEND:\n        // Pass if the variable is not part of the expression\n        if (!this.variablesIntersect([ operation.variable ], expressionVariables)) {\n          return factory.createExtend(\n            this.filterPushdown(expression, expressionVariables, operation.input, factory, context),\n            operation.variable,\n            operation.expression,\n          );\n        }\n        return factory.createFilter(operation, expression);\n      case Algebra.types.FILTER:\n        // Always pass\n        return factory.createFilter(\n          this.filterPushdown(expression, expressionVariables, operation.input, factory, context),\n          operation.expression,\n        );\n      case Algebra.types.JOIN: {\n        // Don't push down for empty join\n        if (operation.input.length === 0) {\n          return factory.createFilter(operation, expression);\n        }\n\n        // Determine overlapping operations\n        const {\n          fullyOverlapping,\n          partiallyOverlapping,\n          notOverlapping,\n        } = this.getOverlappingOperations(operation, expressionVariables);\n\n        const joins: Algebra.Operation[] = [];\n        this.logDebug(context, `Push down filter across join entries with ${fullyOverlapping.length} fully overlapping, ${partiallyOverlapping.length} partially overlapping, and ${notOverlapping.length} not overlapping`);\n        if (fullyOverlapping.length > 0) {\n          joins.push(factory.createJoin(fullyOverlapping\n            .map(input => this.filterPushdown(expression, expressionVariables, input, factory, context))));\n        }\n        if (partiallyOverlapping.length > 0) {\n          joins.push(factory.createFilter(factory.createJoin(partiallyOverlapping, false), expression));\n        }\n        if (notOverlapping.length > 0) {\n          joins.push(...notOverlapping);\n        }\n\n        return joins.length === 1 ? joins[0] : factory.createJoin(joins);\n      }\n      case Algebra.types.NOP:\n        return operation;\n      case Algebra.types.PROJECT:\n        // Push down if variables overlap\n        if (this.variablesIntersect(operation.variables, expressionVariables)) {\n          return factory.createProject(\n            this.filterPushdown(expression, expressionVariables, operation.input, factory, context),\n            operation.variables,\n          );\n        }\n        // Void expression otherwise\n        return operation;\n      case Algebra.types.UNION: {\n        // Determine overlapping operations\n        const {\n          fullyOverlapping,\n          partiallyOverlapping,\n          notOverlapping,\n        } = this.getOverlappingOperations(operation, expressionVariables);\n\n        const unions: Algebra.Operation[] = [];\n        this.logDebug(context, `Push down filter across union entries with ${fullyOverlapping.length} fully overlapping, ${partiallyOverlapping.length} partially overlapping, and ${notOverlapping.length} not overlapping`);\n        if (fullyOverlapping.length > 0) {\n          unions.push(factory.createUnion(fullyOverlapping\n            .map(input => this.filterPushdown(expression, expressionVariables, input, factory, context))));\n        }\n        if (partiallyOverlapping.length > 0) {\n          unions.push(factory.createFilter(factory.createUnion(partiallyOverlapping, false), expression));\n        }\n        if (notOverlapping.length > 0) {\n          unions.push(...notOverlapping);\n        }\n\n        return unions.length === 1 ? unions[0] : factory.createUnion(unions);\n      }\n      case Algebra.types.VALUES:\n        // Only keep filter if it overlaps with the variables\n        if (this.variablesIntersect(operation.variables, expressionVariables)) {\n          return factory.createFilter(operation, expression);\n        }\n        return operation;\n      case Algebra.types.LEFT_JOIN:\n      case Algebra.types.MINUS:\n      case Algebra.types.ALT:\n      case Algebra.types.ASK:\n      case Algebra.types.BGP:\n      case Algebra.types.CONSTRUCT:\n      case Algebra.types.DESCRIBE:\n      case Algebra.types.DISTINCT:\n      case Algebra.types.EXPRESSION:\n      case Algebra.types.FROM:\n      case Algebra.types.GRAPH:\n      case Algebra.types.GROUP:\n      case Algebra.types.INV:\n      case Algebra.types.LINK:\n      case Algebra.types.NPS:\n      case Algebra.types.ONE_OR_MORE_PATH:\n      case Algebra.types.ORDER_BY:\n      case Algebra.types.PATTERN:\n      case Algebra.types.REDUCED:\n      case Algebra.types.SEQ:\n      case Algebra.types.SERVICE:\n      case Algebra.types.SLICE:\n      case Algebra.types.PATH:\n      case Algebra.types.ZERO_OR_MORE_PATH:\n      case Algebra.types.ZERO_OR_ONE_PATH:\n      case Algebra.types.COMPOSITE_UPDATE:\n      case Algebra.types.DELETE_INSERT:\n      case Algebra.types.LOAD:\n      case Algebra.types.CLEAR:\n      case Algebra.types.CREATE:\n      case Algebra.types.DROP:\n      case Algebra.types.ADD:\n      case Algebra.types.MOVE:\n      case Algebra.types.COPY:\n        // Operations that do not support pushing down\n        // Left-join and minus might be possible to support in the future.\n        return factory.createFilter(operation, expression);\n    }\n  }\n\n  /**\n   * Check if there is an overlap between the two given lists of variables.\n   * @param varsA A list of variables.\n   * @param varsB A list of variables.\n   */\n  public variablesIntersect(varsA: RDF.Variable[], varsB: RDF.Variable[]): boolean {\n    return varsA.some(varA => varsB.some(varB => varA.equals(varB)));\n  }\n\n  /**\n   * Check if all variables from the first list are included in the second list.\n   * The second list may contain other variables as well.\n   * @param varsNeedles A list of variables to search for.\n   * @param varsHaystack A list of variables to search in.\n   */\n  public variablesSubSetOf(varsNeedles: RDF.Variable[], varsHaystack: RDF.Variable[]): boolean {\n    return varsNeedles.length <= varsHaystack.length &&\n      varsNeedles.every(varA => varsHaystack.some(varB => varA.equals(varB)));\n  }\n}\n"]}