import type { IActionOptimizeQueryOperation, IActorOptimizeQueryOperationOutput, IActorOptimizeQueryOperationArgs } from '@comunica/bus-optimize-query-operation';
import { ActorOptimizeQueryOperation } from '@comunica/bus-optimize-query-operation';
import type { IActorTest } from '@comunica/core';
import type { IActionContext } from '@comunica/types';
import type * as RDF from '@rdfjs/types';
import type { Factory } from 'sparqlalgebrajs';
import { Algebra } from 'sparqlalgebrajs';
/**
 * A comunica Filter Pushdown Optimize Query Operation Actor.
 */
export declare class ActorOptimizeQueryOperationFilterPushdown extends ActorOptimizeQueryOperation {
    constructor(args: IActorOptimizeQueryOperationArgs);
    test(_action: IActionOptimizeQueryOperation): Promise<IActorTest>;
    run(action: IActionOptimizeQueryOperation): Promise<IActorOptimizeQueryOperationOutput>;
    /**
     * Get all variables inside the given expression.
     * @param expression An expression.
     * @return An array of variables, or undefined if the expression is unsupported for pushdown.
     */
    getExpressionVariables(expression: Algebra.Expression): RDF.Variable[];
    protected getOverlappingOperations(operation: Algebra.Operation, expressionVariables: RDF.Variable[]): {
        fullyOverlapping: Algebra.Operation[];
        partiallyOverlapping: Algebra.Operation[];
        notOverlapping: Algebra.Operation[];
    };
    /**
     * Recursively push down the given expression into the given operation if possible.
     * Different operators have different semantics for choosing whether or not to push down,
     * and how this pushdown is done.
     * For every passed operator, it is checked whether or not the filter will have any effect on the operation.
     * If not, the filter is voided.
     * @param expression An expression to push down.
     * @param expressionVariables The variables inside the given expression.
     * @param operation The operation to push down into.
     * @param factory An algebra factory.
     * @param context The action context.
     * @return The modified operation.
     */
    filterPushdown(expression: Algebra.Expression, expressionVariables: RDF.Variable[], operation: Algebra.Operation, factory: Factory, context: IActionContext): Algebra.Operation;
    /**
     * Check if there is an overlap between the two given lists of variables.
     * @param varsA A list of variables.
     * @param varsB A list of variables.
     */
    variablesIntersect(varsA: RDF.Variable[], varsB: RDF.Variable[]): boolean;
    /**
     * Check if all variables from the first list are included in the second list.
     * The second list may contain other variables as well.
     * @param varsNeedles A list of variables to search for.
     * @param varsHaystack A list of variables to search in.
     */
    variablesSubSetOf(varsNeedles: RDF.Variable[], varsHaystack: RDF.Variable[]): boolean;
}
