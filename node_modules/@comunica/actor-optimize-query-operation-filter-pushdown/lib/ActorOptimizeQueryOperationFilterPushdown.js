"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorOptimizeQueryOperationFilterPushdown = void 0;
const bus_optimize_query_operation_1 = require("@comunica/bus-optimize-query-operation");
const rdf_terms_1 = require("rdf-terms");
const sparqlalgebrajs_1 = require("sparqlalgebrajs");
/**
 * A comunica Filter Pushdown Optimize Query Operation Actor.
 */
class ActorOptimizeQueryOperationFilterPushdown extends bus_optimize_query_operation_1.ActorOptimizeQueryOperation {
    constructor(args) {
        super(args);
    }
    async test(_action) {
        return true;
    }
    async run(action) {
        // eslint-disable-next-line ts/no-this-alias
        const self = this;
        const operation = sparqlalgebrajs_1.Util.mapOperation(action.operation, {
            filter(op, factory) {
                // For all filter expressions in the operation,
                // we attempt to push them down as deep as possible into the algebra.
                const variables = self.getExpressionVariables(op.expression);
                return {
                    recurse: true,
                    result: self.filterPushdown(op.expression, variables, op.input, factory, action.context),
                };
            },
        });
        return { operation, context: action.context };
    }
    /**
     * Get all variables inside the given expression.
     * @param expression An expression.
     * @return An array of variables, or undefined if the expression is unsupported for pushdown.
     */
    getExpressionVariables(expression) {
        switch (expression.expressionType) {
            case sparqlalgebrajs_1.Algebra.expressionTypes.AGGREGATE:
            case sparqlalgebrajs_1.Algebra.expressionTypes.WILDCARD:
                throw new Error(`Getting expression variables is not supported for ${expression.expressionType}`);
            case sparqlalgebrajs_1.Algebra.expressionTypes.EXISTENCE:
                return sparqlalgebrajs_1.Util.inScopeVariables(expression.input);
            case sparqlalgebrajs_1.Algebra.expressionTypes.NAMED:
                return [];
            case sparqlalgebrajs_1.Algebra.expressionTypes.OPERATOR:
                return (0, rdf_terms_1.uniqTerms)(expression.args.flatMap(arg => this.getExpressionVariables(arg)));
            case sparqlalgebrajs_1.Algebra.expressionTypes.TERM:
                if (expression.term.termType === 'Variable') {
                    return [expression.term];
                }
                return [];
        }
    }
    getOverlappingOperations(operation, expressionVariables) {
        const fullyOverlapping = [];
        const partiallyOverlapping = [];
        const notOverlapping = [];
        for (const input of operation.input) {
            const inputVariables = sparqlalgebrajs_1.Util.inScopeVariables(input);
            if (this.variablesSubSetOf(expressionVariables, inputVariables)) {
                fullyOverlapping.push(input);
            }
            else if (this.variablesIntersect(expressionVariables, inputVariables)) {
                partiallyOverlapping.push(input);
            }
            else {
                notOverlapping.push(input);
            }
        }
        return {
            fullyOverlapping,
            partiallyOverlapping,
            notOverlapping,
        };
    }
    /**
     * Recursively push down the given expression into the given operation if possible.
     * Different operators have different semantics for choosing whether or not to push down,
     * and how this pushdown is done.
     * For every passed operator, it is checked whether or not the filter will have any effect on the operation.
     * If not, the filter is voided.
     * @param expression An expression to push down.
     * @param expressionVariables The variables inside the given expression.
     * @param operation The operation to push down into.
     * @param factory An algebra factory.
     * @param context The action context.
     * @return The modified operation.
     */
    filterPushdown(expression, expressionVariables, operation, factory, context) {
        switch (operation.type) {
            case sparqlalgebrajs_1.Algebra.types.EXTEND:
                // Pass if the variable is not part of the expression
                if (!this.variablesIntersect([operation.variable], expressionVariables)) {
                    return factory.createExtend(this.filterPushdown(expression, expressionVariables, operation.input, factory, context), operation.variable, operation.expression);
                }
                return factory.createFilter(operation, expression);
            case sparqlalgebrajs_1.Algebra.types.FILTER:
                // Always pass
                return factory.createFilter(this.filterPushdown(expression, expressionVariables, operation.input, factory, context), operation.expression);
            case sparqlalgebrajs_1.Algebra.types.JOIN: {
                // Don't push down for empty join
                if (operation.input.length === 0) {
                    return factory.createFilter(operation, expression);
                }
                // Determine overlapping operations
                const { fullyOverlapping, partiallyOverlapping, notOverlapping, } = this.getOverlappingOperations(operation, expressionVariables);
                const joins = [];
                this.logDebug(context, `Push down filter across join entries with ${fullyOverlapping.length} fully overlapping, ${partiallyOverlapping.length} partially overlapping, and ${notOverlapping.length} not overlapping`);
                if (fullyOverlapping.length > 0) {
                    joins.push(factory.createJoin(fullyOverlapping
                        .map(input => this.filterPushdown(expression, expressionVariables, input, factory, context))));
                }
                if (partiallyOverlapping.length > 0) {
                    joins.push(factory.createFilter(factory.createJoin(partiallyOverlapping, false), expression));
                }
                if (notOverlapping.length > 0) {
                    joins.push(...notOverlapping);
                }
                return joins.length === 1 ? joins[0] : factory.createJoin(joins);
            }
            case sparqlalgebrajs_1.Algebra.types.NOP:
                return operation;
            case sparqlalgebrajs_1.Algebra.types.PROJECT:
                // Push down if variables overlap
                if (this.variablesIntersect(operation.variables, expressionVariables)) {
                    return factory.createProject(this.filterPushdown(expression, expressionVariables, operation.input, factory, context), operation.variables);
                }
                // Void expression otherwise
                return operation;
            case sparqlalgebrajs_1.Algebra.types.UNION: {
                // Determine overlapping operations
                const { fullyOverlapping, partiallyOverlapping, notOverlapping, } = this.getOverlappingOperations(operation, expressionVariables);
                const unions = [];
                this.logDebug(context, `Push down filter across union entries with ${fullyOverlapping.length} fully overlapping, ${partiallyOverlapping.length} partially overlapping, and ${notOverlapping.length} not overlapping`);
                if (fullyOverlapping.length > 0) {
                    unions.push(factory.createUnion(fullyOverlapping
                        .map(input => this.filterPushdown(expression, expressionVariables, input, factory, context))));
                }
                if (partiallyOverlapping.length > 0) {
                    unions.push(factory.createFilter(factory.createUnion(partiallyOverlapping, false), expression));
                }
                if (notOverlapping.length > 0) {
                    unions.push(...notOverlapping);
                }
                return unions.length === 1 ? unions[0] : factory.createUnion(unions);
            }
            case sparqlalgebrajs_1.Algebra.types.VALUES:
                // Only keep filter if it overlaps with the variables
                if (this.variablesIntersect(operation.variables, expressionVariables)) {
                    return factory.createFilter(operation, expression);
                }
                return operation;
            case sparqlalgebrajs_1.Algebra.types.LEFT_JOIN:
            case sparqlalgebrajs_1.Algebra.types.MINUS:
            case sparqlalgebrajs_1.Algebra.types.ALT:
            case sparqlalgebrajs_1.Algebra.types.ASK:
            case sparqlalgebrajs_1.Algebra.types.BGP:
            case sparqlalgebrajs_1.Algebra.types.CONSTRUCT:
            case sparqlalgebrajs_1.Algebra.types.DESCRIBE:
            case sparqlalgebrajs_1.Algebra.types.DISTINCT:
            case sparqlalgebrajs_1.Algebra.types.EXPRESSION:
            case sparqlalgebrajs_1.Algebra.types.FROM:
            case sparqlalgebrajs_1.Algebra.types.GRAPH:
            case sparqlalgebrajs_1.Algebra.types.GROUP:
            case sparqlalgebrajs_1.Algebra.types.INV:
            case sparqlalgebrajs_1.Algebra.types.LINK:
            case sparqlalgebrajs_1.Algebra.types.NPS:
            case sparqlalgebrajs_1.Algebra.types.ONE_OR_MORE_PATH:
            case sparqlalgebrajs_1.Algebra.types.ORDER_BY:
            case sparqlalgebrajs_1.Algebra.types.PATTERN:
            case sparqlalgebrajs_1.Algebra.types.REDUCED:
            case sparqlalgebrajs_1.Algebra.types.SEQ:
            case sparqlalgebrajs_1.Algebra.types.SERVICE:
            case sparqlalgebrajs_1.Algebra.types.SLICE:
            case sparqlalgebrajs_1.Algebra.types.PATH:
            case sparqlalgebrajs_1.Algebra.types.ZERO_OR_MORE_PATH:
            case sparqlalgebrajs_1.Algebra.types.ZERO_OR_ONE_PATH:
            case sparqlalgebrajs_1.Algebra.types.COMPOSITE_UPDATE:
            case sparqlalgebrajs_1.Algebra.types.DELETE_INSERT:
            case sparqlalgebrajs_1.Algebra.types.LOAD:
            case sparqlalgebrajs_1.Algebra.types.CLEAR:
            case sparqlalgebrajs_1.Algebra.types.CREATE:
            case sparqlalgebrajs_1.Algebra.types.DROP:
            case sparqlalgebrajs_1.Algebra.types.ADD:
            case sparqlalgebrajs_1.Algebra.types.MOVE:
            case sparqlalgebrajs_1.Algebra.types.COPY:
                // Operations that do not support pushing down
                // Left-join and minus might be possible to support in the future.
                return factory.createFilter(operation, expression);
        }
    }
    /**
     * Check if there is an overlap between the two given lists of variables.
     * @param varsA A list of variables.
     * @param varsB A list of variables.
     */
    variablesIntersect(varsA, varsB) {
        return varsA.some(varA => varsB.some(varB => varA.equals(varB)));
    }
    /**
     * Check if all variables from the first list are included in the second list.
     * The second list may contain other variables as well.
     * @param varsNeedles A list of variables to search for.
     * @param varsHaystack A list of variables to search in.
     */
    variablesSubSetOf(varsNeedles, varsHaystack) {
        return varsNeedles.length <= varsHaystack.length &&
            varsNeedles.every(varA => varsHaystack.some(varB => varA.equals(varB)));
    }
}
exports.ActorOptimizeQueryOperationFilterPushdown = ActorOptimizeQueryOperationFilterPushdown;
//# sourceMappingURL=ActorOptimizeQueryOperationFilterPushdown.js.map