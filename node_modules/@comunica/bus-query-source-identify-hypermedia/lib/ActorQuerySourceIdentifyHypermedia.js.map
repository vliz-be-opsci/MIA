{"version":3,"file":"ActorQuerySourceIdentifyHypermedia.js","sourceRoot":"","sources":["ActorQuerySourceIdentifyHypermedia.ts"],"names":[],"mappings":";;;AACA,yCAAuC;AAIvC;;;;;;;;;;GAUG;AACH,MAAsB,kCACpB,SAAQ,YAIT;IAGC;;;OAGG;IACH,YAAmB,IAA6C,EAAE,UAAkB;QAClF,KAAK,CAAC,IAAI,CAAC,CAAC;QACZ,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;IAC/B,CAAC;IAEM,KAAK,CAAC,IAAI,CAAC,MAA4C;QAC5D,IAAI,MAAM,CAAC,eAAe,IAAI,IAAI,CAAC,UAAU,KAAK,MAAM,CAAC,eAAe,EAAE,CAAC;YACzE,MAAM,IAAI,KAAK,CAAC,SAAS,IAAI,CAAC,IAAI,sCAAsC,MAAM,CAAC,eAAe,GAAG,CAAC,CAAC;QACrG,CAAC;QACD,OAAO,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;IACnC,CAAC;CAKF;AA3BD,gFA2BC","sourcesContent":["import type { IAction, IActorArgs, IActorOutput, IActorTest, Mediate } from '@comunica/core';\nimport { Actor } from '@comunica/core';\nimport type { IQuerySource } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\n\n/**\n * A comunica actor for query-source-identify-hypermedia events.\n *\n * Actor types:\n * * Input:  IActionQuerySourceIdentifyHypermedia:      The metadata in the document and a query operation.\n * * Test:   <none>\n * * Output: IActorQuerySourceIdentifyHypermediaOutput: A query source.\n *\n * @see IActionQuerySourceIdentifyHypermedia\n * @see IActorQuerySourceIdentifyHypermediaOutput\n */\nexport abstract class ActorQuerySourceIdentifyHypermedia\n  extends Actor<\n    IActionQuerySourceIdentifyHypermedia,\nIActorQuerySourceIdentifyHypermediaTest,\nIActorQuerySourceIdentifyHypermediaOutput\n> {\n  protected readonly sourceType: string;\n\n  /**\n   * @param args - @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus\n   * @param sourceType The source type.\n   */\n  public constructor(args: IActorQuerySourceIdentifyHypermediaArgs, sourceType: string) {\n    super(args);\n    this.sourceType = sourceType;\n  }\n\n  public async test(action: IActionQuerySourceIdentifyHypermedia): Promise<IActorQuerySourceIdentifyHypermediaTest> {\n    if (action.forceSourceType && this.sourceType !== action.forceSourceType) {\n      throw new Error(`Actor ${this.name} is not able to handle source type ${action.forceSourceType}.`);\n    }\n    return this.testMetadata(action);\n  }\n\n  public abstract testMetadata(\n    action: IActionQuerySourceIdentifyHypermedia,\n  ): Promise<IActorQuerySourceIdentifyHypermediaTest>;\n}\n\nexport interface IActionQuerySourceIdentifyHypermedia extends IAction {\n  /**\n   * The URL of the source that was fetched.\n   */\n  url: string;\n  /**\n   * A metadata key-value mapping.\n   */\n  metadata: Record<string, any>;\n  /**\n   * A stream of data quads.\n   */\n  quads: RDF.Stream;\n  /**\n   * A hash of all datasets that have been handled.\n   */\n  handledDatasets?: Record<string, boolean>;\n  /**\n   * The explicitly requested source type.\n   * If set, the source type of the actor MUST explicitly match the given forced type.\n   */\n  forceSourceType?: string;\n}\n\nexport interface IActorQuerySourceIdentifyHypermediaTest extends IActorTest {\n  /**\n   * A value from 0 to 1 indicating to what respect a source type is\n   * able to pre-filter the source based on the pattern.\n   * 1 indicates that the source can apply the whole pattern,\n   * and 0 indicates that the source can not apply the pattern at all (and local filtering must happen).\n   */\n  filterFactor: number;\n}\n\nexport interface IActorQuerySourceIdentifyHypermediaOutput extends IActorOutput {\n  /**\n   * The new source of quads contained in the document.\n   */\n  source: IQuerySource;\n  /**\n   * The dataset that was handled.\n   */\n  dataset?: string;\n}\n\nexport type IActorQuerySourceIdentifyHypermediaArgs = IActorArgs<\nIActionQuerySourceIdentifyHypermedia,\nIActorQuerySourceIdentifyHypermediaTest,\nIActorQuerySourceIdentifyHypermediaOutput\n>;\n\nexport type MediatorQuerySourceIdentifyHypermedia = Mediate<\nIActionQuerySourceIdentifyHypermedia,\nIActorQuerySourceIdentifyHypermediaOutput,\nIActorQuerySourceIdentifyHypermediaTest\n>;\n"]}