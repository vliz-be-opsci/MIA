{"version":3,"file":"Utils.js","sourceRoot":"","sources":["Utils.ts"],"names":[],"mappings":";;;AAIA;;;GAGG;AACH,SAAgB,gBAAgB,CAAC,IAA6B;IAC5D,OAAO,eAAe,CAAC,GAAG,EAAE,CAAC,IAAI,OAAO,CAAsB,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;QAChF,IAAI,CAAC,WAAW,CAAC,UAAU,EAAE,CAAC,QAA6B,EAAE,EAAE,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC;QACnF,IAAI,CAAC,EAAE,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;IAC3B,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,qBAAqB,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;AAC9D,CAAC;AALD,4CAKC;AAED;;;GAGG;AACH,SAAgB,mBAAmB,CAAC,IAAoB;IACtD,OAAO,eAAe,CAAC,GAAG,EAAE,CAAC,IAAI,OAAO,CAAsB,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;QAChF,IAAI,CAAC,WAAW,CAAC,UAAU,EAAE,CAAC,QAA6B,EAAE,EAAE,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC;QACnF,IAAI,CAAC,EAAE,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;IAC3B,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,WAAW,EAAE,EAAE;QACtB,IAAI,CAAC,CAAC,kBAAkB,IAAI,WAAW,CAAC,EAAE,CAAC;YACzC,WAAW,CAAC,gBAAgB,GAAG,KAAK,CAAC;QACvC,CAAC;QACD,OAAO,wBAAwB,CAAC,WAAW,CAAC,CAAC;IAC/C,CAAC,CAAC,CAAC,CAAC;AACN,CAAC;AAVD,kDAUC;AAED;;;GAGG;AACH,SAAgB,qBAAqB,CAAC,WAAgC;IACpE,KAAK,MAAM,GAAG,IAAI,CAAE,aAAa,CAAE,EAAE,CAAC;QACpC,IAAI,CAAC,CAAC,GAAG,IAAI,WAAW,CAAC,EAAE,CAAC;YAC1B,MAAM,IAAI,KAAK,CAAC,6BAA6B,GAAG,OAAO,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;QACxF,CAAC;IACH,CAAC;IACD,OAAuB,WAAW,CAAC;AACrC,CAAC;AAPD,sDAOC;AAED;;;GAGG;AACH,SAAgB,wBAAwB,CAAC,WAAgC;IACvE,KAAK,MAAM,GAAG,IAAI,CAAE,aAAa,EAAE,kBAAkB,EAAE,WAAW,CAAE,EAAE,CAAC;QACrE,IAAI,CAAC,CAAC,GAAG,IAAI,WAAW,CAAC,EAAE,CAAC;YAC1B,MAAM,IAAI,KAAK,CAAC,6BAA6B,GAAG,OAAO,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;QACxF,CAAC;IACH,CAAC;IACD,OAA0B,WAAW,CAAC;AACxC,CAAC;AAPD,4DAOC;AAED;;;;GAIG;AACH,SAAgB,eAAe,CAC7B,QAA0B;IAE1B,IAAI,UAAkC,CAAC;IACvC,OAAO,GAAG,EAAE;QACV,IAAI,CAAC,UAAU,EAAE,CAAC;YAChB,UAAU,GAAG,QAAQ,EAAE,CAAC;YACxB,UAAU;iBACP,IAAI,CAAC,eAAe,CAAC,EAAE,CAAC,eAAe,CAAC,KAAK,CAAC,qBAAqB,CAAC,GAAG,EAAE;gBACxE,UAAU,GAAG,SAAS,CAAC;YACzB,CAAC,CAAC,CAAC;iBACF,KAAK,CAAC,GAAG,EAAE;gBACZ,eAAe;YACf,CAAC,CAAC,CAAC;QACP,CAAC;QACD,OAAO,UAAU,CAAC;IACpB,CAAC,CAAC;AACJ,CAAC;AAjBD,0CAiBC","sourcesContent":["import type { BindingsStream, IMetadata, MetadataBindings, MetadataQuads } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport type { AsyncIterator } from 'asynciterator';\n\n/**\n * Return a cached callback to the metadata from the given quad stream as a promise.\n * @param data A quad stream.\n */\nexport function getMetadataQuads(data: AsyncIterator<RDF.Quad>): () => Promise<MetadataQuads> {\n  return cachifyMetadata(() => new Promise<Record<string, any>>((resolve, reject) => {\n    data.getProperty('metadata', (metadata: Record<string, any>) => resolve(metadata));\n    data.on('error', reject);\n  }).then(metadataRaw => validateMetadataQuads(metadataRaw)));\n}\n\n/**\n * Return a cached callback to the metadata from the given bindings stream as a promise.\n * @param data A bindings stream.\n */\nexport function getMetadataBindings(data: BindingsStream): () => Promise<MetadataBindings> {\n  return cachifyMetadata(() => new Promise<Record<string, any>>((resolve, reject) => {\n    data.getProperty('metadata', (metadata: Record<string, any>) => resolve(metadata));\n    data.on('error', reject);\n  }).then((metadataRaw) => {\n    if (!('canContainUndefs' in metadataRaw)) {\n      metadataRaw.canContainUndefs = false;\n    }\n    return validateMetadataBindings(metadataRaw);\n  }));\n}\n\n/**\n * Ensure that the given raw metadata object contains all required metadata entries.\n * @param metadataRaw A raw metadata object.\n */\nexport function validateMetadataQuads(metadataRaw: Record<string, any>): MetadataQuads {\n  for (const key of [ 'cardinality' ]) {\n    if (!(key in metadataRaw)) {\n      throw new Error(`Invalid metadata: missing ${key} in ${JSON.stringify(metadataRaw)}`);\n    }\n  }\n  return <MetadataQuads> metadataRaw;\n}\n\n/**\n * Ensure that the given raw metadata object contains all required metadata entries.\n * @param metadataRaw A raw metadata object.\n */\nexport function validateMetadataBindings(metadataRaw: Record<string, any>): MetadataBindings {\n  for (const key of [ 'cardinality', 'canContainUndefs', 'variables' ]) {\n    if (!(key in metadataRaw)) {\n      throw new Error(`Invalid metadata: missing ${key} in ${JSON.stringify(metadataRaw)}`);\n    }\n  }\n  return <MetadataBindings> metadataRaw;\n}\n\n/**\n * Convert a metadata callback to a lazy callback where the response value is cached.\n * @param {() => Promise<IMetadata>} metadata A metadata callback\n * @return {() => Promise<{[p: string]: any}>} The callback where the response will be cached.\n */\nexport function cachifyMetadata<M extends IMetadata<T>, T extends RDF.Variable | RDF.QuadTermName>(\n  metadata: () => Promise<M>,\n): () => Promise<M> {\n  let lastReturn: Promise<M> | undefined;\n  return () => {\n    if (!lastReturn) {\n      lastReturn = metadata();\n      lastReturn\n        .then(lastReturnValue => lastReturnValue.state.addInvalidateListener(() => {\n          lastReturn = undefined;\n        }))\n        .catch(() => {\n        // Ignore error\n        });\n    }\n    return lastReturn;\n  };\n}\n"]}