"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorExtractLinksTree = void 0;
const bus_extract_links_1 = require("@comunica/bus-extract-links");
const context_entries_link_traversal_1 = require("@comunica/context-entries-link-traversal");
const rdf_data_factory_1 = require("rdf-data-factory");
const DF = new rdf_data_factory_1.DataFactory();
/**
 * A comunica Extract Links Tree Extract Links Actor.
 */
class ActorExtractLinksTree extends bus_extract_links_1.ActorExtractLinks {
    constructor(args) {
        super(args);
    }
    async test(_action) {
        return true;
    }
    async run(action) {
        return new Promise((resolve, reject) => {
            const strictModeFlag = action.context.get(context_entries_link_traversal_1.KeysExtractLinksTree.strictTraversal);
            const strictMode = strictModeFlag ?? true;
            const metadata = action.metadata;
            const currentNodeUrl = action.url;
            // The relation node value and the subject of the relation are the values of the map
            const relationNodeSubject = new Map();
            const nodeLinks = [];
            const links = [];
            const effectiveTreeDocumentSubject = new Set();
            // Forward errors
            metadata.on('error', reject);
            // Invoke callback on each metadata quad
            metadata.on('data', (quad) => this.getTreeQuadsRawRelations(quad, currentNodeUrl, relationNodeSubject, nodeLinks, effectiveTreeDocumentSubject, strictMode));
            // Resolve to discovered links
            metadata.on('end', () => {
                // If we are not in the loose mode then the subject of the page is the URL
                if (effectiveTreeDocumentSubject.size === 0) {
                    effectiveTreeDocumentSubject.add(currentNodeUrl);
                }
                // Validate if the nodes forward have the current node has implicit subject
                for (const [nodeValue, link] of nodeLinks) {
                    const subjectOfRelation = relationNodeSubject.get(nodeValue);
                    if (subjectOfRelation && effectiveTreeDocumentSubject.has(subjectOfRelation)) {
                        links.push({ url: link, metadata: { producedByActor: { name: this.name } } });
                    }
                }
                resolve({ links });
            });
        });
    }
    /**
     * A helper function to find all the relations of a TREE document and the possible next nodes to visit.
     * The next nodes are not guaranteed to have as subject the URL of the current page,
     * so filtering is necessary afterward.
     * @param quad the current quad.
     * @param url url of the page
     * @param pageRelationNodes the url of the relation node of the page that have as subject the URL of the page
     * @param nodeLinks the url of the next potential page that has to be visited,
     *  regardless if the implicit subject is the node of the page
     */
    getTreeQuadsRawRelations(quad, url, pageRelationNodes, nodeLinks, rootNodeEffectiveSubject, strictMode) {
        if ((!strictMode || quad.subject.value === url) &&
            (quad.predicate.equals(ActorExtractLinksTree.aView) ||
                quad.predicate.equals(ActorExtractLinksTree.aSubset))) {
            rootNodeEffectiveSubject.add(quad.object.value);
        }
        if ((!strictMode || quad.object.value === url) &&
            quad.predicate.equals(ActorExtractLinksTree.isPartOf)) {
            rootNodeEffectiveSubject.add(quad.subject.value);
        }
        if (quad.predicate.equals(ActorExtractLinksTree.aRelation)) {
            // If it's a relation of the current node
            pageRelationNodes.set(quad.object.value, quad.subject.value);
        }
        // If it's a node forward
        if (quad.predicate.equals(ActorExtractLinksTree.aNodeType)) {
            nodeLinks.push([quad.subject.value, quad.object.value]);
        }
    }
}
exports.ActorExtractLinksTree = ActorExtractLinksTree;
ActorExtractLinksTree.aNodeType = DF.namedNode('https://w3id.org/tree#node');
ActorExtractLinksTree.aRelation = DF.namedNode('https://w3id.org/tree#relation');
ActorExtractLinksTree.aView = DF.namedNode('https://w3id.org/tree#view');
ActorExtractLinksTree.aSubset = DF.namedNode('http://rdfs.org/ns/void#subset');
ActorExtractLinksTree.isPartOf = DF.namedNode('http://purl.org/dc/terms/isPartOf');
//# sourceMappingURL=ActorExtractLinksTree.js.map