"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorQueryOperationLeftJoin = void 0;
const bindings_factory_1 = require("@comunica/bindings-factory");
const bus_query_operation_1 = require("@comunica/bus-query-operation");
const expression_evaluator_1 = require("@comunica/expression-evaluator");
/**
 * A comunica LeftJoin Query Operation Actor.
 */
class ActorQueryOperationLeftJoin extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'leftjoin');
    }
    async testOperation(_operation, _context) {
        return true;
    }
    async runOperation(operationOriginal, context) {
        // Delegate to join bus
        const entries = (await Promise.all(operationOriginal.input
            .map(async (subOperation) => ({
            output: await this.mediatorQueryOperation.mediate({ operation: subOperation, context }),
            operation: subOperation,
        }))))
            .map(({ output, operation }) => ({
            output: bus_query_operation_1.ActorQueryOperation.getSafeBindings(output),
            operation,
        }));
        const joined = await this.mediatorJoin.mediate({ type: 'optional', entries, context });
        // If the pattern contains an expression, filter the resulting stream
        if (operationOriginal.expression) {
            const rightMetadata = await entries[1].output.metadata();
            const expressionVariables = rightMetadata.variables;
            const bindingsFactory = await bindings_factory_1.BindingsFactory.create(this.mediatorMergeBindingsContext, context);
            const config = { ...bus_query_operation_1.ActorQueryOperation.getAsyncExpressionContext(context, this.mediatorQueryOperation, bindingsFactory) };
            const evaluator = new expression_evaluator_1.AsyncEvaluator(operationOriginal.expression, config);
            const bindingsStream = joined.bindingsStream
                .transform({
                autoStart: false,
                // eslint-disable-next-line ts/no-misused-promises
                transform: async (bindings, done, push) => {
                    // If variables of the right-hand entry are missing, we skip expression evaluation
                    if (!expressionVariables.every(variable => bindings.has(variable.value))) {
                        push(bindings);
                        return done();
                    }
                    try {
                        const result = await evaluator.evaluateAsEBV(bindings);
                        if (result) {
                            push(bindings);
                        }
                    }
                    catch (error) {
                        // We ignore all Expression errors.
                        // Other errors (likely programming mistakes) are still propagated.
                        // Left Join is defined in terms of Filter (https://www.w3.org/TR/sparql11-query/#defn_algJoin),
                        // and Filter requires this (https://www.w3.org/TR/sparql11-query/#expressions).
                        if ((0, expression_evaluator_1.isExpressionError)(error)) {
                            // In many cases, this is a user error, where the user should manually cast the variable to a string.
                            // In order to help users debug this, we should report these errors via the logger as warnings.
                            this.logWarn(context, 'Error occurred while filtering.', () => ({ error, bindings }));
                        }
                        else {
                            bindingsStream.emit('error', error);
                        }
                    }
                    done();
                },
            });
            joined.bindingsStream = bindingsStream;
        }
        return joined;
    }
}
exports.ActorQueryOperationLeftJoin = ActorQueryOperationLeftJoin;
//# sourceMappingURL=ActorQueryOperationLeftJoin.js.map