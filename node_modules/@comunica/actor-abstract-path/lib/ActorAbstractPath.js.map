{"version":3,"file":"ActorAbstractPath.js","sourceRoot":"","sources":["ActorAbstractPath.ts"],"names":[],"mappings":"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","sourcesContent":["import type { BindingsFactory } from '@comunica/bindings-factory';\nimport type { IActorQueryOperationTypedMediatedArgs } from '@comunica/bus-query-operation';\nimport {\n  ActorQueryOperation,\n  ActorQueryOperationTypedMediated,\n} from '@comunica/bus-query-operation';\nimport { KeysQueryOperation } from '@comunica/context-entries';\nimport type { IActorTest } from '@comunica/core';\nimport type {\n  IQueryOperationResultBindings,\n  Bindings,\n  IActionContext,\n  MetadataBindings,\n  IQuerySourceWrapper,\n} from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport type { AsyncIterator } from 'asynciterator';\nimport {\n  BufferedIterator,\n  MultiTransformIterator,\n  TransformIterator,\n  EmptyIterator,\n} from 'asynciterator';\nimport { DataFactory } from 'rdf-data-factory';\nimport { termToString } from 'rdf-string';\nimport { Algebra, Factory } from 'sparqlalgebrajs';\nimport { PathVariableObjectIterator } from './PathVariableObjectIterator';\n\nconst DF = new DataFactory();\n\n/**\n * An abstract actor that handles Path operations.\n *\n * Provides multiple helper functions used by the Path operation actors.\n */\nexport abstract class ActorAbstractPath extends ActorQueryOperationTypedMediated<Algebra.Path> {\n  protected static readonly FACTORY: Factory = new Factory();\n\n  protected readonly predicateType: string;\n\n  protected constructor(args: IActorQueryOperationTypedMediatedArgs, predicateType: string) {\n    super(args, 'path');\n    this.predicateType = predicateType;\n  }\n\n  public async testOperation(operation: Algebra.Path, _context: IActionContext): Promise<IActorTest> {\n    if (operation.predicate.type !== this.predicateType) {\n      throw new Error(`This Actor only supports ${this.predicateType} Path operations.`);\n    }\n\n    return true;\n  }\n\n  // Generates a variable that does not yet occur in the path\n  public generateVariable(path?: Algebra.Path, name?: string): RDF.Variable {\n    if (!name) {\n      return this.generateVariable(path, 'b');\n    }\n\n    // Path predicates can't contain variables\n    if (path && (path.subject.value === name || path.object.value === name)) {\n      return this.generateVariable(path, `${name}b`);\n    }\n\n    return DF.variable(name);\n  }\n\n  // Such connectivity matching does not introduce duplicates (it does not incorporate any count of the number\n  // of ways the connection can be made) even if the repeated path itself would otherwise result in duplicates.\n  // https://www.w3.org/TR/sparql11-query/#propertypaths\n  public async isPathArbitraryLengthDistinct(context: IActionContext, path: Algebra.Path):\n  Promise<{ context: IActionContext; operation: IQueryOperationResultBindings | undefined }> {\n    if (!context.get(KeysQueryOperation.isPathArbitraryLengthDistinctKey)) {\n      context = context.set(KeysQueryOperation.isPathArbitraryLengthDistinctKey, true);\n      return { context, operation: ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({\n        operation: ActorAbstractPath.FACTORY.createDistinct(path),\n        context,\n      })) };\n    }\n\n    context = context.set(KeysQueryOperation.isPathArbitraryLengthDistinctKey, false);\n    return { context, operation: undefined };\n  }\n\n  private async predicateStarGraphVariable(\n    subject: RDF.Term,\n    object: RDF.Variable,\n    predicate: Algebra.PropertyPathSymbol,\n    graph: RDF.Variable,\n    context: IActionContext,\n    bindingsFactory: BindingsFactory,\n  ): Promise<IPathResultStream> {\n    const sources = this.getPathSources(predicate);\n    // TODO: refactor this with an iterator just like PathVariableObjectIterator so we handle backpressure correctly\n    // Construct path to obtain all graphs where subject exists\n    const predVar = this.generateVariable(ActorAbstractPath.FACTORY\n      .createPath(subject, predicate, object, graph));\n    const findGraphs = ActorAbstractPath.FACTORY.createUnion([\n      this.assignPatternSources(ActorAbstractPath.FACTORY.createPattern(subject, predVar, object, graph), sources),\n      this.assignPatternSources(ActorAbstractPath.FACTORY.createPattern(object, predVar, subject, graph), sources),\n    ]);\n    const results = ActorQueryOperation.getSafeBindings(\n      await this.mediatorQueryOperation.mediate({ context, operation: findGraphs }),\n    );\n\n    const passedGraphs: Set<string> = new Set();\n\n    const bindingsStream = new MultiTransformIterator<Bindings, Bindings>(\n      results.bindingsStream,\n      {\n        multiTransform: (bindings: Bindings) => {\n          // Extract the graph and start a predicate* search starting from subject in each graph\n          const graphValue: RDF.Term = bindings.get(graph)!;\n          if (passedGraphs.has(graphValue.value)) {\n            return new EmptyIterator();\n          }\n          passedGraphs.add(graphValue.value);\n          return new TransformIterator<Bindings>(\n            async() => {\n              const it = new BufferedIterator<RDF.Term>();\n              await this.getObjectsPredicateStar(subject, predicate, graphValue, context, {}, it, { count: 0 });\n              return it.transform<Bindings>({\n                transform(item, next, push) {\n                  push(bindingsFactory.bindings([\n                    [ object, item ],\n                    [ graph, graphValue ],\n                  ]));\n                  next();\n                },\n              });\n            },\n            { maxBufferSize: 128 },\n          );\n        },\n        autoStart: false,\n      },\n    );\n\n    return {\n      bindingsStream,\n      metadata: results.metadata,\n    };\n  }\n\n  /**\n   * Returns an iterator with Bindings of the query subject predicate* ?o or subject predicate+ ?o\n   * If graph is a variable, it will also be in those bindings\n   * @param {Term} subject Term of where we start the predicate* search.\n   * @param {Algebra.PropertyPathSymbol} predicate Predicate of the *-path.\n   * @param {Variable} object Variable of the zeroOrMore-query.\n   * @param {Term} graph The graph in which we search for the pattern. (Possibly a variable)\n   * @param {ActionContext} context The context to pass to sub-opertations\n   * @param emitFirstSubject If the path operation is predicate*, otherwise it is predicate+.\n   * @return {Promise<AsyncIterator<Bindings>} Iterator to where all bindings of query should have been pushed.\n   */\n  public async getObjectsPredicateStarEval(\n    subject: RDF.Term,\n    predicate: Algebra.PropertyPathSymbol,\n    object: RDF.Variable,\n    graph: RDF.Term,\n    context: IActionContext,\n    emitFirstSubject: boolean,\n    bindingsFactory: BindingsFactory,\n  ): Promise<IPathResultStream> {\n    if (graph.termType === 'Variable') {\n      return this.predicateStarGraphVariable(subject, object, predicate, graph, context, bindingsFactory);\n    }\n\n    const it = new PathVariableObjectIterator(\n      subject,\n      predicate,\n      graph,\n      context,\n      this.mediatorQueryOperation,\n      emitFirstSubject,\n    );\n\n    const bindingsStream = it.transform<Bindings>({\n      autoStart: false,\n      transform(item, next, push) {\n        push(bindingsFactory.bindings([[ object, item ]]));\n        next();\n      },\n    });\n\n    return {\n      bindingsStream,\n      async metadata() {\n        const metadata: MetadataBindings = await new Promise((resolve) => {\n          it.getProperty('metadata', (metadataInner: any) => resolve(metadataInner()));\n        });\n        // Increment cardinality by one, because we always have at least one result once we reach this stage.\n        // See the transformation above where we push a single binding.\n        metadata.cardinality.value++;\n        return metadata;\n      },\n    };\n  }\n\n  /**\n   * Pushes all terms to iterator `it` that are a solution of object predicate* ?o.\n   * @param {Term} object Term of where we start the predicate* search.\n   * @param {Algebra.PropertyPathSymbol} predicate Predicate of the *-path.\n   * @param {Term} graph The graph in which we search for the pattern.\n   * @param {ActionContext} context\n   * @param {Record<string, Term>} termHashes Remembers the objects we've already searched for.\n   * @param {BufferedIterator<Term>} it Iterator to push terms to.\n   * @param {any} counter Counts how many searches are in progress to close it when needed (when counter == 0).\n   * @return {Promise<IPathResultStream['metadata']>} The results metadata.\n   */\n  public async getObjectsPredicateStar(\n    object: RDF.Term,\n    predicate: Algebra.PropertyPathSymbol,\n    graph: RDF.Term,\n    context: IActionContext,\n    termHashes: Record<string, RDF.Term>,\n    it: BufferedIterator<RDF.Term>,\n    counter: any,\n  ): Promise<IPathResultStream['metadata'] | undefined> {\n    const termString = termToString(object);\n    if (termHashes[termString]) {\n      return;\n    }\n\n    (<any> it)._push(object);\n    termHashes[termString] = object;\n    counter.count++;\n\n    const thisVariable = this.generateVariable();\n    const path = ActorAbstractPath.FACTORY.createPath(object, predicate, thisVariable, graph);\n    const results = ActorQueryOperation.getSafeBindings(\n      await this.mediatorQueryOperation.mediate({ operation: path, context }),\n    );\n    // TODO: fixme\n    // eslint-disable-next-line ts/no-misused-promises\n    results.bindingsStream.on('data', async(bindings: Bindings) => {\n      const result = bindings.get(thisVariable);\n      await this.getObjectsPredicateStar(result!, predicate, graph, context, termHashes, it, counter);\n    });\n    results.bindingsStream.on('end', () => {\n      if (--counter.count === 0) {\n        it.close();\n      }\n    });\n\n    return results.metadata;\n  }\n\n  /**\n   * Pushes all terms to iterator `it` that are a solution of ?s predicate* ?o.\n   * @param {string} subjectVar String representation of subjectVariable\n   * @param {string} objectVar String representation of objectVariable\n   * @param {Term} subjectVal Term of where we start the predicate* search.\n   * @param {Term} objectVal Found solution for an object, start for the new step.\n   * @param {Algebra.PropertyPathSymbol} predicate Predicate of the *-path.\n   * @param {Term} graph The graph in which we search for the pattern.\n   * @param {ActionContext} context\n   * @param {{[id: string]: Promise<Term[]>}} termHashesGlobal\n   * Remembers solutions for when objectVal is already been calculated, can be reused when same objectVal occurs\n   * @param {{[id: string]: Term}} termHashesCurrentSubject\n   * Remembers the pairs we've already searched for, can stop searching if so.\n   * @param {BufferedIterator<Bindings>} it Iterator to push terms to.\n   * @param {any} counter Counts how many searches are in progress to close it when needed (when counter == 0).\n   * @return {Promise<void>} All solutions of query should have been pushed to it by then.\n   */\n  // Let the iterator `it` emit all bindings of size 2, with subjectStringVariable as value subjectVal\n  // and objectStringVariable as value all nodes reachable through predicate* beginning at objectVal\n  public async getSubjectAndObjectBindingsPredicateStar(\n    subjectVar: RDF.Variable,\n    objectVar: RDF.Variable,\n    subjectVal: RDF.Term,\n    objectVal: RDF.Term,\n    predicate: Algebra.PropertyPathSymbol,\n    graph: RDF.Term,\n    context: IActionContext,\n    termHashesGlobal: Record<string, Promise<RDF.Term[]>>,\n    termHashesCurrentSubject: Record<string, boolean>,\n    it: BufferedIterator<Bindings>,\n    counter: any,\n    bindingsFactory: BindingsFactory,\n  ): Promise<void> {\n    const termString = termToString(objectVal) + termToString(graph);\n\n    // If this combination of subject and object already done, return nothing\n    if (termHashesCurrentSubject[termString]) {\n      return;\n    }\n\n    counter.count++;\n    termHashesCurrentSubject[termString] = true;\n    (<any> it)._push(bindingsFactory.bindings([\n      [ subjectVar, subjectVal ],\n      [ objectVar, objectVal ],\n    ]));\n\n    // If every reachable node from object has already been calculated, use these for current subject too\n    if (termString in termHashesGlobal) {\n      const objects = await termHashesGlobal[termString];\n      for (const object of objects) {\n        await this.getSubjectAndObjectBindingsPredicateStar(\n          subjectVar,\n          objectVar,\n          subjectVal,\n          object,\n          predicate,\n          graph,\n          context,\n          termHashesGlobal,\n          termHashesCurrentSubject,\n          it,\n          counter,\n          bindingsFactory,\n        );\n      }\n      if (--counter.count === 0) {\n        it.close();\n      }\n\n      return;\n    }\n\n    // Construct promise to calculate all reachable nodes from this object\n    // TODO: fixme\n    // eslint-disable-next-line no-async-promise-executor,ts/no-misused-promises\n    const promise = new Promise<RDF.Term[]>(async(resolve, reject) => {\n      const objectsArray: RDF.Term[] = [];\n\n      // Construct path that leads us one step through predicate\n      const thisVariable = this.generateVariable();\n      const path = ActorAbstractPath.FACTORY.createPath(objectVal, predicate, thisVariable, graph);\n      const results = ActorQueryOperation.getSafeBindings(\n        await this.mediatorQueryOperation.mediate({ operation: path, context }),\n      );\n\n      // Recursive call on all neighbours\n      // TODO: fixme\n      // eslint-disable-next-line ts/no-misused-promises\n      results.bindingsStream.on('data', async(bindings: RDF.Bindings) => {\n        const result: RDF.Term = bindings.get(thisVariable)!;\n        objectsArray.push(result);\n        await this.getSubjectAndObjectBindingsPredicateStar(\n          subjectVar,\n          objectVar,\n          subjectVal,\n          result,\n          predicate,\n          graph,\n          context,\n          termHashesGlobal,\n          termHashesCurrentSubject,\n          it,\n          counter,\n          bindingsFactory,\n        );\n      });\n      results.bindingsStream.on('error', reject);\n      results.bindingsStream.on('end', () => {\n        if (--counter.count === 0) {\n          it.close();\n        }\n        resolve(objectsArray);\n      });\n    });\n\n    // Set it in the termHashesGlobal when this object occurs again they can wait for this promise\n    termHashesGlobal[termString] = promise;\n  }\n\n  /**\n   * Find all sources recursively contained in the given path operation.\n   * @param operation\n   */\n  public getPathSources(operation: Algebra.PropertyPathSymbol): IQuerySourceWrapper[] {\n    switch (operation.type) {\n      case Algebra.types.ALT:\n      case Algebra.types.SEQ:\n        return operation.input\n          .flatMap((subOp: Algebra.PropertyPathSymbol) => this.getPathSources(subOp));\n      case Algebra.types.INV:\n      case Algebra.types.ONE_OR_MORE_PATH:\n      case Algebra.types.ZERO_OR_MORE_PATH:\n      case Algebra.types.ZERO_OR_ONE_PATH:\n        return this.getPathSources(operation.path);\n      case Algebra.types.LINK:\n      case Algebra.types.NPS: {\n        const source = ActorQueryOperation.getOperationSource(operation);\n        if (!source) {\n          throw new Error(`Could not find a required source on a link path operation`);\n        }\n        return [ source ];\n      }\n    }\n  }\n\n  public assignPatternSources(pattern: Algebra.Pattern, sources: IQuerySourceWrapper[]): Algebra.Operation {\n    if (sources.length === 0) {\n      throw new Error(`Attempted to assign zero sources to a pattern during property path handling`);\n    }\n    if (sources.length === 1) {\n      return ActorQueryOperation.assignOperationSource(pattern, sources[0]);\n    }\n    return ActorAbstractPath.FACTORY.createUnion(sources\n      .map(source => ActorQueryOperation.assignOperationSource(pattern, source)), true);\n  }\n}\n\nexport interface IPathResultStream {\n  bindingsStream: AsyncIterator<Bindings>;\n  metadata: () => Promise<MetadataBindings>;\n}\n"]}