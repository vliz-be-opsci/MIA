{"version":3,"file":"ActorOptimizeQueryOperationAssignSourcesExhaustive.js","sourceRoot":"","sources":["ActorOptimizeQueryOperationAssignSourcesExhaustive.ts"],"names":[],"mappings":";;;AAKA,yFAAqF;AACrF,uEAAoE;AACpE,yEAAyE;AACzE,+DAAkG;AAGlG,qDAAgD;AAEhD;;GAEG;AACH,MAAa,kDAAmD,SAAQ,0DAA2B;IACjG,YAAmB,IAAsC;QACvD,KAAK,CAAC,IAAI,CAAC,CAAC;IACd,CAAC;IAEM,KAAK,CAAC,IAAI,CAAC,OAAsC;QACtD,OAAO,IAAI,CAAC;IACd,CAAC;IAEM,KAAK,CAAC,GAAG,CAAC,MAAqC;QACpD,MAAM,OAAO,GAA0B,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,oCAAkB,CAAC,YAAY,CAAC,IAAI,EAAE,CAAC;QACjG,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACzB,OAAO,EAAE,SAAS,EAAE,MAAM,CAAC,SAAS,EAAE,OAAO,EAAE,MAAM,CAAC,OAAO,EAAE,CAAC;QAClE,CAAC;QACD,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACzB,MAAM,aAAa,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;YACjC,MAAM,WAAW,GAAiC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,oCAAkB,CAAC,WAAW,CAAC,CAAC;YACrG,IAAI,CAAC,WAAW,IAAI,aAAa,CAAC,MAAM,CAAC,cAAc,KAAK,IAAA,8CAAuB,EAAC,WAAW,CAAC,EAAE,CAAC;gBACjG,IAAI,CAAC;oBACH,MAAM,KAAK,GAAG,MAAM,aAAa,CAAC,MAAM,CAAC,gBAAgB,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;oBAC1E,IAAI,yCAAmB,CAAC,wBAAwB,CAAC,KAAK,EAAE,MAAM,CAAC,SAAS,CAAC,EAAE,CAAC;wBAC1E,OAAO;4BACL,SAAS,EAAE,yCAAmB,CAAC,qBAAqB,CAAC,MAAM,CAAC,SAAS,EAAE,aAAa,CAAC;4BACrF,OAAO,EAAE,MAAM,CAAC,OAAO;yBACxB,CAAC;oBACJ,CAAC;gBACH,CAAC;gBAAC,MAAM,CAAC;oBACP,uEAAuE;oBACvE,kDAAkD;gBACpD,CAAC;YACH,CAAC;QACH,CAAC;QACD,OAAO;YACL,SAAS,EAAE,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,SAAS,EAAE,OAAO,CAAC;YAC3D,2GAA2G;YAC3G,iEAAiE;YACjE,OAAO,EAAE,MAAM,CAAC,OAAO;iBACpB,MAAM,CAAC,+BAAa,CAAC,WAAW,CAAC;SACrC,CAAC;IACJ,CAAC;IAED;;;;;;OAMG;IACI,gBAAgB,CAAC,SAA4B,EAAE,OAA8B;QAClF,4CAA4C;QAC5C,MAAM,IAAI,GAAG,IAAI,CAAC;QAClB,OAAO,sBAAI,CAAC,YAAY,CAAC,SAAS,EAAE;YAClC,CAAC,yBAAO,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,YAAY,EAAE,OAAO;gBAC3C,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;oBACzB,OAAO;wBACL,MAAM,EAAE,yCAAmB,CAAC,qBAAqB,CAAC,YAAY,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC;wBAC3E,OAAO,EAAE,KAAK;qBACf,CAAC;gBACJ,CAAC;gBACD,OAAO;oBACL,MAAM,EAAE,OAAO,CAAC,WAAW,CAAC,OAAO;yBAChC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,yCAAmB,CAAC,qBAAqB,CAAC,YAAY,EAAE,MAAM,CAAC,CAAC,CAAC;oBAClF,OAAO,EAAE,KAAK;iBACf,CAAC;YACJ,CAAC;YACD,CAAC,yBAAO,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,YAAY,EAAE,OAAO;gBACxC,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;oBACzB,OAAO;wBACL,MAAM,EAAE,yCAAmB,CAAC,qBAAqB,CAAC,YAAY,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC;wBAC3E,OAAO,EAAE,KAAK;qBACf,CAAC;gBACJ,CAAC;gBACD,OAAO;oBACL,MAAM,EAAE,OAAO,CAAC,SAAS,CAAC,OAAO;yBAC9B,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,yCAAmB,CAAC,qBAAqB,CAAC,YAAY,EAAE,MAAM,CAAC,CAAC,CAAC;oBAClF,OAAO,EAAE,KAAK;iBACf,CAAC;YACJ,CAAC;YACD,CAAC,yBAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,YAAY,EAAE,OAAO;gBACvC,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;oBACzB,OAAO;wBACL,MAAM,EAAE,yCAAmB,CAAC,qBAAqB,CAAC,YAAY,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC;wBAC3E,OAAO,EAAE,KAAK;qBACf,CAAC;gBACJ,CAAC;gBACD,OAAO;oBACL,MAAM,EAAE,OAAO,CAAC,SAAS,CAAC,OAAO;yBAC9B,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,yCAAmB,CAAC,qBAAqB,CAAC,YAAY,EAAE,MAAM,CAAC,CAAC,CAAC;oBAClF,OAAO,EAAE,KAAK;iBACf,CAAC;YACJ,CAAC;YACD,CAAC,yBAAO,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,YAAY;gBAClC,OAAO;oBACL,MAAM,EAAE,YAAY;oBACpB,OAAO,EAAE,KAAK;iBACf,CAAC;YACJ,CAAC;YACD,CAAC,yBAAO,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,YAAY,EAAE,OAAO;gBAC7C,OAAO;oBACL,MAAM,EAAE,OAAO,CAAC,eAAe,CAC7B,IAAI,CAAC,gBAAgB,CAAC,YAAY,CAAC,KAAK,EAAE,OAAO,CAAC,EAClD,YAAY,CAAC,QAAQ,CACtB;oBACD,OAAO,EAAE,KAAK;iBACf,CAAC;YACJ,CAAC;YACD,CAAC,yBAAO,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC,YAAY,EAAE,OAAO;gBACjD,OAAO;oBACL,MAAM,EAAE,OAAO,CAAC,kBAAkB,CAChC,YAAY,CAAC,MAAM,EACnB,YAAY,CAAC,MAAM,EACnB,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,gBAAgB,CAAC,YAAY,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC,CAAC,CAAC,SAAS,CACpF;oBACD,OAAO,EAAE,KAAK;iBACf,CAAC;YACJ,CAAC;SACF,CAAC,CAAC;IACL,CAAC;CACF;AAtHD,gHAsHC","sourcesContent":["import type {\n  IActionOptimizeQueryOperation,\n  IActorOptimizeQueryOperationOutput,\n  IActorOptimizeQueryOperationArgs,\n} from '@comunica/bus-optimize-query-operation';\nimport { ActorOptimizeQueryOperation } from '@comunica/bus-optimize-query-operation';\nimport { ActorQueryOperation } from '@comunica/bus-query-operation';\nimport { getDataDestinationValue } from '@comunica/bus-rdf-update-quads';\nimport { KeysInitQuery, KeysQueryOperation, KeysRdfUpdateQuads } from '@comunica/context-entries';\nimport type { IActorTest } from '@comunica/core';\nimport type { IDataDestination, IQuerySourceWrapper } from '@comunica/types';\nimport { Algebra, Util } from 'sparqlalgebrajs';\n\n/**\n * A comunica Assign Sources Exhaustive Optimize Query Operation Actor.\n */\nexport class ActorOptimizeQueryOperationAssignSourcesExhaustive extends ActorOptimizeQueryOperation {\n  public constructor(args: IActorOptimizeQueryOperationArgs) {\n    super(args);\n  }\n\n  public async test(_action: IActionOptimizeQueryOperation): Promise<IActorTest> {\n    return true;\n  }\n\n  public async run(action: IActionOptimizeQueryOperation): Promise<IActorOptimizeQueryOperationOutput> {\n    const sources: IQuerySourceWrapper[] = action.context.get(KeysQueryOperation.querySources) ?? [];\n    if (sources.length === 0) {\n      return { operation: action.operation, context: action.context };\n    }\n    if (sources.length === 1) {\n      const sourceWrapper = sources[0];\n      const destination: IDataDestination | undefined = action.context.get(KeysRdfUpdateQuads.destination);\n      if (!destination || sourceWrapper.source.referenceValue === getDataDestinationValue(destination)) {\n        try {\n          const shape = await sourceWrapper.source.getSelectorShape(action.context);\n          if (ActorQueryOperation.doesShapeAcceptOperation(shape, action.operation)) {\n            return {\n              operation: ActorQueryOperation.assignOperationSource(action.operation, sourceWrapper),\n              context: action.context,\n            };\n          }\n        } catch {\n          // Fallback to the default case when the selector shape does not exist,\n          // which can occur for a non-existent destination.\n        }\n      }\n    }\n    return {\n      operation: this.assignExhaustive(action.operation, sources),\n      // We only keep queryString in the context if we only have a single source that accepts the full operation.\n      // In that case, the queryString can be sent to the source as-is.\n      context: action.context\n        .delete(KeysInitQuery.queryString),\n    };\n  }\n\n  /**\n   * Assign the given sources to the leaves in the given query operation.\n   * Leaves will be wrapped in a union operation and duplicated for every source.\n   * The input operation will not be modified.\n   * @param operation The input operation.\n   * @param sources The sources to assign.\n   */\n  public assignExhaustive(operation: Algebra.Operation, sources: IQuerySourceWrapper[]): Algebra.Operation {\n    // eslint-disable-next-line ts/no-this-alias\n    const self = this;\n    return Util.mapOperation(operation, {\n      [Algebra.types.PATTERN](subOperation, factory) {\n        if (sources.length === 1) {\n          return {\n            result: ActorQueryOperation.assignOperationSource(subOperation, sources[0]),\n            recurse: false,\n          };\n        }\n        return {\n          result: factory.createUnion(sources\n            .map(source => ActorQueryOperation.assignOperationSource(subOperation, source))),\n          recurse: false,\n        };\n      },\n      [Algebra.types.LINK](subOperation, factory) {\n        if (sources.length === 1) {\n          return {\n            result: ActorQueryOperation.assignOperationSource(subOperation, sources[0]),\n            recurse: false,\n          };\n        }\n        return {\n          result: factory.createAlt(sources\n            .map(source => ActorQueryOperation.assignOperationSource(subOperation, source))),\n          recurse: false,\n        };\n      },\n      [Algebra.types.NPS](subOperation, factory) {\n        if (sources.length === 1) {\n          return {\n            result: ActorQueryOperation.assignOperationSource(subOperation, sources[0]),\n            recurse: false,\n          };\n        }\n        return {\n          result: factory.createAlt(sources\n            .map(source => ActorQueryOperation.assignOperationSource(subOperation, source))),\n          recurse: false,\n        };\n      },\n      [Algebra.types.SERVICE](subOperation) {\n        return {\n          result: subOperation,\n          recurse: false,\n        };\n      },\n      [Algebra.types.CONSTRUCT](subOperation, factory) {\n        return {\n          result: factory.createConstruct(\n            self.assignExhaustive(subOperation.input, sources),\n            subOperation.template,\n          ),\n          recurse: false,\n        };\n      },\n      [Algebra.types.DELETE_INSERT](subOperation, factory) {\n        return {\n          result: factory.createDeleteInsert(\n            subOperation.delete,\n            subOperation.insert,\n            subOperation.where ? self.assignExhaustive(subOperation.where, sources) : undefined,\n          ),\n          recurse: false,\n        };\n      },\n    });\n  }\n}\n"]}