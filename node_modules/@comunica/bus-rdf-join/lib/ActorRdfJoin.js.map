{"version":3,"file":"ActorRdfJoin.js","sourceRoot":"","sources":["ActorRdfJoin.ts"],"names":[],"mappings":"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","sourcesContent":["import type { MediatorRdfJoinEntriesSort } from '@comunica/bus-rdf-join-entries-sort';\nimport type {\n  MediatorRdfJoinSelectivity,\n} from '@comunica/bus-rdf-join-selectivity';\nimport { KeysInitQuery } from '@comunica/context-entries';\nimport type { IAction, IActorArgs, Mediate } from '@comunica/core';\nimport { Actor } from '@comunica/core';\nimport type { IMediatorTypeJoinCoefficients } from '@comunica/mediatortype-join-coefficients';\nimport { cachifyMetadata, MetadataValidationState } from '@comunica/metadata';\nimport type {\n  IQueryOperationResultBindings,\n  MetadataBindings,\n  IPhysicalQueryPlanLogger,\n  Bindings,\n  IActionContext,\n  IJoinEntry,\n  IJoinEntryWithMetadata,\n} from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport { DataFactory } from 'rdf-data-factory';\n\nconst DF = new DataFactory();\n\n/**\n * A comunica actor for joining 2 binding streams.\n *\n * Actor types:\n * * Input:  IActionRdfJoin:                The streams that need to be joined.\n * * Test:   IMediatorTypeJoinCoefficients: Join coefficients.\n * * Output: IActorRdfJoinOutput:           The resulting joined stream.\n *\n * @see IActionRdfJoin\n * @see IActorQueryOperationOutput\n */\nexport abstract class ActorRdfJoin\n  extends Actor<IActionRdfJoin, IMediatorTypeJoinCoefficients, IQueryOperationResultBindings> {\n  public readonly mediatorJoinSelectivity: MediatorRdfJoinSelectivity;\n\n  /**\n   * If this actor will be logged in the debugger and physical query plan logger\n   */\n  public includeInLogs = true;\n  public readonly logicalType: LogicalJoinType;\n  public readonly physicalName: string;\n  /**\n   * Can be used by subclasses to indicate the max or min number of streams that can be joined.\n   * 0 for infinity.\n   * By default, this indicates the max number, but can be inverted by setting limitEntriesMin to true.\n   */\n  protected readonly limitEntries: number;\n  /**\n   * If true, the limitEntries field is a lower limit,\n   * otherwise, it is an upper limit.\n   */\n  protected readonly limitEntriesMin: boolean;\n  /**\n   * If this actor can handle undefs in the bindings.\n   */\n  protected readonly canHandleUndefs: boolean;\n\n  /**\n   * @param args - @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus\n   * @param options - Actor-specific join options.\n   */\n  public constructor(args: IActorRdfJoinArgs, options: IActorRdfJoinInternalOptions) {\n    super(args);\n    this.logicalType = options.logicalType;\n    this.physicalName = options.physicalName;\n    this.limitEntries = options.limitEntries ?? Number.POSITIVE_INFINITY;\n    this.limitEntriesMin = options.limitEntriesMin ?? false;\n    this.canHandleUndefs = options.canHandleUndefs ?? false;\n  }\n\n  /**\n   * Creates a hash of the given bindings by concatenating the results of the given variables.\n   * This function will not sort the variables and expects them to be in the same order for every call.\n   * @param {Bindings} bindings\n   * @param {string[]} variables\n   * @returns {string} A hash string.\n   */\n  public static hash(bindings: Bindings, variables: RDF.Variable[]): string {\n    return variables\n      .map((variable) => {\n        const term = bindings.get(variable);\n        if (term) {\n          return term.value;\n        }\n        return '';\n      })\n      .join('');\n  }\n\n  /**\n   * Returns an array containing all the variable names that occur in all bindings streams.\n   * @param {MetadataBindings[]} metadatas An array of optional metadata objects for the entries.\n   * @returns {RDF.Variable[]} An array of variables.\n   */\n  public static overlappingVariables(metadatas: MetadataBindings[]): RDF.Variable[] {\n    const variables = metadatas.map(metadata => metadata.variables);\n    let baseArray = variables[0];\n    for (const array of variables.slice(1)) {\n      baseArray = baseArray.filter(el => array.some(value => value.value === el.value));\n    }\n    return baseArray;\n  }\n\n  /**\n   * Returns the variables that will occur in the joined bindings.\n   * @param {MetadataBindings[]} metadatas An array of metadata objects for the entries.\n   * @returns {RDF.Variable[]} An array of joined variables.\n   */\n  public static joinVariables(metadatas: MetadataBindings[]): RDF.Variable[] {\n    return [ ...new Set(metadatas.flatMap(metadata => metadata.variables.map(variable => variable.value))) ]\n      .map(variable => DF.variable(variable));\n  }\n\n  /**\n   * Returns the result of joining bindings, or `null` if no join is possible.\n   * @param {Bindings[]} bindings\n   * @returns {Bindings}\n   */\n\n  public static joinBindings(...bindings: Bindings[]): Bindings | null {\n    if (bindings.length === 0) {\n      return null;\n    }\n    if (bindings.length === 1) {\n      return bindings[0];\n    }\n\n    let acc: Bindings = bindings[0];\n    for (const binding of bindings.slice(1)) {\n      const merged = acc.merge(binding);\n      if (!merged) {\n        return null;\n      }\n      acc = merged;\n    }\n    return acc;\n  }\n\n  /**\n   * Get the estimated number of items from the given metadata.\n   * @param {Record<string, any>} metadata A metadata object.\n   * @return {number} The estimated number of items, or `Infinity` if cardinality is falsy.\n   */\n  public static getCardinality(metadata: MetadataBindings): RDF.QueryResultCardinality {\n    return metadata.cardinality;\n  }\n\n  /**\n   * Obtain the metadata from all given join entries.\n   * @param entries Join entries.\n   */\n  public static async getMetadatas(entries: IJoinEntry[]): Promise<MetadataBindings[]> {\n    return await Promise.all(entries.map(entry => entry.output.metadata()));\n  }\n\n  /**\n   * Obtain the join entries witt metadata from all given join entries.\n   * @param entries Join entries.\n   */\n  public static async getEntriesWithMetadatas(entries: IJoinEntry[]): Promise<IJoinEntryWithMetadata[]> {\n    const metadatas = await ActorRdfJoin.getMetadatas(entries);\n    return entries.map((entry, i) => ({ ...entry, metadata: metadatas[i] }));\n  }\n\n  /**\n   * Calculate the time to initiate a request for the given metadata entries.\n   * @param metadatas An array of checked metadata.\n   */\n  public static getRequestInitialTimes(metadatas: MetadataBindings[]): number[] {\n    return metadatas.map(metadata => metadata.pageSize ? 0 : metadata.requestTime ?? 0);\n  }\n\n  /**\n   * Calculate the time to receive a single item for the given metadata entries.\n   * @param metadatas An array of checked metadata.\n   */\n  public static getRequestItemTimes(metadatas: MetadataBindings[]): number[] {\n    return metadatas\n      .map(metadata => metadata.pageSize ? (metadata.requestTime ?? 0) / metadata.pageSize : 0);\n  }\n\n  /**\n   * Helper function to create a new metadata object for the join result.\n   * For required metadata entries that are not provided, sane defaults are calculated.\n   * @param entries Join entries.\n   * @param metadatas Metadata of the join entries.\n   * @param context The action context.\n   * @param partialMetadata Partial metadata entries.\n   */\n  public async constructResultMetadata(\n    entries: IJoinEntry[],\n    metadatas: MetadataBindings[],\n    context: IActionContext,\n    partialMetadata: Partial<MetadataBindings> = {},\n  ): Promise<MetadataBindings> {\n    let cardinalityJoined: RDF.QueryResultCardinality;\n    if (partialMetadata.cardinality) {\n      cardinalityJoined = partialMetadata.cardinality;\n    } else {\n      cardinalityJoined = metadatas\n        .reduce((acc: RDF.QueryResultCardinality, metadata) => {\n          const cardinalityThis = ActorRdfJoin.getCardinality(metadata);\n          return {\n            type: cardinalityThis.type === 'estimate' ? 'estimate' : acc.type,\n            value: acc.value * cardinalityThis.value,\n          };\n        }, { type: 'exact', value: 1 });\n      cardinalityJoined.value *= (await this.mediatorJoinSelectivity.mediate({ entries, context })).selectivity;\n    }\n\n    // Propagate metadata invalidations\n    const state = new MetadataValidationState();\n    const invalidateListener = (): void => state.invalidate();\n    for (const metadata of metadatas) {\n      metadata.state.addInvalidateListener(invalidateListener);\n    }\n\n    return {\n      state,\n      ...partialMetadata,\n      cardinality: {\n        type: cardinalityJoined.type,\n        value: cardinalityJoined.value,\n      },\n      canContainUndefs: partialMetadata.canContainUndefs ?? metadatas.some(metadata => metadata.canContainUndefs),\n      variables: ActorRdfJoin.joinVariables(metadatas),\n    };\n  }\n\n  /**\n   * Order the given join entries using the join-entries-sort bus.\n   * @param {MediatorRdfJoinEntriesSort} mediatorJoinEntriesSort A mediator for sorting join entries.\n   * @param {IJoinEntryWithMetadata[]} entries An array of join entries.\n   * @param context The action context.\n   * @return {IJoinEntryWithMetadata[]} The sorted join entries.\n   */\n  public static async sortJoinEntries(\n    mediatorJoinEntriesSort: MediatorRdfJoinEntriesSort,\n    entries: IJoinEntryWithMetadata[],\n    context: IActionContext,\n  ): Promise<IJoinEntryWithMetadata[]> {\n    // If there is a stream that can contain undefs, we don't modify the join order.\n    const canContainUndefs = entries.some(entry => entry.metadata.canContainUndefs);\n    if (canContainUndefs) {\n      return entries;\n    }\n\n    // Calculate number of occurrences of each variable\n    const variableOccurrences: Record<string, number> = {};\n    for (const entry of entries) {\n      for (const variable of entry.metadata.variables) {\n        let counter = variableOccurrences[variable.value];\n        if (!counter) {\n          counter = 0;\n        }\n        variableOccurrences[variable.value] = ++counter;\n      }\n    }\n\n    // Determine variables that occur in at least two join entries\n    const multiOccurrenceVariables: string[] = [];\n    for (const [ variable, count ] of Object.entries(variableOccurrences)) {\n      if (count >= 2) {\n        multiOccurrenceVariables.push(variable);\n      }\n    }\n\n    // Reject if no entries have common variables\n    if (multiOccurrenceVariables.length === 0) {\n      throw new Error(`Bind join can only join entries with at least one common variable`);\n    }\n\n    // Determine entries without common variables\n    // These will be placed in the back of the sorted array\n    const entriesWithoutCommonVariables: IJoinEntryWithMetadata[] = [];\n    for (const entry of entries) {\n      let hasCommon = false;\n      for (const variable of entry.metadata.variables) {\n        if (multiOccurrenceVariables.includes(variable.value)) {\n          hasCommon = true;\n          break;\n        }\n      }\n      if (!hasCommon) {\n        entriesWithoutCommonVariables.push(entry);\n      }\n    }\n\n    return (await mediatorJoinEntriesSort.mediate({ entries, context })).entries\n      .sort((entryLeft, entryRight) => {\n        // Sort to make sure that entries without common variables come last in the array.\n        // For all other entries, the original order is kept.\n        const leftWithoutCommonVariables = entriesWithoutCommonVariables.includes(entryLeft);\n        const rightWithoutCommonVariables = entriesWithoutCommonVariables.includes(entryRight);\n        if (leftWithoutCommonVariables === rightWithoutCommonVariables) {\n          return 0;\n        }\n        return leftWithoutCommonVariables ?\n          1 :\n            -1;\n      });\n  }\n\n  /**\n   * Default test function for join actors.\n   * Checks whether all iterators have metadata.\n   * If yes: call the abstract getIterations method, if not: return Infinity.\n   * @param {IActionRdfJoin} action The input action containing the relevant iterators\n   * @returns {Promise<IMediatorTypeJoinCoefficients>} The join coefficients.\n   */\n  public async test(action: IActionRdfJoin): Promise<IMediatorTypeJoinCoefficients> {\n    // Validate logical join type\n    if (action.type !== this.logicalType) {\n      throw new Error(`${this.name} can only handle logical joins of type '${this.logicalType}', while '${action.type}' was given.`);\n    }\n\n    // Don't allow joining of one or zero streams\n    if (action.entries.length <= 1) {\n      throw new Error(`${this.name} requires at least two join entries.`);\n    }\n\n    // Check if this actor can handle the given number of streams\n    if (this.limitEntriesMin ? action.entries.length < this.limitEntries : action.entries.length > this.limitEntries) {\n      throw new Error(`${this.name} requires ${this.limitEntries\n      } join entries at ${this.limitEntriesMin ? 'least' : 'most'\n      }. The input contained ${action.entries.length}.`);\n    }\n\n    // Check if all streams are bindings streams\n    for (const entry of action.entries) {\n      if (entry.output.type !== 'bindings') {\n        // eslint-disable-next-line ts/restrict-template-expressions\n        throw new Error(`Invalid type of a join entry: Expected 'bindings' but got '${entry.output.type}'`);\n      }\n    }\n\n    const metadatas = await ActorRdfJoin.getMetadatas(action.entries);\n\n    // Check if this actor can handle undefs\n    if (!this.canHandleUndefs) {\n      for (const metadata of metadatas) {\n        if (metadata.canContainUndefs) {\n          throw new Error(`Actor ${this.name} can not join streams containing undefs`);\n        }\n      }\n    }\n\n    return await this.getJoinCoefficients(action, metadatas);\n  }\n\n  /**\n   * Returns default input for 0 or 1 entries. Calls the getOutput function otherwise\n   * @param {IActionRdfJoin} action\n   * @returns {Promise<IQueryOperationResultBindings>} A bindings result.\n   */\n  public async run(action: IActionRdfJoin): Promise<IQueryOperationResultBindings> {\n    // Prepare logging to physical plan\n    // This must be called before getOutput, because we need to override the plan node in the context\n    let parentPhysicalQueryPlanNode;\n    if (action.context.has(KeysInitQuery.physicalQueryPlanLogger)) {\n      parentPhysicalQueryPlanNode = action.context.get(KeysInitQuery.physicalQueryPlanNode);\n      action.context = action.context.set(KeysInitQuery.physicalQueryPlanNode, action);\n    }\n\n    // Log to physical plan\n    const physicalQueryPlanLogger: IPhysicalQueryPlanLogger | undefined = action.context.get(KeysInitQuery\n      .physicalQueryPlanLogger);\n    let planMetadata: any;\n    if (this.includeInLogs && physicalQueryPlanLogger) {\n      planMetadata = {};\n      physicalQueryPlanLogger.logOperation(\n        `join-${this.logicalType}`,\n        this.physicalName,\n        action,\n        parentPhysicalQueryPlanNode,\n        this.name,\n        planMetadata,\n      );\n    }\n\n    // Get action output\n    const { result, physicalPlanMetadata } = await this.getOutput(action);\n    const metadatas = await ActorRdfJoin.getMetadatas(action.entries);\n\n    // Fill in the physical plan metadata after determining action output\n    if (planMetadata) {\n      Object.assign(planMetadata, physicalPlanMetadata);\n      planMetadata.cardinalities = metadatas.map(ActorRdfJoin.getCardinality);\n      planMetadata.joinCoefficients = await this.getJoinCoefficients(action, metadatas);\n    }\n\n    // Cache metadata\n    result.metadata = cachifyMetadata(result.metadata);\n\n    return result;\n  }\n\n  /**\n   * Returns the resulting output for joining the given entries.\n   * This is called after removing the trivial cases in run.\n   * @param {IActionRdfJoin} action\n   * @returns {Promise<IActorRdfJoinOutputInner>}\n   */\n  protected abstract getOutput(action: IActionRdfJoin): Promise<IActorRdfJoinOutputInner>;\n\n  /**\n   * Calculate the join coefficients.\n   * @param {IActionRdfJoin} action Join action\n   * @param metadatas Array of resolved metadata objects.\n   * @returns {IMediatorTypeJoinCoefficients} The join coefficient estimates.\n   */\n  protected abstract getJoinCoefficients(\n    action: IActionRdfJoin,\n    metadatas: MetadataBindings[],\n  ): Promise<IMediatorTypeJoinCoefficients>;\n}\n\nexport interface IActorRdfJoinArgs\n  extends IActorArgs<IActionRdfJoin, IMediatorTypeJoinCoefficients, IQueryOperationResultBindings> {\n  mediatorJoinSelectivity: MediatorRdfJoinSelectivity;\n}\n\nexport interface IActorRdfJoinInternalOptions {\n  /**\n   * The logical join type this actor can handle.\n   */\n  logicalType: LogicalJoinType;\n  /**\n   * The physical name of join operation this actor implements.\n   * This is used for debug and query plan logs.\n   */\n  physicalName: string;\n  /**\n   * Can be used by subclasses to indicate the max or min number of streams that can be joined.\n   * 0 for infinity.\n   * By default, this indicates the max number, but can be inverted by setting limitEntriesMin to true.\n   */\n  limitEntries?: number;\n  /**\n   * If true, the limitEntries field is a lower limit,\n   * otherwise, it is an upper limit.\n   * Defaults to false.\n   */\n  limitEntriesMin?: boolean;\n  /**\n   * If this actor can handle undefs in the bindings.\n   * Defaults to false.\n   */\n  canHandleUndefs?: boolean;\n}\n\n/**\n * Represents a logical join type.\n */\nexport type LogicalJoinType = 'inner' | 'optional' | 'minus';\n\nexport interface IActionRdfJoin extends IAction {\n  /**\n   * The logical join type.\n   */\n  type: LogicalJoinType;\n  /**\n   * The array of streams to join.\n   */\n  entries: IJoinEntry[];\n}\n\nexport interface IActorRdfJoinOutputInner {\n  /**\n   * The join result.\n   */\n  result: IQueryOperationResultBindings;\n  /**\n   * Optional metadata that will be included as metadata within the physical query plan output.\n   */\n  physicalPlanMetadata?: any;\n}\n\nexport type MediatorRdfJoin = Mediate<IActionRdfJoin, IQueryOperationResultBindings, IMediatorTypeJoinCoefficients>;\n"]}