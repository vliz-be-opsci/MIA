"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorRdfJoin = void 0;
const context_entries_1 = require("@comunica/context-entries");
const core_1 = require("@comunica/core");
const metadata_1 = require("@comunica/metadata");
const rdf_data_factory_1 = require("rdf-data-factory");
const DF = new rdf_data_factory_1.DataFactory();
/**
 * A comunica actor for joining 2 binding streams.
 *
 * Actor types:
 * * Input:  IActionRdfJoin:                The streams that need to be joined.
 * * Test:   IMediatorTypeJoinCoefficients: Join coefficients.
 * * Output: IActorRdfJoinOutput:           The resulting joined stream.
 *
 * @see IActionRdfJoin
 * @see IActorQueryOperationOutput
 */
class ActorRdfJoin extends core_1.Actor {
    /**
     * @param args - @defaultNested {<default_bus> a <cc:components/Bus.jsonld#Bus>} bus
     * @param options - Actor-specific join options.
     */
    constructor(args, options) {
        super(args);
        /**
         * If this actor will be logged in the debugger and physical query plan logger
         */
        this.includeInLogs = true;
        this.logicalType = options.logicalType;
        this.physicalName = options.physicalName;
        this.limitEntries = options.limitEntries ?? Number.POSITIVE_INFINITY;
        this.limitEntriesMin = options.limitEntriesMin ?? false;
        this.canHandleUndefs = options.canHandleUndefs ?? false;
    }
    /**
     * Creates a hash of the given bindings by concatenating the results of the given variables.
     * This function will not sort the variables and expects them to be in the same order for every call.
     * @param {Bindings} bindings
     * @param {string[]} variables
     * @returns {string} A hash string.
     */
    static hash(bindings, variables) {
        return variables
            .map((variable) => {
            const term = bindings.get(variable);
            if (term) {
                return term.value;
            }
            return '';
        })
            .join('');
    }
    /**
     * Returns an array containing all the variable names that occur in all bindings streams.
     * @param {MetadataBindings[]} metadatas An array of optional metadata objects for the entries.
     * @returns {RDF.Variable[]} An array of variables.
     */
    static overlappingVariables(metadatas) {
        const variables = metadatas.map(metadata => metadata.variables);
        let baseArray = variables[0];
        for (const array of variables.slice(1)) {
            baseArray = baseArray.filter(el => array.some(value => value.value === el.value));
        }
        return baseArray;
    }
    /**
     * Returns the variables that will occur in the joined bindings.
     * @param {MetadataBindings[]} metadatas An array of metadata objects for the entries.
     * @returns {RDF.Variable[]} An array of joined variables.
     */
    static joinVariables(metadatas) {
        return [...new Set(metadatas.flatMap(metadata => metadata.variables.map(variable => variable.value)))]
            .map(variable => DF.variable(variable));
    }
    /**
     * Returns the result of joining bindings, or `null` if no join is possible.
     * @param {Bindings[]} bindings
     * @returns {Bindings}
     */
    static joinBindings(...bindings) {
        if (bindings.length === 0) {
            return null;
        }
        if (bindings.length === 1) {
            return bindings[0];
        }
        let acc = bindings[0];
        for (const binding of bindings.slice(1)) {
            const merged = acc.merge(binding);
            if (!merged) {
                return null;
            }
            acc = merged;
        }
        return acc;
    }
    /**
     * Get the estimated number of items from the given metadata.
     * @param {Record<string, any>} metadata A metadata object.
     * @return {number} The estimated number of items, or `Infinity` if cardinality is falsy.
     */
    static getCardinality(metadata) {
        return metadata.cardinality;
    }
    /**
     * Obtain the metadata from all given join entries.
     * @param entries Join entries.
     */
    static async getMetadatas(entries) {
        return await Promise.all(entries.map(entry => entry.output.metadata()));
    }
    /**
     * Obtain the join entries witt metadata from all given join entries.
     * @param entries Join entries.
     */
    static async getEntriesWithMetadatas(entries) {
        const metadatas = await ActorRdfJoin.getMetadatas(entries);
        return entries.map((entry, i) => ({ ...entry, metadata: metadatas[i] }));
    }
    /**
     * Calculate the time to initiate a request for the given metadata entries.
     * @param metadatas An array of checked metadata.
     */
    static getRequestInitialTimes(metadatas) {
        return metadatas.map(metadata => metadata.pageSize ? 0 : metadata.requestTime ?? 0);
    }
    /**
     * Calculate the time to receive a single item for the given metadata entries.
     * @param metadatas An array of checked metadata.
     */
    static getRequestItemTimes(metadatas) {
        return metadatas
            .map(metadata => metadata.pageSize ? (metadata.requestTime ?? 0) / metadata.pageSize : 0);
    }
    /**
     * Helper function to create a new metadata object for the join result.
     * For required metadata entries that are not provided, sane defaults are calculated.
     * @param entries Join entries.
     * @param metadatas Metadata of the join entries.
     * @param context The action context.
     * @param partialMetadata Partial metadata entries.
     */
    async constructResultMetadata(entries, metadatas, context, partialMetadata = {}) {
        let cardinalityJoined;
        if (partialMetadata.cardinality) {
            cardinalityJoined = partialMetadata.cardinality;
        }
        else {
            cardinalityJoined = metadatas
                .reduce((acc, metadata) => {
                const cardinalityThis = ActorRdfJoin.getCardinality(metadata);
                return {
                    type: cardinalityThis.type === 'estimate' ? 'estimate' : acc.type,
                    value: acc.value * cardinalityThis.value,
                };
            }, { type: 'exact', value: 1 });
            cardinalityJoined.value *= (await this.mediatorJoinSelectivity.mediate({ entries, context })).selectivity;
        }
        // Propagate metadata invalidations
        const state = new metadata_1.MetadataValidationState();
        const invalidateListener = () => state.invalidate();
        for (const metadata of metadatas) {
            metadata.state.addInvalidateListener(invalidateListener);
        }
        return {
            state,
            ...partialMetadata,
            cardinality: {
                type: cardinalityJoined.type,
                value: cardinalityJoined.value,
            },
            canContainUndefs: partialMetadata.canContainUndefs ?? metadatas.some(metadata => metadata.canContainUndefs),
            variables: ActorRdfJoin.joinVariables(metadatas),
        };
    }
    /**
     * Order the given join entries using the join-entries-sort bus.
     * @param {MediatorRdfJoinEntriesSort} mediatorJoinEntriesSort A mediator for sorting join entries.
     * @param {IJoinEntryWithMetadata[]} entries An array of join entries.
     * @param context The action context.
     * @return {IJoinEntryWithMetadata[]} The sorted join entries.
     */
    static async sortJoinEntries(mediatorJoinEntriesSort, entries, context) {
        // If there is a stream that can contain undefs, we don't modify the join order.
        const canContainUndefs = entries.some(entry => entry.metadata.canContainUndefs);
        if (canContainUndefs) {
            return entries;
        }
        // Calculate number of occurrences of each variable
        const variableOccurrences = {};
        for (const entry of entries) {
            for (const variable of entry.metadata.variables) {
                let counter = variableOccurrences[variable.value];
                if (!counter) {
                    counter = 0;
                }
                variableOccurrences[variable.value] = ++counter;
            }
        }
        // Determine variables that occur in at least two join entries
        const multiOccurrenceVariables = [];
        for (const [variable, count] of Object.entries(variableOccurrences)) {
            if (count >= 2) {
                multiOccurrenceVariables.push(variable);
            }
        }
        // Reject if no entries have common variables
        if (multiOccurrenceVariables.length === 0) {
            throw new Error(`Bind join can only join entries with at least one common variable`);
        }
        // Determine entries without common variables
        // These will be placed in the back of the sorted array
        const entriesWithoutCommonVariables = [];
        for (const entry of entries) {
            let hasCommon = false;
            for (const variable of entry.metadata.variables) {
                if (multiOccurrenceVariables.includes(variable.value)) {
                    hasCommon = true;
                    break;
                }
            }
            if (!hasCommon) {
                entriesWithoutCommonVariables.push(entry);
            }
        }
        return (await mediatorJoinEntriesSort.mediate({ entries, context })).entries
            .sort((entryLeft, entryRight) => {
            // Sort to make sure that entries without common variables come last in the array.
            // For all other entries, the original order is kept.
            const leftWithoutCommonVariables = entriesWithoutCommonVariables.includes(entryLeft);
            const rightWithoutCommonVariables = entriesWithoutCommonVariables.includes(entryRight);
            if (leftWithoutCommonVariables === rightWithoutCommonVariables) {
                return 0;
            }
            return leftWithoutCommonVariables ?
                1 :
                -1;
        });
    }
    /**
     * Default test function for join actors.
     * Checks whether all iterators have metadata.
     * If yes: call the abstract getIterations method, if not: return Infinity.
     * @param {IActionRdfJoin} action The input action containing the relevant iterators
     * @returns {Promise<IMediatorTypeJoinCoefficients>} The join coefficients.
     */
    async test(action) {
        // Validate logical join type
        if (action.type !== this.logicalType) {
            throw new Error(`${this.name} can only handle logical joins of type '${this.logicalType}', while '${action.type}' was given.`);
        }
        // Don't allow joining of one or zero streams
        if (action.entries.length <= 1) {
            throw new Error(`${this.name} requires at least two join entries.`);
        }
        // Check if this actor can handle the given number of streams
        if (this.limitEntriesMin ? action.entries.length < this.limitEntries : action.entries.length > this.limitEntries) {
            throw new Error(`${this.name} requires ${this.limitEntries} join entries at ${this.limitEntriesMin ? 'least' : 'most'}. The input contained ${action.entries.length}.`);
        }
        // Check if all streams are bindings streams
        for (const entry of action.entries) {
            if (entry.output.type !== 'bindings') {
                // eslint-disable-next-line ts/restrict-template-expressions
                throw new Error(`Invalid type of a join entry: Expected 'bindings' but got '${entry.output.type}'`);
            }
        }
        const metadatas = await ActorRdfJoin.getMetadatas(action.entries);
        // Check if this actor can handle undefs
        if (!this.canHandleUndefs) {
            for (const metadata of metadatas) {
                if (metadata.canContainUndefs) {
                    throw new Error(`Actor ${this.name} can not join streams containing undefs`);
                }
            }
        }
        return await this.getJoinCoefficients(action, metadatas);
    }
    /**
     * Returns default input for 0 or 1 entries. Calls the getOutput function otherwise
     * @param {IActionRdfJoin} action
     * @returns {Promise<IQueryOperationResultBindings>} A bindings result.
     */
    async run(action) {
        // Prepare logging to physical plan
        // This must be called before getOutput, because we need to override the plan node in the context
        let parentPhysicalQueryPlanNode;
        if (action.context.has(context_entries_1.KeysInitQuery.physicalQueryPlanLogger)) {
            parentPhysicalQueryPlanNode = action.context.get(context_entries_1.KeysInitQuery.physicalQueryPlanNode);
            action.context = action.context.set(context_entries_1.KeysInitQuery.physicalQueryPlanNode, action);
        }
        // Log to physical plan
        const physicalQueryPlanLogger = action.context.get(context_entries_1.KeysInitQuery
            .physicalQueryPlanLogger);
        let planMetadata;
        if (this.includeInLogs && physicalQueryPlanLogger) {
            planMetadata = {};
            physicalQueryPlanLogger.logOperation(`join-${this.logicalType}`, this.physicalName, action, parentPhysicalQueryPlanNode, this.name, planMetadata);
        }
        // Get action output
        const { result, physicalPlanMetadata } = await this.getOutput(action);
        const metadatas = await ActorRdfJoin.getMetadatas(action.entries);
        // Fill in the physical plan metadata after determining action output
        if (planMetadata) {
            Object.assign(planMetadata, physicalPlanMetadata);
            planMetadata.cardinalities = metadatas.map(ActorRdfJoin.getCardinality);
            planMetadata.joinCoefficients = await this.getJoinCoefficients(action, metadatas);
        }
        // Cache metadata
        result.metadata = (0, metadata_1.cachifyMetadata)(result.metadata);
        return result;
    }
}
exports.ActorRdfJoin = ActorRdfJoin;
//# sourceMappingURL=ActorRdfJoin.js.map