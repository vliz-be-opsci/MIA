{"version":3,"file":"ActorQueryResultSerializeSparqlCsv.js","sourceRoot":"","sources":["ActorQueryResultSerializeSparqlCsv.ts"],"names":[],"mappings":";;;AAKA,qFAE8C;AAG9C,qDAA2C;AAE3C;;GAEG;AACH,MAAa,kCAAmC,SAAQ,qEAAwC;IAC9F;;;;;;;;OAQG;IACH,YAAmB,IAAmD;QACpE,KAAK,CAAC,IAAI,CAAC,CAAC;IACd,CAAC;IAED;;;;OAIG;IACI,MAAM,CAAC,oBAAoB,CAAC,KAAgB;QACjD,IAAI,CAAC,KAAK,EAAE,CAAC;YACX,OAAO,EAAE,CAAC;QACZ,CAAC;QAED,IAAI,WAAW,GAAG,KAAK,CAAC,KAAK,CAAC;QAE9B,IAAI,KAAK,CAAC,QAAQ,KAAK,SAAS,EAAE,CAAC;YACjC,uFAAuF;YACvF,WAAW,GAAG,GAAG,WAAW,EAAE,CAAC;QACjC,CAAC;aAAM,IAAI,KAAK,CAAC,QAAQ,KAAK,WAAW,EAAE,CAAC;YAC1C,WAAW,GAAG,KAAK,WAAW,EAAE,CAAC;QACnC,CAAC;aAAM,IAAI,KAAK,CAAC,QAAQ,KAAK,MAAM,EAAE,CAAC;YACrC,IAAI,MAAM,GAAG,kCAAkC,CAAC,oBAAoB,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;YACnF,IAAI,KAAK,CAAC,MAAM,CAAC,QAAQ,KAAK,SAAS,EAAE,CAAC;gBACxC,wFAAwF;gBACxF,MAAM,GAAG,IAAI,MAAM,CAAC,UAAU,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,CAAC;YAC/C,CAAC;YACD,WAAW,GAAG,MAAM,kCAAkC,CAAC,oBAAoB,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,kCAAkC,CAAC,oBAAoB,CAAC,KAAK,CAAC,SAAS,CAAC,IAAI,MAAM,KAAK,CAAC;QACxL,CAAC;aAAM,CAAC;YACN,WAAW,GAAG,IAAI,WAAW,GAAG,CAAC;QACnC,CAAC;QAED,uEAAuE;QACvE,IAAI,WAAW,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC;YAClC,yEAAyE;YACzE,WAAW,GAAG,IAAI,WAAW,CAAC,UAAU,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,CAAC;QACzD,CAAC;QAED,OAAO,WAAW,CAAC;IACrB,CAAC;IAEe,KAAK,CAAC,iBAAiB,CAAC,MAA8B,EAAE,QAAwB;QAC9F,IAAI,MAAM,CAAC,IAAI,KAAK,UAAU,EAAE,CAAC;YAC/B,MAAM,IAAI,KAAK,CAAC,8CAA8C,CAAC,CAAC;QAClE,CAAC;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IAEM,KAAK,CAAC,SAAS,CAAC,MAA8B,EAAE,UAA8B,EAAE,QAAwB;QAE7G,MAAM,cAAc,GAAmC,MAAM,CAAC;QAE9D,MAAM,IAAI,GAAG,IAAI,0BAAQ,EAAE,CAAC;QAE5B,MAAM,QAAQ,GAAG,MAAM,cAAc,CAAC,QAAQ,EAAE,CAAC;QAEjD,aAAa;QACb,IAAI,CAAC,IAAI,CAAC,GAAG,QAAQ,CAAC,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QAEjF,aAAa;QACb,IAAI,CAAC,IAAI,CAAO,cAAc,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,QAAkB,EAAE,EAAE,CAAC,GAAG,QAAQ,CAAC,SAAS;aAC1F,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,kCAAkC,CAAC,oBAAoB,CAAC,QAAQ,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;aACtF,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC;QAEvB,OAAO,EAAE,IAAI,EAAE,CAAC;IAClB,CAAC;CACF;AA5ED,gFA4EC","sourcesContent":["import type {\n  IActionSparqlSerialize,\n  IActorQueryResultSerializeFixedMediaTypesArgs,\n  IActorQueryResultSerializeOutput,\n} from '@comunica/bus-query-result-serialize';\nimport {\n  ActorQueryResultSerializeFixedMediaTypes,\n} from '@comunica/bus-query-result-serialize';\nimport type { Bindings, IActionContext, IQueryOperationResultBindings } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport { Readable } from 'readable-stream';\n\n/**\n * A comunica SPARQL CSV Query Result Serialize Actor.\n */\nexport class ActorQueryResultSerializeSparqlCsv extends ActorQueryResultSerializeFixedMediaTypes {\n  /**\n   * @param args -\n   *   \\ @defaultNested {{\n   *       \"text/csv\": 0.75\n   *     }} mediaTypePriorities\n   *   \\ @defaultNested {{\n   *       \"text/csv\": \"http://www.w3.org/ns/formats/SPARQL_Results_CSV\"\n   *     }} mediaTypeFormats\n   */\n  public constructor(args: IActorQueryResultSerializeFixedMediaTypesArgs) {\n    super(args);\n  }\n\n  /**\n   * Converts an RDF term to its CSV representation.\n   * @param {RDF.Term} value An RDF term.\n   * @return {string} A string representation of the given value.\n   */\n  public static bindingToCsvBindings(value?: RDF.Term): string {\n    if (!value) {\n      return '';\n    }\n\n    let stringValue = value.value;\n\n    if (value.termType === 'Literal') {\n      // This is a lossy representation, since language and datatype are not encoded in here.\n      stringValue = `${stringValue}`;\n    } else if (value.termType === 'BlankNode') {\n      stringValue = `_:${stringValue}`;\n    } else if (value.termType === 'Quad') {\n      let object = ActorQueryResultSerializeSparqlCsv.bindingToCsvBindings(value.object);\n      if (value.object.termType === 'Literal') {\n        // If object is a literal, it must be put in quotes, and internal quotes must be escaped\n        object = `\"${object.replaceAll('\"', '\"\"')}\"`;\n      }\n      stringValue = `<< ${ActorQueryResultSerializeSparqlCsv.bindingToCsvBindings(value.subject)} ${ActorQueryResultSerializeSparqlCsv.bindingToCsvBindings(value.predicate)} ${object} >>`;\n    } else {\n      stringValue = `<${stringValue}>`;\n    }\n\n    // If a value contains certain characters, put it between double quotes\n    if (/[\",\\n\\r]/u.test(stringValue)) {\n      // Within quote strings, \" is written using a pair of quotation marks \"\".\n      stringValue = `\"${stringValue.replaceAll('\"', '\"\"')}\"`;\n    }\n\n    return stringValue;\n  }\n\n  public override async testHandleChecked(action: IActionSparqlSerialize, _context: IActionContext): Promise<boolean> {\n    if (action.type !== 'bindings') {\n      throw new Error('This actor can only handle bindings streams.');\n    }\n    return true;\n  }\n\n  public async runHandle(action: IActionSparqlSerialize, _mediaType: string | undefined, _context: IActionContext):\n  Promise<IActorQueryResultSerializeOutput> {\n    const bindingsAction = <IQueryOperationResultBindings> action;\n\n    const data = new Readable();\n\n    const metadata = await bindingsAction.metadata();\n\n    // Write head\n    data.push(`${metadata.variables.map(variable => variable.value).join(',')}\\r\\n`);\n\n    // Write body\n    data.wrap(<any> bindingsAction.bindingsStream.map((bindings: Bindings) => `${metadata.variables\n        .map(key => ActorQueryResultSerializeSparqlCsv.bindingToCsvBindings(bindings.get(key)))\n        .join(',')}\\r\\n`));\n\n    return { data };\n  }\n}\n"]}