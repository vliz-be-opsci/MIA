{"version":3,"file":"Utils.js","sourceRoot":"","sources":["Utils.ts"],"names":[],"mappings":"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","sourcesContent":["import type { BindingsFactory } from '@comunica/bindings-factory';\nimport { ClosableTransformIterator } from '@comunica/bus-query-operation';\nimport { validateMetadataQuads } from '@comunica/metadata';\nimport type { BindingsStream, MetadataBindings, MetadataQuads, TermsOrder } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport type { AsyncIterator } from 'asynciterator';\nimport { DataFactory } from 'rdf-data-factory';\nimport { termToString } from 'rdf-string';\nimport type { QuadTermName } from 'rdf-terms';\nimport {\n  forEachTermsNested,\n  getTermsNested,\n  getValueNestedPath,\n  reduceTermsNested,\n  someTerms,\n  uniqTerms,\n} from 'rdf-terms';\nimport { matchPatternMappings } from 'rdf-terms/lib/QuadTermUtil';\nimport type { Algebra } from 'sparqlalgebrajs';\n\nconst DF = new DataFactory();\n\n/**\n * Convert an iterator of quads to an iterator of bindings.\n * @param quads The quads to convert.\n * @param pattern The pattern to get variables from to determine bindings.\n *                All quads are also assumed to match the pattern.\n * @param bindingsFactory The factory for creating bindings.\n * @param unionDefaultGraph If union default graph mode is enabled.\n *                          If true, variable graphs will match all graphs, including the default graph.\n *                          If false, variable graphs will only match named graphs, and not the default graph.\n */\nexport function quadsToBindings(\n  quads: AsyncIterator<RDF.Quad>,\n  pattern: Algebra.Pattern,\n  bindingsFactory: BindingsFactory,\n  unionDefaultGraph: boolean,\n): BindingsStream {\n  const variables = getVariables(pattern);\n\n  // If non-default-graph triples need to be filtered out\n  const filterNonDefaultQuads = pattern.graph.termType === 'Variable' && !unionDefaultGraph;\n\n  // Detect duplicate variables in the pattern\n  const duplicateElementLinks: Record<string, QuadTermName[][]> | undefined = getDuplicateElementLinks(pattern);\n\n  // Convenience datastructure for mapping quad elements to variables\n  const elementVariables: Record<string, string> = reduceTermsNested(\n    pattern,\n    (acc: Record<string, string>, term: RDF.Term, keys: QuadTermName[]) => {\n      if (term.termType === 'Variable') {\n        acc[keys.join('_')] = term.value;\n      }\n      return acc;\n    },\n    {},\n  );\n\n  // Optionally filter, and construct bindings\n  const it = new ClosableTransformIterator(async() => {\n    let filteredOutput = quads;\n\n    // SPARQL query semantics allow graph variables to only match with named graphs, excluding the default graph\n    // But this is not the case when using union default graph semantics\n    if (filterNonDefaultQuads) {\n      filteredOutput = filteredOutput.filter(quad => quad.graph.termType !== 'DefaultGraph');\n    }\n\n    // If there are duplicate variables in the search pattern,\n    // make sure that we filter out the triples that don't have equal values for those triple elements,\n    // as the rdf-resolve-quad-pattern bus ignores variable names.\n    if (duplicateElementLinks) {\n      filteredOutput = filteredOutput.filter((quad) => {\n        for (const keyLeft in duplicateElementLinks) {\n          const keysLeft: QuadTermName[] = <QuadTermName[]> keyLeft.split('_');\n          const valueLeft = getValueNestedPath(quad, keysLeft);\n          for (const keysRight of duplicateElementLinks[keyLeft]) {\n            if (!valueLeft.equals(getValueNestedPath(quad, keysRight))) {\n              return false;\n            }\n          }\n        }\n        return true;\n      });\n    }\n\n    return filteredOutput.map<RDF.Bindings>(quad => bindingsFactory\n      .bindings(Object.keys(elementVariables).map((key) => {\n        const keys: QuadTermName[] = <any>key.split('_');\n        const variable = elementVariables[key];\n        const term = getValueNestedPath(quad, keys);\n        return [ DF.variable(variable), term ];\n      })));\n  }, {\n    autoStart: false,\n    onClose: () => quads.destroy(),\n  });\n\n  // Set the metadata property\n  setMetadata(it, quads, elementVariables, variables, filterNonDefaultQuads || Boolean(duplicateElementLinks));\n\n  return it;\n}\n\n/**\n * Check if a term is a variable.\n * @param {RDF.Term} term An RDF term.\n * @return {any} If the term is a variable or blank node.\n */\nexport function isTermVariable(term: RDF.Term): term is RDF.Variable {\n  return term.termType === 'Variable';\n}\n\n/**\n * Get all variables in the given pattern.\n * No duplicates are returned.\n * @param {RDF.BaseQuad} pattern A quad pattern.\n */\nexport function getVariables(pattern: RDF.BaseQuad): RDF.Variable[] {\n  return uniqTerms(getTermsNested(pattern).filter(isTermVariable));\n}\n\n/**\n * A helper function to find a hash with quad elements that have duplicate variables.\n *\n * @param {RDF.Quad} pattern A quad pattern.\n *\n * @return {{[p: string]: string[]}} If no equal variable names are present in the four terms, this returns undefined.\n *                                   Otherwise, this maps quad elements paths (['subject'], ['predicate'], ['object'],\n *                                   ['graph'])\n *                                   to the list of quad elements it shares a variable name with.\n *                                   For quoted triples, paths such as ['subject', 'object'] may occur.\n *                                   If no links for a certain element exist, this element will\n *                                   not be included in the hash.\n *                                   Note 1: Quad elements will never have a link to themselves.\n *                                           So this can never occur: { subject: [[ 'subject']] },\n *                                           instead 'null' would be returned.\n *                                   Note 2: Links only exist in one direction,\n *                                           this means that { subject: [[ 'predicate']], predicate: [[ 'subject' ]] }\n *                                           will not occur, instead only { subject: [[ 'predicate']] }\n *                                           will be returned.\n *                                   Note 3: Keys can also be paths, but they are delimited by '_', such as:\n *                                           { subject_object_subject: [[ 'predicate']] }\n */\nexport function getDuplicateElementLinks(pattern: RDF.BaseQuad): Record<string, QuadTermName[][]> | undefined {\n  // Collect a variable to quad elements mapping.\n  const variableElements: Record<string, QuadTermName[][]> = {};\n  let duplicateVariables = false;\n  forEachTermsNested(pattern, (value, keys) => {\n    if (value.termType === 'Variable') {\n      const val = termToString(value);\n      const length = (variableElements[val] || (variableElements[val] = [])).push(keys);\n      duplicateVariables = duplicateVariables || length > 1;\n    }\n  });\n\n  if (!duplicateVariables) {\n    return;\n  }\n\n  // Collect quad element to elements with equal variables mapping.\n  const duplicateElementLinks: Record<string, QuadTermName[][]> = {};\n  for (const variable in variableElements) {\n    const elements = variableElements[variable];\n    const remainingElements = elements.slice(1);\n    // Only store the elements that have at least one equal element.\n    if (remainingElements.length > 0) {\n      duplicateElementLinks[elements[0].join('_')] = remainingElements;\n    }\n  }\n\n  return duplicateElementLinks;\n}\n\n/**\n * Set the metadata of the bindings stream derived from the metadata of the quads stream.\n *\n * @param {BindingsStream} bindings The bindings stream that will receive the metadata property.\n * @param {AsyncIterator<Quad>} quads The quads stream that is guaranteed to emit the metadata property.\n * @param elementVariables Mapping of quad term name to variable name.\n * @param variables Variables to include in the metadata\n * @param forceEstimateCardinality Set the cardinality to estimate\n * @return {() => Promise<{[p: string]: any}>} A lazy promise behind a callback resolving to a metadata object.\n */\nexport function setMetadata(\n  bindings: BindingsStream,\n  quads: AsyncIterator<RDF.Quad>,\n  elementVariables: Record<string, string>,\n  variables: RDF.Variable[],\n  forceEstimateCardinality: boolean,\n): void {\n  const getMetadataCb = (metadataRaw: Record<string, any>): void => {\n    if (!('canContainUndefs' in metadataRaw)) {\n      metadataRaw.canContainUndefs = false;\n    }\n    if (forceEstimateCardinality) {\n      metadataRaw.cardinality.type = 'estimate';\n    }\n    bindings.setProperty(\n      'metadata',\n      quadsMetadataToBindingsMetadata(validateMetadataQuads(metadataRaw), elementVariables, variables),\n    );\n\n    // Propagate metadata invalidations\n    if (metadataRaw.state) {\n      metadataRaw.state.addInvalidateListener(() => {\n        setMetadata(bindings, quads, elementVariables, variables, forceEstimateCardinality);\n      });\n    }\n  };\n\n  const metadata = quads.getProperty('metadata');\n  if (metadata) {\n    // This is to enforce sync metadata setting, because AsyncIterator will always call it async,\n    // even if the property was already defined.\n    getMetadataCb(metadata);\n  } else {\n    quads.getProperty('metadata', getMetadataCb);\n  }\n}\n\n/**\n * Convert the metadata of quads to the metadata of bindings.\n * @param metadataQuads Quads metadata.\n * @param elementVariables A mapping from quad elements to variables.\n * @param variables The variables in the bindings.\n */\nexport function quadsMetadataToBindingsMetadata(\n  metadataQuads: MetadataQuads,\n  elementVariables: Record<string, string>,\n  variables: RDF.Variable[],\n): MetadataBindings {\n  return {\n    ...metadataQuads,\n    canContainUndefs: false,\n    order: metadataQuads.order ?\n      quadsOrderToBindingsOrder(metadataQuads.order, elementVariables) :\n      undefined,\n    availableOrders: metadataQuads.availableOrders ?\n      metadataQuads.availableOrders.map(orderDef => ({\n        cost: orderDef.cost,\n        terms: quadsOrderToBindingsOrder(orderDef.terms, elementVariables),\n      })) :\n      undefined,\n    variables,\n  };\n}\n\n/**\n * Convert the quads order metadata element to a bindings order metadata element.\n * @param quadsOrder Quads order.\n * @param elementVariables A mapping from quad elements to variables.\n */\nexport function quadsOrderToBindingsOrder(\n  quadsOrder: TermsOrder<RDF.QuadTermName>,\n  elementVariables: Record<string, string>,\n): TermsOrder<RDF.Variable> {\n  const mappedVariables: Record<string, boolean> = {};\n  return <TermsOrder<RDF.Variable>> quadsOrder.map((entry) => {\n    // Omit entries that do not map to a variable\n    const variableName = elementVariables[entry.term];\n    if (!variableName) {\n      // eslint-disable-next-line array-callback-return\n      return;\n    }\n\n    // Omit entries that have been mapped already\n    if (mappedVariables[variableName]) {\n      // eslint-disable-next-line array-callback-return\n      return;\n    }\n\n    mappedVariables[variableName] = true;\n    return {\n      term: DF.variable(variableName),\n      direction: entry.direction,\n    };\n  }).filter(Boolean);\n}\n\n/**\n * Perform post-match-filtering if the source does not support quoted triple filtering,\n * but we have a variable inside a quoted triple.\n * @param pattern The current quad pattern operation.\n * @param it The iterator to filter.\n */\nexport function filterMatchingQuotedQuads(pattern: RDF.BaseQuad, it: AsyncIterator<RDF.Quad>): AsyncIterator<RDF.Quad> {\n  if (someTerms(pattern, term => term.termType === 'Quad')) {\n    it = it.filter(quad => matchPatternMappings(quad, pattern));\n  }\n  return it;\n}\n"]}