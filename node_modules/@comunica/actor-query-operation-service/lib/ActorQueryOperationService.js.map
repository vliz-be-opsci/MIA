{"version":3,"file":"ActorQueryOperationService.js","sourceRoot":"","sources":["ActorQueryOperationService.ts"],"names":[],"mappings":";;;AAAA,iEAA6D;AAG7D,uEAAsG;AAGtG,iDAA6D;AAG7D,iDAAkD;AAGlD;;;GAGG;AACH,MAAa,0BAA2B,SAAQ,sDAAiD;IAK/F,YAAmB,IAAqC;QACtD,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;IACzB,CAAC;IAEM,KAAK,CAAC,aAAa,CAAC,SAA0B,EAAE,QAAwB;QAC7E,IAAI,SAAS,CAAC,IAAI,CAAC,QAAQ,KAAK,WAAW,EAAE,CAAC;YAC5C,MAAM,IAAI,KAAK,CAAC,GAAG,IAAI,CAAC,IAAI,4CAA4C,SAAS,CAAC,IAAI,CAAC,QAAQ,aAAa,CAAC,CAAC;QAChH,CAAC;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IAEM,KAAK,CAAC,YAAY,CAAC,SAA0B,EAAE,OAAuB;QAE3E,8CAA8C;QAC9C,MAAM,EAAE,WAAW,EAAE,GAAG,MAAM,IAAI,CAAC,2BAA2B,CAAC,OAAO,CAAC;YACrE,uBAAuB,EAAE;gBACvB,KAAK,EAAE,SAAS,CAAC,IAAI,CAAC,KAAK;gBAC3B,IAAI,EAAE,IAAI,CAAC,mBAAmB,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,SAAS;aACtD;YACD,OAAO;SACR,CAAC,CAAC;QAEH,kDAAkD;QAClD,IAAI,MAAqC,CAAC;QAC1C,IAAI,CAAC;YACH,MAAM,GAAG,yCAAmB,CAAC,eAAe,CAAC,MAAM,IAAI,CAAC,sBAAsB,CAAC,OAAO,CAAC;gBACrF,SAAS,EAAE,yCAAmB,CAAC,qBAAqB,CAAC,SAAS,CAAC,KAAK,EAAE,WAAW,CAAC;gBAClF,OAAO;aACR,CAAC,CAAC,CAAC;QACN,CAAC;QAAC,OAAO,KAAc,EAAE,CAAC;YACxB,IAAI,SAAS,CAAC,MAAM,EAAE,CAAC;gBACrB,8BAA8B;gBAC9B,MAAM,eAAe,GAAG,MAAM,kCAAe,CAAC,MAAM,CAAC,IAAI,CAAC,4BAA4B,EAAE,OAAO,CAAC,CAAC;gBACjG,MAAM,GAAG;oBACP,cAAc,EAAE,IAAI,iCAAiB,CAAe,eAAe,CAAC,QAAQ,EAAE,CAAC;oBAC/E,IAAI,EAAE,UAAU;oBAChB,QAAQ,EAAE,KAAK,IAAG,EAAE,CAAC,CAAC;wBACpB,KAAK,EAAE,IAAI,kCAAuB,EAAE;wBACpC,WAAW,EAAE,EAAE,IAAI,EAAE,OAAO,EAAE,KAAK,EAAE,CAAC,EAAE;wBACxC,gBAAgB,EAAE,KAAK;wBACvB,SAAS,EAAE,EAAE;qBACd,CAAC;iBACH,CAAC;gBACF,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,sDAA+D,KAAM,CAAC,OAAO,EAAE,CAAC,CAAC;YACzG,CAAC;iBAAM,CAAC;gBACN,MAAM,KAAK,CAAC;YACd,CAAC;QACH,CAAC;QAED,OAAO,MAAM,CAAC;IAChB,CAAC;CACF;AAxDD,gEAwDC","sourcesContent":["import { BindingsFactory } from '@comunica/bindings-factory';\nimport type { MediatorMergeBindingsContext } from '@comunica/bus-merge-bindings-context';\nimport type { IActorQueryOperationTypedMediatedArgs } from '@comunica/bus-query-operation';\nimport { ActorQueryOperation, ActorQueryOperationTypedMediated } from '@comunica/bus-query-operation';\nimport type { MediatorQuerySourceIdentify } from '@comunica/bus-query-source-identify';\nimport type { IActorTest } from '@comunica/core';\nimport { MetadataValidationState } from '@comunica/metadata';\nimport type { IActionContext, IQueryOperationResult, IQueryOperationResultBindings } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport { SingletonIterator } from 'asynciterator';\nimport type { Algebra } from 'sparqlalgebrajs';\n\n/**\n * A comunica Service Query Operation Actor.\n * It unwraps the SERVICE operation and executes it on the given source.\n */\nexport class ActorQueryOperationService extends ActorQueryOperationTypedMediated<Algebra.Service> {\n  public readonly forceSparqlEndpoint: boolean;\n  public readonly mediatorMergeBindingsContext: MediatorMergeBindingsContext;\n  public readonly mediatorQuerySourceIdentify: MediatorQuerySourceIdentify;\n\n  public constructor(args: IActorQueryOperationServiceArgs) {\n    super(args, 'service');\n  }\n\n  public async testOperation(operation: Algebra.Service, _context: IActionContext): Promise<IActorTest> {\n    if (operation.name.termType !== 'NamedNode') {\n      throw new Error(`${this.name} can only query services by IRI, while a ${operation.name.termType} was given.`);\n    }\n    return true;\n  }\n\n  public async runOperation(operation: Algebra.Service, context: IActionContext):\n  Promise<IQueryOperationResult> {\n    // Identify the SERVICE target as query source\n    const { querySource } = await this.mediatorQuerySourceIdentify.mediate({\n      querySourceUnidentified: {\n        value: operation.name.value,\n        type: this.forceSparqlEndpoint ? 'sparql' : undefined,\n      },\n      context,\n    });\n\n    // Attach the source to the operation, and execute\n    let output: IQueryOperationResultBindings;\n    try {\n      output = ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({\n        operation: ActorQueryOperation.assignOperationSource(operation.input, querySource),\n        context,\n      }));\n    } catch (error: unknown) {\n      if (operation.silent) {\n        // Emit a single empty binding\n        const bindingsFactory = await BindingsFactory.create(this.mediatorMergeBindingsContext, context);\n        output = {\n          bindingsStream: new SingletonIterator<RDF.Bindings>(bindingsFactory.bindings()),\n          type: 'bindings',\n          metadata: async() => ({\n            state: new MetadataValidationState(),\n            cardinality: { type: 'exact', value: 1 },\n            canContainUndefs: false,\n            variables: [],\n          }),\n        };\n        this.logWarn(context, `An error occurred when executing a SERVICE clause: ${(<Error> error).message}`);\n      } else {\n        throw error;\n      }\n    }\n\n    return output;\n  }\n}\n\nexport interface IActorQueryOperationServiceArgs extends IActorQueryOperationTypedMediatedArgs {\n  /**\n   * If the SERVICE target should be assumed to be a SPARQL endpoint.\n   * @default {false}\n   */\n  forceSparqlEndpoint: boolean;\n  /**\n   * A mediator for creating binding context merge handlers\n   */\n  mediatorMergeBindingsContext: MediatorMergeBindingsContext;\n  /**\n   * The mediator for identifying query sources.\n   */\n  mediatorQuerySourceIdentify: MediatorQuerySourceIdentify;\n}\n"]}