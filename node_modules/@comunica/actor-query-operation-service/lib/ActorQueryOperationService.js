"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorQueryOperationService = void 0;
const bindings_factory_1 = require("@comunica/bindings-factory");
const bus_query_operation_1 = require("@comunica/bus-query-operation");
const metadata_1 = require("@comunica/metadata");
const asynciterator_1 = require("asynciterator");
/**
 * A comunica Service Query Operation Actor.
 * It unwraps the SERVICE operation and executes it on the given source.
 */
class ActorQueryOperationService extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'service');
    }
    async testOperation(operation, _context) {
        if (operation.name.termType !== 'NamedNode') {
            throw new Error(`${this.name} can only query services by IRI, while a ${operation.name.termType} was given.`);
        }
        return true;
    }
    async runOperation(operation, context) {
        // Identify the SERVICE target as query source
        const { querySource } = await this.mediatorQuerySourceIdentify.mediate({
            querySourceUnidentified: {
                value: operation.name.value,
                type: this.forceSparqlEndpoint ? 'sparql' : undefined,
            },
            context,
        });
        // Attach the source to the operation, and execute
        let output;
        try {
            output = bus_query_operation_1.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({
                operation: bus_query_operation_1.ActorQueryOperation.assignOperationSource(operation.input, querySource),
                context,
            }));
        }
        catch (error) {
            if (operation.silent) {
                // Emit a single empty binding
                const bindingsFactory = await bindings_factory_1.BindingsFactory.create(this.mediatorMergeBindingsContext, context);
                output = {
                    bindingsStream: new asynciterator_1.SingletonIterator(bindingsFactory.bindings()),
                    type: 'bindings',
                    metadata: async () => ({
                        state: new metadata_1.MetadataValidationState(),
                        cardinality: { type: 'exact', value: 1 },
                        canContainUndefs: false,
                        variables: [],
                    }),
                };
                this.logWarn(context, `An error occurred when executing a SERVICE clause: ${error.message}`);
            }
            else {
                throw error;
            }
        }
        return output;
    }
}
exports.ActorQueryOperationService = ActorQueryOperationService;
//# sourceMappingURL=ActorQueryOperationService.js.map