{"version":3,"file":"ActorQueryOperationConstruct.js","sourceRoot":"","sources":["ActorQueryOperationConstruct.ts"],"names":[],"mappings":";;;AACA,uEAGuC;AAUvC,yCAAoE;AACpE,qDAA0C;AAC1C,uEAAoE;AAEpE;;GAEG;AACH,MAAa,4BAA6B,SAAQ,sDAAmD;IACnG,YAAmB,IAA2C;QAC5D,KAAK,CAAC,IAAI,EAAE,WAAW,CAAC,CAAC;IAC3B,CAAC;IAED;;;;OAIG;IACI,MAAM,CAAC,YAAY,CAAC,QAAwB;QACjD,OAAO,IAAA,qBAAS,EAAmB,EAAG,CAAC,MAAM;aAC1C,KAAK,CAAC,EAAE,EAAE,QAAQ,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE,CAAC,IAAA,wBAAY,EAAC,IAAA,0BAAc,EAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAChF,CAAC;IAEM,KAAK,CAAC,aAAa,CAAC,UAA6B,EAAE,QAAwB;QAChF,OAAO,IAAI,CAAC;IACd,CAAC;IAEM,KAAK,CAAC,YAAY,CAAC,iBAAoC,EAAE,OAAuB;QAErF,yGAAyG;QACzG,MAAM,SAAS,GAAmB,4BAA4B,CAAC,YAAY,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAC;QACxG,MAAM,SAAS,GAAsB,EAAE,IAAI,EAAE,yBAAO,CAAC,KAAK,CAAC,OAAO,EAAE,KAAK,EAAE,iBAAiB,CAAC,KAAK,EAAE,SAAS,EAAE,CAAC;QAEhH,2BAA2B;QAC3B,MAAM,MAAM,GAAkC,yCAAmB,CAAC,eAAe,CAC/E,MAAM,IAAI,CAAC,sBAAsB,CAAC,OAAO,CAAC,EAAE,SAAS,EAAE,OAAO,EAAE,CAAC,CAClE,CAAC;QAEF,2DAA2D;QAC3D,oEAAoE;QACpE,MAAM,UAAU,GAA4B,IAAI,iDAAuB,CACrE,iBAAiB,CAAC,QAAQ,EAC1B,MAAM,CAAC,cAAc,CACtB,CAAC;QAEF,iEAAiE;QACjE,MAAM,QAAQ,GAAmC,GAAG,EAAE,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;YACrF,GAAG,IAAI;YACP,KAAK,EAAE,SAAS;YAChB,WAAW,EAAE;gBACX,IAAI,EAAE,IAAI,CAAC,WAAW,CAAC,IAAI;gBAC3B,KAAK,EAAE,IAAI,CAAC,WAAW,CAAC,KAAK,GAAG,iBAAiB,CAAC,QAAQ,CAAC,MAAM;aAClE;YACD,gBAAgB,EAAE,KAAK;YACvB,eAAe,EAAE,SAAS;SAC3B,CAAC,CAAC,CAAC;QAEJ,OAAO;YACL,QAAQ;YACR,UAAU;YACV,IAAI,EAAE,OAAO;SACd,CAAC;IACJ,CAAC;CACF;AAvDD,oEAuDC","sourcesContent":["import type { IActorQueryOperationTypedMediatedArgs } from '@comunica/bus-query-operation';\nimport {\n  ActorQueryOperation,\n  ActorQueryOperationTypedMediated,\n} from '@comunica/bus-query-operation';\nimport type { IActorTest } from '@comunica/core';\nimport type {\n  IQueryOperationResultBindings,\n  IActionContext,\n  IQueryOperationResult,\n  MetadataQuads,\n} from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport type { AsyncIterator } from 'asynciterator';\nimport { getTermsNested, getVariables, uniqTerms } from 'rdf-terms';\nimport { Algebra } from 'sparqlalgebrajs';\nimport { BindingsToQuadsIterator } from './BindingsToQuadsIterator';\n\n/**\n * A comunica Construct Query Operation Actor.\n */\nexport class ActorQueryOperationConstruct extends ActorQueryOperationTypedMediated<Algebra.Construct> {\n  public constructor(args: IActorQueryOperationTypedMediatedArgs) {\n    super(args, 'construct');\n  }\n\n  /**\n   * Find all variables in a list of triple patterns.\n   * @param {Algebra.Pattern[]} patterns An array of triple patterns.\n   * @return {RDF.Variable[]} The variables in the triple patterns.\n   */\n  public static getVariables(patterns: RDF.BaseQuad[]): RDF.Variable[] {\n    return uniqTerms((<RDF.Variable[]> []).concat\n      .apply([], patterns.map(pattern => getVariables(getTermsNested(pattern)))));\n  }\n\n  public async testOperation(_operation: Algebra.Construct, _context: IActionContext): Promise<IActorTest> {\n    return true;\n  }\n\n  public async runOperation(operationOriginal: Algebra.Construct, context: IActionContext):\n  Promise<IQueryOperationResult> {\n    // Apply a projection on our CONSTRUCT variables first, as the query may contain other variables as well.\n    const variables: RDF.Variable[] = ActorQueryOperationConstruct.getVariables(operationOriginal.template);\n    const operation: Algebra.Operation = { type: Algebra.types.PROJECT, input: operationOriginal.input, variables };\n\n    // Evaluate the input query\n    const output: IQueryOperationResultBindings = ActorQueryOperation.getSafeBindings(\n      await this.mediatorQueryOperation.mediate({ operation, context }),\n    );\n\n    // Construct triples using the result based on the pattern.\n    // If it's a DESCRIBE query don't apply the blank node localisation.\n    const quadStream: AsyncIterator<RDF.Quad> = new BindingsToQuadsIterator(\n      operationOriginal.template,\n      output.bindingsStream,\n    );\n\n    // Let the final metadata contain the estimated number of triples\n    const metadata: (() => Promise<MetadataQuads>) = () => output.metadata().then(meta => ({\n      ...meta,\n      order: undefined,\n      cardinality: {\n        type: meta.cardinality.type,\n        value: meta.cardinality.value * operationOriginal.template.length,\n      },\n      canContainUndefs: false,\n      availableOrders: undefined,\n    }));\n\n    return {\n      metadata,\n      quadStream,\n      type: 'quads',\n    };\n  }\n}\n"]}