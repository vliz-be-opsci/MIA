{"version":3,"file":"BindingsToQuadsIterator.js","sourceRoot":"","sources":["BindingsToQuadsIterator.ts"],"names":[],"mappings":";;;AAGA,iDAAsE;AACtE,uDAA+C;AAC/C,yCAA2C;AAE3C,MAAM,EAAE,GAAG,IAAI,8BAAW,EAAE,CAAC;AAE7B;;;;;GAKG;AACH,MAAa,uBAAwB,SAAQ,sCAA0C;IAIrF,YAAmB,QAAwB,EAAE,cAA8B;QACzE,KAAK,CAAC,cAAc,EAAE,EAAE,SAAS,EAAE,KAAK,EAAE,CAAC,CAAC;QAC5C,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,gBAAgB,GAAG,CAAC,CAAC;IAC5B,CAAC;IAED;;;;;;;;;;;;OAYG;IACI,MAAM,CAAC,QAAQ,CAAC,QAAkB,EAAE,IAAc;QACvD,IAAI,IAAI,CAAC,QAAQ,KAAK,UAAU,EAAE,CAAC;YACjC,OAAO,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QAC5B,CAAC;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;;;;;;OAOG;IACI,MAAM,CAAC,QAAQ,CAAC,QAAkB,EAAE,OAAqB;QAC9D,IAAI,CAAC;YACH,OAAO,IAAA,0BAAc,EAAY,OAAO,EAAE,CAAC,IAAI,EAAE,EAAE;gBACjD,MAAM,SAAS,GAAG,uBAAuB,CAAC,QAAQ,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;gBACnE,IAAI,CAAC,SAAS,EAAE,CAAC;oBACf,MAAM,IAAI,KAAK,CAAC,cAAc,CAAC,CAAC;gBAClC,CAAC;gBACD,OAAO,SAAS,CAAC;YACnB,CAAC,CAAC,CAAC;QACL,CAAC;QAAC,MAAM,CAAC;YACP,aAAa;QACf,CAAC;IACH,CAAC;IAED;;;;;;OAMG;IACI,MAAM,CAAC,iBAAiB,CAAC,gBAAwB,EAAE,IAAc;QACtE,IAAI,IAAI,CAAC,QAAQ,KAAK,WAAW,EAAE,CAAC;YAClC,OAAO,EAAE,CAAC,SAAS,CAAC,GAAG,IAAI,CAAC,KAAK,GAAG,gBAAgB,EAAE,CAAC,CAAC;QAC1D,CAAC;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;;;;OAKG;IACI,MAAM,CAAC,YAAY,CAAC,gBAAwB,EAAE,OAAqB;QACxE,OAAO,IAAA,0BAAc,EAAC,OAAO,EAAE,IAAI,CAAC,EAAE,CAAC,uBAAuB,CAAC,iBAAiB,CAAC,gBAAgB,EAAE,IAAI,CAAC,CAAC,CAAC;IAC5G,CAAC;IAED;;;;;;OAMG;IACI,YAAY,CAAC,QAAkB,EAAE,QAAwB,EAAE,gBAAwB;QACxF,MAAM,KAAK,GAAoC,QAAQ;YACrD,kHAAkH;aACjH,GAAG,CAAC,uBAAuB,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,EAAE,gBAAgB,CAAC,CAAC;YACvE,gCAAgC;aAC/B,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,uBAAuB,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;YACnE,8DAA8D;aAC7D,MAAM,CAAC,OAAO,CAAC,CAAC;QACnB,OAAoB,KAAK,CAAC;IAC5B,CAAC;IAEe,kBAAkB,CAAC,QAAkB;QACnD,OAAO,IAAI,6BAAa,CAAC,IAAI,CAAC,YAAY,CACxC,QAAQ,EACR,IAAI,CAAC,QAAQ,EACb,IAAI,CAAC,gBAAgB,EAAE,CACxB,EAAE,EAAE,SAAS,EAAE,KAAK,EAAE,CAAC,CAAC;IAC3B,CAAC;CACF;AArGD,0DAqGC","sourcesContent":["import type { Bindings, BindingsStream } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport type { AsyncIterator } from 'asynciterator';\nimport { ArrayIterator, MultiTransformIterator } from 'asynciterator';\nimport { DataFactory } from 'rdf-data-factory';\nimport { mapTermsNested } from 'rdf-terms';\n\nconst DF = new DataFactory();\n\n/**\n * Transforms a bindings stream into a quad stream given a quad template.\n *\n * This conforms to the SPARQL 1.1 spec on constructing triples:\n * https://www.w3.org/TR/sparql11-query/#rConstructTriples\n */\nexport class BindingsToQuadsIterator extends MultiTransformIterator<Bindings, RDF.Quad> {\n  protected readonly template: RDF.BaseQuad[];\n  protected blankNodeCounter: number;\n\n  public constructor(template: RDF.BaseQuad[], bindingsStream: BindingsStream) {\n    super(bindingsStream, { autoStart: false });\n    this.template = template;\n    this.blankNodeCounter = 0;\n  }\n\n  /**\n   * Bind the given term.\n   * If the term is a variable and the variable is bound in the bindings object,\n   * return the bindings value.\n   * If the term is a variable and the variable is not bound in the bindings object,\n   * a falsy value is returned..\n   * Otherwise, the term itself is returned.\n   * @param {Bindings}  bindings A bindings object.\n   * @param {RDF.Term}  term     An RDF term.\n   * @return {RDF.Term}          If the given term is not a variable, the term itself is returned.\n   *                             If the given term is a variable, then the bound term is returned,\n   *                             or a falsy value if it did not exist in the bindings.\n   */\n  public static bindTerm(bindings: Bindings, term: RDF.Term): RDF.Term | undefined {\n    if (term.termType === 'Variable') {\n      return bindings.get(term);\n    }\n    return term;\n  }\n\n  /**\n   * Bind the given quad pattern.\n   * If one of the terms was a variable AND is not bound in the bindings,\n   * a falsy value will be returned.\n   * @param {Bindings} bindings A bindings object.\n   * @param {RDF.Quad} pattern  An RDF quad.\n   * @return {RDF.Quad}         A bound RDF quad or undefined.\n   */\n  public static bindQuad(bindings: Bindings, pattern: RDF.BaseQuad): RDF.Quad | undefined {\n    try {\n      return mapTermsNested(<RDF.Quad> pattern, (term) => {\n        const boundTerm = BindingsToQuadsIterator.bindTerm(bindings, term);\n        if (!boundTerm) {\n          throw new Error('Unbound term');\n        }\n        return boundTerm;\n      });\n    } catch {\n      // Do nothing\n    }\n  }\n\n  /**\n   * Convert a blank node to a unique blank node in the given context.\n   * If the given term is not a blank node, the term itself will be returned.\n   * @param             blankNodeCounter A counter value for the blank node.\n   * @param {RDF.Term}  term             The term that should be localized.\n   * @return {RDF.Term}                  A term.\n   */\n  public static localizeBlankNode(blankNodeCounter: number, term: RDF.Term): RDF.Term {\n    if (term.termType === 'BlankNode') {\n      return DF.blankNode(`${term.value}${blankNodeCounter}`);\n    }\n    return term;\n  }\n\n  /**\n   * Convert the given quad to a quad that only contains unique blank nodes.\n   * @param            blankNodeCounter A counter value for the blank node.\n   * @param {RDF.BaseQuad} pattern          The pattern that should be localized.\n   * @return {RDF.BaseQuad}                 A quad.\n   */\n  public static localizeQuad(blankNodeCounter: number, pattern: RDF.BaseQuad): RDF.BaseQuad {\n    return mapTermsNested(pattern, term => BindingsToQuadsIterator.localizeBlankNode(blankNodeCounter, term));\n  }\n\n  /**\n   * Convert the given template to a list of quads based on the given bindings.\n   * @param {Bindings}    bindings           A bindings object.\n   * @param {RDF.Quad[]}  template           A list of quad patterns.\n   * @param               blankNodeCounter   A counter value for the blank node.\n   * @return {RDF.Quad[]}                    A list of quads.\n   */\n  public bindTemplate(bindings: Bindings, template: RDF.BaseQuad[], blankNodeCounter: number): RDF.Quad[] {\n    const quads: RDF.BaseQuad[] = <RDF.BaseQuad[]> template\n      // Make sure the multiple instantiations of the template contain different blank nodes, as required by SPARQL 1.1.\n      .map(BindingsToQuadsIterator.localizeQuad.bind(null, blankNodeCounter))\n      // Bind variables to bound terms\n      .map(x => BindingsToQuadsIterator.bindQuad.bind(null, bindings)(x))\n      // Remove quads that contained unbound terms, i.e., variables.\n      .filter(Boolean);\n    return <RDF.Quad[]> quads;\n  }\n\n  public override _createTransformer(bindings: Bindings): AsyncIterator<RDF.Quad> {\n    return new ArrayIterator(this.bindTemplate(\n      bindings,\n      this.template,\n      this.blankNodeCounter++,\n    ), { autoStart: false });\n  }\n}\n"]}