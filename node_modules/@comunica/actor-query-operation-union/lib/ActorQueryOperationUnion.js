"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorQueryOperationUnion = void 0;
const bus_query_operation_1 = require("@comunica/bus-query-operation");
const metadata_1 = require("@comunica/metadata");
const asynciterator_1 = require("asynciterator");
const rdf_terms_1 = require("rdf-terms");
/**
 * A comunica Union Query Operation Actor.
 */
class ActorQueryOperationUnion extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'union');
    }
    /**
     * Takes the union of the given double array variables.
     * Uniqueness is guaranteed.
     * @param {string[][]} variables Double array of variables to take the union of.
     * @return {string[]} The union of the given variables.
     */
    static unionVariables(variables) {
        return (0, rdf_terms_1.uniqTerms)(variables.flat());
    }
    /**
     * Takes the union of the given metadata array.
     * It will ensure that the cardinality metadata value is properly calculated.
     * @param {{[p: string]: any}[]} metadatas Array of metadata.
     * @param bindings If the union of the variables field should also be taken.
     * @param context The action context
     * @param mediatorRdfMetadataAccumulate Mediator for metadata accumulation
     * @return {{[p: string]: any}} Union of the metadata.
     */
    static async unionMetadata(metadatas, bindings, context, mediatorRdfMetadataAccumulate) {
        let accumulatedMetadata = (await mediatorRdfMetadataAccumulate
            .mediate({ mode: 'initialize', context })).metadata;
        // Accumulate cardinality
        for (const appendingMetadata of metadatas) {
            accumulatedMetadata = {
                ...appendingMetadata,
                ...(await mediatorRdfMetadataAccumulate
                    .mediate({
                    mode: 'append',
                    accumulatedMetadata: accumulatedMetadata,
                    appendingMetadata: appendingMetadata,
                    context,
                })).metadata,
            };
        }
        // Create new metadata state
        accumulatedMetadata.state = new metadata_1.MetadataValidationState();
        // Propagate metadata invalidations
        const invalidateListener = () => accumulatedMetadata.state.invalidate();
        for (const metadata of metadatas) {
            metadata.state.addInvalidateListener(invalidateListener);
        }
        // Union variables
        if (bindings) {
            accumulatedMetadata.variables = ActorQueryOperationUnion
                .unionVariables(metadatas.map(metadata => metadata.variables));
        }
        return accumulatedMetadata;
    }
    async testOperation(_operation, _context) {
        return true;
    }
    async runOperation(operation, context) {
        // Determine the type over which we are taking a union
        const outputsRaw = await Promise.all(operation.input
            .map(subOperation => this.mediatorQueryOperation.mediate({ operation: subOperation, context })));
        let outputType;
        for (const output of outputsRaw) {
            if (outputType === undefined) {
                outputType = output.type;
            }
            else if (outputType !== output.type) {
                throw new Error(`Unable to union ${outputType} and ${output.type}`);
            }
        }
        // Handle bindings
        if (outputType === 'bindings' || operation.input.length === 0) {
            const outputs = outputsRaw.map(bus_query_operation_1.ActorQueryOperation.getSafeBindings);
            const bindingsStream = new asynciterator_1.UnionIterator(outputs.map((output) => output.bindingsStream), { autoStart: false });
            const metadata = () => Promise.all(outputs.map(output => output.metadata()))
                .then(subMeta => ActorQueryOperationUnion
                .unionMetadata(subMeta, true, context, this.mediatorRdfMetadataAccumulate));
            return { type: 'bindings', bindingsStream, metadata };
        }
        // Handle quads
        if (outputType === 'quads') {
            const outputs = outputsRaw.map(bus_query_operation_1.ActorQueryOperation.getSafeQuads);
            const quadStream = new asynciterator_1.UnionIterator(outputs.map((output) => output.quadStream), { autoStart: false });
            const metadata = () => Promise.all(outputs.map(output => output.metadata()))
                .then(subMeta => ActorQueryOperationUnion
                .unionMetadata(subMeta, false, context, this.mediatorRdfMetadataAccumulate));
            return { type: 'quads', quadStream, metadata };
        }
        // Throw otherwise
        throw new Error(`Unable to union ${outputType}`);
    }
}
exports.ActorQueryOperationUnion = ActorQueryOperationUnion;
//# sourceMappingURL=ActorQueryOperationUnion.js.map