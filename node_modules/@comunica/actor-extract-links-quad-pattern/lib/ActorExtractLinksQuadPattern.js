"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorExtractLinksQuadPattern = void 0;
const bus_extract_links_1 = require("@comunica/bus-extract-links");
const context_entries_1 = require("@comunica/context-entries");
const rdf_terms_1 = require("rdf-terms");
/**
 * A comunica Traverse Quad Pattern RDF Metadata Extract Actor.
 */
class ActorExtractLinksQuadPattern extends bus_extract_links_1.ActorExtractLinks {
    constructor(args) {
        super(args);
    }
    static getCurrentQuadPattern(context) {
        const currentQueryOperation = context.get(context_entries_1.KeysQueryOperation.operation);
        if (!currentQueryOperation || currentQueryOperation.type !== 'pattern') {
            return;
        }
        return currentQueryOperation;
    }
    async test(action) {
        if (!ActorExtractLinksQuadPattern.getCurrentQuadPattern(action.context)) {
            throw new Error(`Actor ${this.name} can only work in the context of a quad pattern.`);
        }
        return true;
    }
    async run(action) {
        const quadPattern = ActorExtractLinksQuadPattern
            .getCurrentQuadPattern(action.context);
        return {
            links: await bus_extract_links_1.ActorExtractLinks.collectStream(action.metadata, (quad, links) => {
                if (this.onlyVariables) {
                    // --- If we only want to follow links matching with a variable component ---
                    if ((0, rdf_terms_1.matchPatternComplete)(quad, quadPattern)) {
                        for (const quadTermName of (0, rdf_terms_1.filterQuadTermNames)(quadPattern, value => value.termType === 'Variable')) {
                            if (quad[quadTermName].termType === 'NamedNode') {
                                links.push({
                                    url: quad[quadTermName].value,
                                    metadata: { producedByActor: { name: this.name, onlyVariables: true } },
                                });
                            }
                        }
                    }
                }
                else {
                    // --- If we want to follow links, irrespective of matching with a variable component ---
                    // eslint-disable-next-line no-lonely-if
                    if ((0, rdf_terms_1.matchPatternComplete)(quad, quadPattern)) {
                        for (const link of (0, rdf_terms_1.getNamedNodes)((0, rdf_terms_1.getTerms)(quad))) {
                            links.push({
                                url: link.value,
                                metadata: { producedByActor: { name: this.name, onlyVariables: false } },
                            });
                        }
                    }
                }
            }),
        };
    }
}
exports.ActorExtractLinksQuadPattern = ActorExtractLinksQuadPattern;
//# sourceMappingURL=ActorExtractLinksQuadPattern.js.map