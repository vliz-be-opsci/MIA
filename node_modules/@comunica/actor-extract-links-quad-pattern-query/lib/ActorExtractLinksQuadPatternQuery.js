"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorExtractLinksQuadPatternQuery = void 0;
const bus_extract_links_1 = require("@comunica/bus-extract-links");
const context_entries_1 = require("@comunica/context-entries");
const rdf_data_factory_1 = require("rdf-data-factory");
const rdf_terms_1 = require("rdf-terms");
const sparqlalgebrajs_1 = require("sparqlalgebrajs");
const DF = new rdf_data_factory_1.DataFactory();
const VAR = DF.variable('__comunica:pp_var');
/**
 * A comunica Traverse Quad Pattern Query RDF Metadata Extract Actor.
 */
class ActorExtractLinksQuadPatternQuery extends bus_extract_links_1.ActorExtractLinks {
    constructor(args) {
        super(args);
    }
    static getCurrentQuery(context) {
        const currentQueryOperation = context.get(context_entries_1.KeysInitQuery.query);
        if (!currentQueryOperation) {
            return;
        }
        return currentQueryOperation;
    }
    static matchQuadPatternInOperation(quad, operation) {
        const matchingPatterns = [];
        sparqlalgebrajs_1.Util.recurseOperation(operation, {
            pattern(pattern) {
                if ((0, rdf_terms_1.matchPatternComplete)(quad, pattern)) {
                    matchingPatterns.push(pattern);
                }
                return false;
            },
            path(path) {
                sparqlalgebrajs_1.Util.recurseOperation(path, {
                    link(link) {
                        const pattern = DF.quad(VAR, link.iri, VAR, path.graph);
                        if ((0, rdf_terms_1.matchPatternComplete)(quad, pattern)) {
                            matchingPatterns.push(pattern);
                        }
                        return false;
                    },
                    nps(nps) {
                        for (const iri of nps.iris) {
                            const pattern = DF.quad(VAR, iri, VAR, path.graph);
                            if ((0, rdf_terms_1.matchPatternComplete)(quad, pattern)) {
                                matchingPatterns.push(pattern);
                            }
                        }
                        return false;
                    },
                });
                return false;
            },
        });
        return matchingPatterns;
    }
    async test(action) {
        if (!ActorExtractLinksQuadPatternQuery.getCurrentQuery(action.context)) {
            throw new Error(`Actor ${this.name} can only work in the context of a query.`);
        }
        return true;
    }
    async run(action) {
        const operation = ActorExtractLinksQuadPatternQuery
            .getCurrentQuery(action.context);
        return {
            links: await bus_extract_links_1.ActorExtractLinks.collectStream(action.metadata, (quad, links) => {
                const matchingPatterns = ActorExtractLinksQuadPatternQuery
                    .matchQuadPatternInOperation(quad, operation);
                if (matchingPatterns.length > 0) {
                    if (this.onlyVariables) {
                        // --- If we only want to follow links matching with a variable component ---
                        // Determine quad term names that we should check
                        const quadTermNames = {};
                        for (const quadPattern of matchingPatterns) {
                            for (const quadTermName of (0, rdf_terms_1.filterQuadTermNames)(quadPattern, value => value.termType === 'Variable')) {
                                quadTermNames[quadTermName] = true;
                            }
                        }
                        // For the discovered quad term names, check extract the named nodes in the quad
                        for (const quadTermName of Object.keys(quadTermNames)) {
                            if (quad[quadTermName].termType === 'NamedNode') {
                                links.push({
                                    url: quad[quadTermName].value,
                                    metadata: { producedByActor: { name: this.name, onlyVariables: this.onlyVariables } },
                                });
                            }
                        }
                    }
                    else {
                        // --- If we want to follow links, irrespective of matching with a variable component ---
                        for (const link of (0, rdf_terms_1.getNamedNodes)((0, rdf_terms_1.getTerms)(quad))) {
                            links.push({
                                url: link.value,
                                metadata: { producedByActor: { name: this.name, onlyVariables: this.onlyVariables } },
                            });
                        }
                    }
                }
            }),
        };
    }
}
exports.ActorExtractLinksQuadPatternQuery = ActorExtractLinksQuadPatternQuery;
//# sourceMappingURL=ActorExtractLinksQuadPatternQuery.js.map