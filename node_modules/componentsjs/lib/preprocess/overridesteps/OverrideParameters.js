"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OverrideParameters = void 0;
const Iris_1 = require("../../rdf/Iris");
const OverrideUtil_1 = require("./OverrideUtil");
/**
 * Override step that replaces properties of the target object.
 * Only the specified parameters will be replaced,
 * others will keep their original value.
 * In case the type is changed all original values will be removed.
 *
 * Uses the following override step fields:
 *  - `overrideValue`: New properties for the object.
 */
class OverrideParameters {
    canHandle(config, step) {
        return step.property.type.value === (0, Iris_1.PREFIX_OO)('OverrideParameters');
    }
    handle(config, step) {
        var _a;
        const { values } = (0, OverrideUtil_1.extractOverrideStepFields)(step, { parameters: 0, targets: 0, values: 1 });
        const partialResource = values[0];
        // In case the step has a different type, the properties of the previous step don't matter any more,
        // as the object is being replaced completely.
        const originalType = config.property.type.term;
        const newType = (_a = partialResource.property.type) === null || _a === void 0 ? void 0 : _a.term;
        // In case the type changes we have to delete all the original properties as those correspond to the old type
        if (newType && !newType.equals(originalType)) {
            for (const id of Object.keys(config.properties)) {
                delete config.properties[id];
            }
        }
        for (const property of Object.keys(partialResource.properties)) {
            config.properties[property] = partialResource.properties[property];
        }
        return config;
    }
}
exports.OverrideParameters = OverrideParameters;
//# sourceMappingURL=OverrideParameters.js.map