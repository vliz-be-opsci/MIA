"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findResourceIndex = exports.getPropertyResourceList = exports.extractOverrideStepFields = exports.OVERRIDE_STEP_FIELD_NAMES = void 0;
const Iris_1 = require("../../rdf/Iris");
const ErrorResourcesContext_1 = require("../../util/ErrorResourcesContext");
exports.OVERRIDE_STEP_FIELD_NAMES = ['parameter', 'target', 'value'];
/**
 * Extracts the fields from an override step and checks if the correct amount is present.
 * Will throw an error if the amount doesn't match what is expected.
 *
 * @param step - Override step to get the fields from.
 * @param expected - For each field, how many are expected. The value can be undefined if there is no fixed amount.
 */
function extractOverrideStepFields(step, expected = {}) {
    var _a, _b;
    // Type is not correct yet now but will be completed in the loop below
    const result = {};
    for (const key of exports.OVERRIDE_STEP_FIELD_NAMES) {
        const overrideKey = `override${key[0].toUpperCase()}${key.slice(1)}`;
        const propertiesKey = `${key}s`;
        const properties = step.properties[(0, Iris_1.PREFIX_OO)(overrideKey)];
        if (properties.length > 1) {
            throw new ErrorResourcesContext_1.ErrorResourcesContext(`Detected multiple values for ${overrideKey} in Override step ${step.value}. RDF lists should be used for defining multiple values.`, {
                overrideStep: step,
            });
        }
        const list = (_b = (_a = properties[0]) === null || _a === void 0 ? void 0 : _a.list) !== null && _b !== void 0 ? _b : properties;
        if (typeof expected[propertiesKey] === 'number' && list.length !== expected[propertiesKey]) {
            throw new ErrorResourcesContext_1.ErrorResourcesContext(`Expected ${expected[propertiesKey]} entries for ${overrideKey} but found ${list.length} in Override step ${step.value}`, {
                overrideStep: step,
            });
        }
        result[propertiesKey] = list;
    }
    return result;
}
exports.extractOverrideStepFields = extractOverrideStepFields;
/**
 * Returns a list containing all values for the given resource found with the given property.
 * In case there are multiple matches, the lists will be merged.
 * The parameter of the resource will be updated to have a single value which is the returned list,
 * so the returned list can be updated to modify the resource directly.
 *
 * @param config
 * @param parameter
 */
function getPropertyResourceList(config, parameter) {
    const properties = config.properties[parameter.value];
    if (!properties || properties.length === 0) {
        return [];
    }
    // Having multiple lists can happen if multiple config files add elements to the same list
    const list = properties.flatMap(prop => prop.list);
    if (list.some(res => res === undefined)) {
        throw new ErrorResourcesContext_1.ErrorResourcesContext(`Invalid target in Override step targeting ${config.value}: ${parameter.value} does not reference a list`, {
            config,
        });
    }
    config.properties[parameter.value] = [properties[0]];
    properties[0].list = list;
    return properties[0].list;
}
exports.getPropertyResourceList = getPropertyResourceList;
/**
 * Finds the index of the given resource in the given list.
 * Will throw an error if the resource is not found.
 *
 * @param list - The list to find the resource in.
 * @param target - The resource to find.
 */
function findResourceIndex(list, target) {
    const index = list.findIndex((element) => element.term.equals(target.term));
    if (index < 0) {
        throw new ErrorResourcesContext_1.ErrorResourcesContext(`Unable to find ${target.value} in targeted list while overriding.`, {
            target,
            list,
        });
    }
    return index;
}
exports.findResourceIndex = findResourceIndex;
//# sourceMappingURL=OverrideUtil.js.map