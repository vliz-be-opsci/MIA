"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OverrideMapEntry = void 0;
const Iris_1 = require("../../rdf/Iris");
const ErrorResourcesContext_1 = require("../../util/ErrorResourcesContext");
const OverrideUtil_1 = require("./OverrideUtil");
/**
 * Override step that updates an entry in a key/value map.
 *
 * Uses the following override step fields:
 *  - `overrideParameter`: Parameter of the original object that contains the key/value map.
 *  - `overrideTarget`: The key that needs to be updated.
 *  - `overrideValue`: The new value for the key. In case this is not defined, the key will be deleted instead.
 */
class OverrideMapEntry {
    canHandle(config, step) {
        return step.property.type.value === (0, Iris_1.PREFIX_OO)('OverrideMapEntry');
    }
    handle(config, step) {
        const { parameters, targets, values } = (0, OverrideUtil_1.extractOverrideStepFields)(step, { parameters: 1, targets: 1 });
        const properties = this.findProperties(config.property.type, parameters[0]);
        const entries = (0, OverrideUtil_1.getPropertyResourceList)(config, parameters[0]);
        const index = this.findEntryIndex(entries, targets[0], properties);
        if (values.length === 0) {
            // Remove the entry
            entries.splice(index, 1);
        }
        else {
            // Replace the value of the entry
            entries[index].properties[properties.value.value] = values;
        }
        return config;
    }
    /**
     * Finds the URIs used to link to the key and value of a map entry.
     *
     * @param type - Type of the class that contains the key/value map.
     * @param parameter - Parameter of the class used to link to the key/value map.
     */
    findProperties(type, parameter) {
        var _a, _b;
        const constructArgs = (_a = type.property.constructorArguments.list) !== null && _a !== void 0 ? _a : [];
        for (const arg of constructArgs) {
            const fields = (_b = arg.property.fields.list) !== null && _b !== void 0 ? _b : [];
            for (const field of fields) {
                let collectEntries = field.property.collectEntries;
                // Not sure when this is not a list in practice.
                // Based on behaviour in `ConstructorArgumentsElementMappingHandlerCollectEntries`.
                if (collectEntries.list) {
                    collectEntries = collectEntries.list[0];
                }
                if (collectEntries.term.equals(parameter.term)) {
                    return { key: field.property.key, value: field.property.value };
                }
            }
        }
        throw new ErrorResourcesContext_1.ErrorResourcesContext(`Unable to find key/value URIs for parameter ${parameter.value}`, {
            type,
            parameter,
        });
    }
    /**
     * Finds the index in a list of key/value map entries of the entry with the matching key.
     *
     * @param entries - List of key/value map entries.
     * @param key - Key of the entry to find.
     * @param properties - URIs used to link the key and value of a map entry.
     */
    findEntryIndex(entries, key, properties) {
        for (const [i, entry] of entries.entries()) {
            if (key.term.equals(entry.property[properties.key.value].term)) {
                return i;
            }
        }
        throw new ErrorResourcesContext_1.ErrorResourcesContext(`Unable to find key/value entry with key ${key.value}`, {
            entries,
            key,
            properties,
        });
    }
}
exports.OverrideMapEntry = OverrideMapEntry;
//# sourceMappingURL=OverrideMapEntry.js.map