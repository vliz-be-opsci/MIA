import type { Resource } from 'rdf-object';
import type { RdfObjectLoader } from 'rdf-object/lib/RdfObjectLoader';
import type { Logger } from 'winston';
import type { IConfigPreprocessor, IConfigPreprocessorTransform } from './IConfigPreprocessor';
/**
 * An {@link IConfigPreprocessor} that handles the overriding of parameters.
 * Values in the given {@link Resource}s will be replaced if any overriding object is found,
 * targeting this resource.
 */
export declare class ConfigPreprocessorOverride implements IConfigPreprocessor<Resource[]> {
    readonly objectLoader: RdfObjectLoader;
    readonly componentResources: Record<string, Resource>;
    readonly logger: Logger;
    private readonly stepHandlers;
    private overrides;
    constructor(options: IComponentConfigPreprocessorOverrideOptions);
    /**
     * Checks if there are any overrides targeting the given resource.
     * @param config - Resource to find overrides for.
     *
     * @returns A list of override steps to apply to the target, in order.
     */
    canHandle(config: Resource): Resource[] | undefined;
    /**
     * Override the resource with the stored override steps.
     * @param config - The resource to override.
     * @param handleResponse - Override steps that were found for this resource.
     */
    transform(config: Resource, handleResponse: Resource[]): IConfigPreprocessorTransform;
    /**
     * Clear all cached overrides, so they will be calculated again on the next call.
     */
    reset(): void;
    /**
     * Generates a cache of all overrides found in the object loader.
     * Keys of the object are the identifiers of the resources that need to be modified,
     * values are key/value maps listing all parameters with their new values.
     */
    createOverrideSteps(): Record<string, Resource[]>;
    /**
     * Finds all Override resources in the object loader and links them to their target resource.
     */
    protected findOverrideTargets(): Iterable<{
        override: Resource;
        target: Resource;
    }>;
    /**
     * Chains all Overrides together if they reference each other.
     * E.g., if the input is a list of Overrides A -> B, B -> C, D -> E,
     * the result wil be [[ A, B, C ], [ D, E ]].
     * The last element in the array will always be the non-Override resource being targeted.
     *
     * @param overrides - All Overrides that have to be combined.
     */
    protected createOverrideChains(overrides: {
        override: Resource;
        target: Resource;
    }[]): Resource[][];
    /**
     * Throws an error in case there are 2 chains targeting the same resource.
     * @param chains - The override chains to check.
     */
    protected validateChains(chains: Resource[][]): void;
    /**
     * Merges all Overrides in a chain to create a single list of override steps.
     * The order of the steps is the order in which they should be applied,
     * with the first entry being the first step of the override closest to the target resource.
     *
     * @param chain - The chain of Overrides, with a normal resource as the last entry in the array.
     */
    protected chainToOverrideSteps(chain: Resource[]): {
        target: Resource;
        steps: Resource[];
    };
    /**
     * Finds the final target and validates its type value.
     * @param chain - The chain to find the target of.
     */
    protected getChainTarget(chain: Resource[]): Resource;
    /**
     *
     * @param override
     * @protected
     */
    protected simplifiedOverrideToStep(override: Resource): Resource;
}
export interface IComponentConfigPreprocessorOverrideOptions {
    objectLoader: RdfObjectLoader;
    componentResources: Record<string, Resource>;
    logger: Logger;
}
