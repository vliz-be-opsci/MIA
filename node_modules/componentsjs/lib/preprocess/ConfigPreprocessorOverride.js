"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigPreprocessorOverride = void 0;
const Iris_1 = require("../rdf/Iris");
const ResourceUtil_1 = require("../rdf/ResourceUtil");
const ErrorResourcesContext_1 = require("../util/ErrorResourcesContext");
const OverrideListInsertAfter_1 = require("./overridesteps/OverrideListInsertAfter");
const OverrideListInsertAt_1 = require("./overridesteps/OverrideListInsertAt");
const OverrideListInsertBefore_1 = require("./overridesteps/OverrideListInsertBefore");
const OverrideListRemove_1 = require("./overridesteps/OverrideListRemove");
const OverrideMapEntry_1 = require("./overridesteps/OverrideMapEntry");
const OverrideParameters_1 = require("./overridesteps/OverrideParameters");
/**
 * An {@link IConfigPreprocessor} that handles the overriding of parameters.
 * Values in the given {@link Resource}s will be replaced if any overriding object is found,
 * targeting this resource.
 */
class ConfigPreprocessorOverride {
    constructor(options) {
        this.objectLoader = options.objectLoader;
        this.componentResources = options.componentResources;
        this.logger = options.logger;
        this.stepHandlers = [
            new OverrideParameters_1.OverrideParameters(),
            new OverrideListInsertBefore_1.OverrideListInsertBefore(),
            new OverrideListInsertAfter_1.OverrideListInsertAfter(),
            new OverrideListInsertAt_1.OverrideListInsertAt(),
            new OverrideListRemove_1.OverrideListRemove(),
            new OverrideMapEntry_1.OverrideMapEntry(),
        ];
    }
    /**
     * Checks if there are any overrides targeting the given resource.
     * @param config - Resource to find overrides for.
     *
     * @returns A list of override steps to apply to the target, in order.
     */
    canHandle(config) {
        if (!this.overrides) {
            this.overrides = this.createOverrideSteps();
        }
        return this.overrides[config.value];
    }
    /**
     * Override the resource with the stored override steps.
     * @param config - The resource to override.
     * @param handleResponse - Override steps that were found for this resource.
     */
    transform(config, handleResponse) {
        // Apply all override steps sequentially
        for (const step of handleResponse) {
            let handler;
            for (const stepHandler of this.stepHandlers) {
                if (stepHandler.canHandle(config, step)) {
                    handler = stepHandler;
                    break;
                }
            }
            if (!handler) {
                throw new ErrorResourcesContext_1.ErrorResourcesContext(`Found no handler supporting an override step of type ${step.property.type.value}`, {
                    step,
                });
            }
            handler.handle(config, step);
        }
        return { rawConfig: config, finishTransformation: false };
    }
    /**
     * Clear all cached overrides, so they will be calculated again on the next call.
     */
    reset() {
        this.overrides = undefined;
    }
    /**
     * Generates a cache of all overrides found in the object loader.
     * Keys of the object are the identifiers of the resources that need to be modified,
     * values are key/value maps listing all parameters with their new values.
     */
    createOverrideSteps() {
        const overrides = [...this.findOverrideTargets()];
        const chains = this.createOverrideChains(overrides);
        this.validateChains(chains);
        const overrideSteps = {};
        for (const chain of chains) {
            const { target, steps } = this.chainToOverrideSteps(chain);
            if (Object.keys(steps).length > 0) {
                overrideSteps[target.value] = steps;
            }
        }
        return overrideSteps;
    }
    /**
     * Finds all Override resources in the object loader and links them to their target resource.
     */
    *findOverrideTargets() {
        for (const [id, resource] of Object.entries(this.objectLoader.resources)) {
            if (resource.isA(Iris_1.IRIS_OO.Override) && resource.value !== Iris_1.IRIS_OO.Override) {
                const targets = resource.properties[Iris_1.IRIS_OO.overrideInstance];
                if (!targets || targets.length === 0) {
                    this.logger.warn(`Missing overrideInstance for ${id}. This Override will be ignored.`);
                    continue;
                }
                if (targets.length > 1) {
                    throw new ErrorResourcesContext_1.ErrorResourcesContext(`Detected multiple overrideInstance targets for ${id}`, {
                        override: resource,
                    });
                }
                yield { override: resource, target: targets[0] };
            }
        }
    }
    /**
     * Chains all Overrides together if they reference each other.
     * E.g., if the input is a list of Overrides A -> B, B -> C, D -> E,
     * the result wil be [[ A, B, C ], [ D, E ]].
     * The last element in the array will always be the non-Override resource being targeted.
     *
     * @param overrides - All Overrides that have to be combined.
     */
    createOverrideChains(overrides) {
        // Start by creating small chains: from each override to its immediate target
        const overrideChains = Object.fromEntries(overrides.map(({ override, target }) => [override.value, [override, target]]));
        // Then keep combining those smaller chains into bigger chains until they are complete.
        // If there is an override cycle (A -> B -> ... -> A) it will delete itself from the list of chains here.
        let change = true;
        while (change) {
            change = false;
            for (const [id, chain] of Object.entries(overrideChains)) {
                let next = chain[chain.length - 1];
                // If the next part of the chain is found in `overrideChains` we can merge them and remove the tail entry
                while (overrideChains[next.value]) {
                    change = true;
                    const nextChain = overrideChains[next.value];
                    // First element of nextChain will be equal to last element of this chain
                    overrideChains[id].push(...nextChain.slice(1));
                    // In case of a cycle there will be a point where next equals the first element,
                    // at which point it will delete itself.
                    delete overrideChains[next.value];
                    next = chain[chain.length - 1];
                }
                // Reset the loop since we are modifying the object we are iterating over
                if (change) {
                    break;
                }
            }
        }
        return Object.values(overrideChains);
    }
    /**
     * Throws an error in case there are 2 chains targeting the same resource.
     * @param chains - The override chains to check.
     */
    validateChains(chains) {
        const targets = chains.map((chain) => chain[chain.length - 1].value);
        for (let i = 0; i < targets.length; ++i) {
            const duplicateIdx = targets.findIndex((target, idx) => idx > i && target === targets[i]);
            if (duplicateIdx > 0) {
                const target = chains[i][chains[i].length - 1];
                const duplicate1 = chains[i][chains[i].length - 2];
                const duplicate2 = chains[duplicateIdx][chains[duplicateIdx].length - 2];
                throw new ErrorResourcesContext_1.ErrorResourcesContext(`Found multiple Overrides targeting ${targets[i]}`, {
                    target,
                    overrides: [duplicate1, duplicate2],
                });
            }
        }
    }
    /**
     * Merges all Overrides in a chain to create a single list of override steps.
     * The order of the steps is the order in which they should be applied,
     * with the first entry being the first step of the override closest to the target resource.
     *
     * @param chain - The chain of Overrides, with a normal resource as the last entry in the array.
     */
    chainToOverrideSteps(chain) {
        var _a, _b;
        const target = this.getChainTarget(chain);
        const steps = [];
        for (let i = chain.length - 2; i >= 0; --i) {
            const subStepProperties = chain[i].properties[Iris_1.IRIS_OO.overrideSteps];
            if (subStepProperties.length > 1) {
                throw new ErrorResourcesContext_1.ErrorResourcesContext(`Detected multiple values for overrideSteps in Override ${chain[i].value}. RDF lists should be used for defining multiple values.`, {
                    override: chain[i],
                });
            }
            let subSteps = (_b = (_a = subStepProperties[0]) === null || _a === void 0 ? void 0 : _a.list) !== null && _b !== void 0 ? _b : subStepProperties;
            // Translate simplified format to override step
            if (chain[i].properties[Iris_1.IRIS_OO.overrideParameters].length > 0) {
                subSteps = [this.simplifiedOverrideToStep(chain[i])];
            }
            if (subSteps.length === 0) {
                this.logger.warn(`No steps found for Override ${chain[i].value}. This Override will be ignored.`);
                continue;
            }
            steps.push(...subSteps);
        }
        return { target, steps };
    }
    /**
     * Finds the final target and validates its type value.
     * @param chain - The chain to find the target of.
     */
    getChainTarget(chain) {
        const target = chain[chain.length - 1];
        const types = (0, ResourceUtil_1.uniqueTypes)(target, this.componentResources);
        if (!types || types.length === 0) {
            throw new ErrorResourcesContext_1.ErrorResourcesContext(`Missing type for override target ${target.value} of Override ${chain[chain.length - 2].value}`, {
                target,
                override: chain[chain.length - 2],
            });
        }
        if (types.length > 1) {
            throw new ErrorResourcesContext_1.ErrorResourcesContext(`Found multiple types for override target ${target.value} of Override ${chain[chain.length - 2].value}`, {
                target,
                override: chain[chain.length - 2],
            });
        }
        return target;
    }
    /**
     *
     * @param override
     * @protected
     */
    simplifiedOverrideToStep(override) {
        const overrideObjects = override.properties[Iris_1.IRIS_OO.overrideParameters];
        if (overrideObjects.length > 1) {
            throw new ErrorResourcesContext_1.ErrorResourcesContext(`Detected multiple values for overrideParameters in Override ${override.value}`, {
                override,
            });
        }
        return this.objectLoader.createCompactedResource({
            types: (0, Iris_1.PREFIX_OO)('OverrideParameters'),
            overrideValue: overrideObjects[0],
        });
    }
}
exports.ConfigPreprocessorOverride = ConfigPreprocessorOverride;
//# sourceMappingURL=ConfigPreprocessorOverride.js.map